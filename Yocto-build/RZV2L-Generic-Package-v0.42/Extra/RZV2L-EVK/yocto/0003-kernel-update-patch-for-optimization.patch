From 3f90a4d1b7f1904879778cb1699edc12eaf454c6 Mon Sep 17 00:00:00 2001
From: Vu Dang <vu.dang.te@renesas.com>
Date: Thu, 12 Jan 2023 10:09:06 +0000
Subject: [PATCH 3/5] kernel: update patch for optimization

Signed-off-by: Vu Dang <vu.dang.te@renasas.com>
---
 ...hat-caused-flicker-when-outputting-t.patch |    7 +-
 ...renesas-Update-defconfig-for-v2l-opt.patch | 1018 ++++
 ...s-renesas-disable-OSTM2-I2C0-and-CRU.patch |   51 +
 ...-dts-renesas-change-default-bootargs.patch |   27 +
 ...7g044-Set-SCIF2-OSTM2-CRU-I2C0-as-cr.patch |   32 +
 ...-add-DPR-AI-support-for-RZ-V2L-board.patch | 5142 +++++++++++++++++
 ...-GPU-driver-remove-power-domains-v2l.patch |   25 +
 .../linux/linux-renesas_5.10.bbappend         |    9 +
 .../linux/linux-renesas_5.10.bbappend         |   20 +-
 .../mali/linux-renesas_5.10.bbappend          |   12 +-
 .../linux/linux-renesas_5.10.bbappend         |   12 +-
 11 files changed, 6330 insertions(+), 25 deletions(-)
 create mode 100644 meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-arm64-defconfig-renesas-Update-defconfig-for-v2l-opt.patch
 create mode 100644 meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0002-arm64-dts-renesas-disable-OSTM2-I2C0-and-CRU.patch
 create mode 100644 meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0003-arm64-dts-renesas-change-default-bootargs.patch
 create mode 100644 meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0004-clk-renesas-r9a07g044-Set-SCIF2-OSTM2-CRU-I2C0-as-cr.patch
 create mode 100644 meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0005-driver-DRP-AI-add-DPR-AI-support-for-RZ-V2L-board.patch
 create mode 100644 meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0006-Workaround-GPU-driver-remove-power-domains-v2l.patch

diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-Fixed-an-issue-that-caused-flicker-when-outputting-t.patch b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-Fixed-an-issue-that-caused-flicker-when-outputting-t.patch
index 4f95e9b..97cd9f2 100644
--- a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-Fixed-an-issue-that-caused-flicker-when-outputting-t.patch
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-Fixed-an-issue-that-caused-flicker-when-outputting-t.patch
@@ -1,7 +1,8 @@
-From 1fbe97ec036062779dc1d15040cdb4d7b7aa6d34 Mon Sep 17 00:00:00 2001
+From 2812b6099e769cf5369a9271aa276267a094aa06 Mon Sep 17 00:00:00 2001
 From: Hien Huynh <hien.huynh.px@renesas.com>
 Date: Sun, 6 Mar 2022 00:18:41 +0700
-Subject: [PATCH] Fixed an issue that caused flicker when outputting the screen
+Subject: [PATCH 1/6] Fixed an issue that caused flicker when outputting the
+ screen
 
 This commit is created to fix flickerring issue.
 
@@ -30,7 +31,7 @@ index aa19d5a40e31..eb39b4f5eeba 100644
  		return;
  
 diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
-index 8913bdea4b96..c52583a7d445 100644
+index cd01a34c1abd..900566a2f9fa 100644
 --- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
 +++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
 @@ -224,153 +224,209 @@ struct cpg_param {
diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-arm64-defconfig-renesas-Update-defconfig-for-v2l-opt.patch b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-arm64-defconfig-renesas-Update-defconfig-for-v2l-opt.patch
new file mode 100644
index 0000000..d71fcde
--- /dev/null
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0001-arm64-defconfig-renesas-Update-defconfig-for-v2l-opt.patch
@@ -0,0 +1,1018 @@
+From 29ded428e7505bc9d50fe66aa7bd084768c93d9a Mon Sep 17 00:00:00 2001
+From: Vu Dang <vu.dang.te@renasas.com>
+Date: Wed, 11 Jan 2023 15:49:36 +0700
+Subject: [PATCH] arm64: defconfig: renesas: Update defconfig for v2l
+ optimization
+
+Signed-off-by: Vu Dang <vu.dang.te@renasas.com>
+---
+ arch/arm64/configs/defconfig | 969 ++++++++++++++++++++++++++++++++++-
+ 1 file changed, 962 insertions(+), 7 deletions(-)
+
+diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
+index 5f8032094b6d..8cbc01e79e39 100644
+--- a/arch/arm64/configs/defconfig
++++ b/arch/arm64/configs/defconfig
+@@ -152,8 +152,8 @@ CONFIG_INPUT_TOUCHSCREEN=y
+ CONFIG_TOUCHSCREEN_USB_COMPOSITE=y
+ CONFIG_INPUT_PM8941_PWRKEY=y
+ CONFIG_INPUT_HISI_POWERKEY=y
+-CONFIG_INPUT_UINPUT=m
+-CONFIG_INPUT_MOUSEDEV=m
++CONFIG_INPUT_UINPUT=n
++CONFIG_INPUT_MOUSEDEV=n
+ # CONFIG_MOUSE_PS2 is not set
+ CONFIG_INPUT_MISC=y
+ # CONFIG_SERIO is not set
+@@ -211,7 +211,7 @@ CONFIG_VIDEO_RZG2L_CRU=y
+ CONFIG_VIDEO_RZG2L_CSI2=y
+ CONFIG_V4L_MEM2MEM_DRIVERS=y
+ CONFIG_MEDIA_USB_SUPPORT=y
+-CONFIG_USB_VIDEO_CLASS=m
++CONFIG_USB_VIDEO_CLASS=n
+ CONFIG_VIDEO_RENESAS_FDP1=y
+ CONFIG_VIDEO_RENESAS_FCP=y
+ CONFIG_VIDEO_RENESAS_VSP1=y
+@@ -311,9 +311,9 @@ CONFIG_USB_SNP_UDC_PLAT=y
+ CONFIG_USB_BDC_UDC=y
+ CONFIG_TYPEC=y
+ CONFIG_TYPEC_HD3SS3220=y
+-CONFIG_USB_MASS_STORAGE=m
+-CONFIG_USB_G_SERIAL=m
+-CONFIG_USB_ETH=m
++CONFIG_USB_MASS_STORAGE=n
++CONFIG_USB_G_SERIAL=n
++CONFIG_USB_ETH=n
+ CONFIG_MMC=y
+ CONFIG_MMC_SDHI=y
+ CONFIG_NEW_LEDS=y
+@@ -402,10 +402,965 @@ CONFIG_DEVFREQ_GOV_PASSIVE=y
+ CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+ CONFIG_E1000E=y
+ CONFIG_RENESAS_MFIS_ECC=y
+-CONFIG_VIDEOBUF2_DMA_CONTIG=m
++CONFIG_VIDEOBUF2_DMA_CONTIG=n
+ CONFIG_RZ_DMAC=y
+ CONFIG_RZG2L_THERMAL=y
+ CONFIG_RENESAS_TIMER_MTU3=y
+ CONFIG_RENESAS_POE3=y
+ CONFIG_GPT_RZG2L=y
+ CONFIG_POEG_RZG2L=y
++
++CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION=n
++CONFIG_ARCH_ENABLE_THP_MIGRATION=n
++CONFIG_ARCH_HAS_PTE_SPECIAL=n
++CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS=n
++CONFIG_ARCH_HIBERNATION_HEADER=n
++CONFIG_ARCH_HIBERNATION_POSSIBLE=n
++CONFIG_ARCH_MMAP_RND_BITS_MAX=33
++CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
++CONFIG_ARCH_RANDOM=n
++CONFIG_ARCH_SUPPORTS_ACPI=n
++CONFIG_ARCH_USES_HIGH_VMA_FLAGS=n
++CONFIG_ARCH_USE_MEMREMAP_PROT=n
++CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=n
++CONFIG_ARM64_AMU_EXTN=n
++CONFIG_ARM64_BTI=n
++CONFIG_ARM64_CNP=n
++CONFIG_ARM64_CRYPTO=n
++CONFIG_ARM64_E0PD=n
++CONFIG_ARM64_ERRATUM_1024718=n
++CONFIG_ARM64_ERRATUM_1165522=n
++CONFIG_ARM64_ERRATUM_1286807=n
++CONFIG_ARM64_ERRATUM_1319367=n
++CONFIG_ARM64_ERRATUM_1418040=n
++CONFIG_ARM64_ERRATUM_1463225=n
++CONFIG_ARM64_ERRATUM_1508412=n
++CONFIG_ARM64_ERRATUM_1530923=n
++CONFIG_ARM64_ERRATUM_1542419=n
++CONFIG_ARM64_ERRATUM_819472=n
++CONFIG_ARM64_ERRATUM_824069=n
++CONFIG_ARM64_ERRATUM_826319=n
++CONFIG_ARM64_ERRATUM_827319=n
++CONFIG_ARM64_ERRATUM_832075=n
++CONFIG_ARM64_ERRATUM_834220=n
++CONFIG_ARM64_ERRATUM_843419=n
++CONFIG_ARM64_ERRATUM_845719=n
++CONFIG_ARM64_HW_AFDBM=n
++CONFIG_ARM64_LSE_ATOMICS=n
++CONFIG_ARM64_MODULE_PLTS=n
++CONFIG_ARM64_MTE=n
++CONFIG_ARM64_PAN=n
++CONFIG_ARM64_PTR_AUTH=n
++CONFIG_ARM64_SVE=n
++CONFIG_ARM64_TAGGED_ADDR_ABI=n
++CONFIG_ARM64_TLB_RANGE=n
++CONFIG_ARM64_UAO=n
++CONFIG_ARM64_USE_LSE_ATOMICS=n
++CONFIG_ARM64_VA_BITS_48=n
++CONFIG_ARM64_VHE=n
++CONFIG_ARM64_WORKAROUND_CLEAN_CACHE=n
++CONFIG_ARM64_WORKAROUND_REPEAT_TLBI=n
++CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT=n
++CONFIG_ARM_ARCH_TIMER_EVTSTREAM=n
++CONFIG_ARM_CPUIDLE=n
++CONFIG_ARM_GIC_V2M=n
++CONFIG_ARM_GIC_V3_ITS_PCI=n
++CONFIG_ARM_PMU=n
++CONFIG_ARM_PSCI_CPUIDLE=n
++CONFIG_ARM_PSCI_CPUIDLE_DOMAIN=n
++CONFIG_ARM_SMCCC_SOC_ID=n
++CONFIG_ASSOCIATIVE_ARRAY=n
++CONFIG_ATA_BMDMA=n
++CONFIG_ATA_SFF=n
++CONFIG_ATA_VERBOSE_ERROR=n
++CONFIG_AUDIT=n
++CONFIG_AUDITSYSCALL=n
++CONFIG_AUDIT_COMPAT_GENERIC=n
++CONFIG_AUDIT_GENERIC=n
++CONFIG_BACKLIGHT_PWM=n
++CONFIG_BALLOON_COMPACTION=n
++CONFIG_BLK_CGROUP=n
++CONFIG_BLK_DEV_INITRD=n
++CONFIG_BLK_DEV_INTEGRITY=n
++CONFIG_BLK_DEV_INTEGRITY_T10=n
++CONFIG_BLK_MQ_PCI=n
++CONFIG_BLK_MQ_VIRTIO=n
++CONFIG_BLOCK_COMPAT=n
++CONFIG_BOUNCE=n
++CONFIG_BSD_PROCESS_ACCT=n
++CONFIG_BSD_PROCESS_ACCT_V3=n
++CONFIG_BT=n
++CONFIG_BT_BNEP=n
++CONFIG_BT_BNEP_MC_FILTER=n
++CONFIG_BT_BNEP_PROTO_FILTER=n
++CONFIG_BT_BREDR=n
++CONFIG_BT_DEBUGFS=n
++CONFIG_BT_HCIUART=n
++CONFIG_BT_HCIUART_BCSP=n
++CONFIG_BT_HCIUART_H4=n
++CONFIG_BT_HCIVHCI=n
++CONFIG_BT_HIDP=n
++CONFIG_BT_LE=n
++CONFIG_BT_RFCOMM=n
++CONFIG_BT_RFCOMM_TTY=n
++CONFIG_CAN=n
++CONFIG_CAN_BCM=n
++CONFIG_CAN_CALC_BITTIMING=n
++CONFIG_CAN_DEV=n
++CONFIG_CAN_GW=n
++CONFIG_CAN_RAW=n
++CONFIG_CAN_RCAR=n
++CONFIG_CAN_RCAR_CANFD=n
++CONFIG_CAVIUM_TX2_ERRATUM_219=n
++CONFIG_CEC_CORE=n
++CONFIG_CEC_NOTIFIER=n
++CONFIG_CGROUP_CPUACCT=n
++CONFIG_CGROUP_DEVICE=n
++CONFIG_CGROUP_HUGETLB=n
++CONFIG_CGROUP_PERF=n
++CONFIG_CGROUP_PIDS=n
++CONFIG_CGROUP_WRITEBACK=n
++CONFIG_CHROME_PLATFORMS=n
++CONFIG_CLKSRC_MMIO=n
++CONFIG_CLK_RCAR_USB2_CLOCK_SEL=n
++CONFIG_CMA_ALIGNMENT=9
++CONFIG_CMA_AREAS=7
++CONFIG_CMA_SIZE_MBYTES=128
++CONFIG_CMA_SIZE_SEL_MBYTES=n
++CONFIG_COMMON_CLK_CS2000_CP=n
++CONFIG_COMMON_CLK_PWM=n
++CONFIG_COMMON_CLK_VC5=n
++CONFIG_COMPACTION=n
++CONFIG_CONTIG_ALLOC=n
++CONFIG_CPU_FREQ_THERMAL=n
++CONFIG_CPU_IDLE=n
++CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=n
++CONFIG_CPU_ISOLATION=n
++CONFIG_CPU_THERMAL=n
++CONFIG_CRASH_CORE=n
++CONFIG_CRASH_DUMP=n
++CONFIG_CRC_T10DIF=n
++CONFIG_CROSS_MEMORY_ATTACH=n
++CONFIG_CRYPTO_ACOMP2=n
++CONFIG_CRYPTO_AEAD2=n
++CONFIG_CRYPTO_AEAD=n
++CONFIG_CRYPTO_AES=n
++CONFIG_CRYPTO_AES_ARM64=n
++CONFIG_CRYPTO_AES_ARM64_CE=n
++CONFIG_CRYPTO_AES_ARM64_CE_BLK=n
++CONFIG_CRYPTO_AES_ARM64_CE_CCM=n
++CONFIG_CRYPTO_AKCIPHER2=n
++CONFIG_CRYPTO_ANSI_CPRNG=n
++CONFIG_CRYPTO_AUTHENC=n
++CONFIG_CRYPTO_CBC=n
++CONFIG_CRYPTO_CRCT10DIF=n
++CONFIG_CRYPTO_CRYPTD=n
++CONFIG_CRYPTO_CTR=n
++CONFIG_CRYPTO_DEV_CCREE=n
++CONFIG_CRYPTO_ECB=n
++CONFIG_CRYPTO_GF128MUL=n
++CONFIG_CRYPTO_GHASH_ARM64_CE=n
++CONFIG_CRYPTO_HMAC=n
++CONFIG_CRYPTO_HW=n
++CONFIG_CRYPTO_KPP2=n
++CONFIG_CRYPTO_LIB_AES=n
++CONFIG_CRYPTO_LIB_DES=n
++CONFIG_CRYPTO_LIB_SHA256=n
++CONFIG_CRYPTO_MANAGER2=n
++CONFIG_CRYPTO_MANAGER=n
++CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=n
++CONFIG_CRYPTO_MD5=n
++CONFIG_CRYPTO_NULL2=n
++CONFIG_CRYPTO_NULL=n
++CONFIG_CRYPTO_RNG2=n
++CONFIG_CRYPTO_RNG=n
++CONFIG_CRYPTO_SHA1=n
++CONFIG_CRYPTO_SHA1_ARM64_CE=n
++CONFIG_CRYPTO_SHA256=n
++CONFIG_CRYPTO_SHA256_ARM64=n
++CONFIG_CRYPTO_SHA2_ARM64_CE=n
++CONFIG_CRYPTO_SHA512=n
++CONFIG_CRYPTO_SIMD=n
++CONFIG_CRYPTO_SKCIPHER2=n
++CONFIG_CRYPTO_SKCIPHER=n
++CONFIG_CRYPTO_SM3=n
++CONFIG_CRYPTO_SM4=n
++CONFIG_CRYPTO_XTS=n
++CONFIG_DEBUG_MISC=n
++CONFIG_DECOMPRESS_BZIP2=n
++CONFIG_DECOMPRESS_GZIP=n
++CONFIG_DECOMPRESS_LZ4=n
++CONFIG_DECOMPRESS_LZMA=n
++CONFIG_DECOMPRESS_LZO=n
++CONFIG_DECOMPRESS_XZ=n
++CONFIG_DECOMPRESS_ZSTD=n
++CONFIG_DEVFREQ_GOV_PASSIVE=n
++CONFIG_DEVFREQ_GOV_PERFORMANCE=n
++CONFIG_DEVFREQ_GOV_POWERSAVE=n
++CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=n
++CONFIG_DEVFREQ_GOV_USERSPACE=n
++CONFIG_DMA_OPS=n
++CONFIG_DMI=n
++CONFIG_DNOTIFY=n
++CONFIG_DNS_RESOLVER=n
++CONFIG_DRM=n
++CONFIG_DRM_BRIDGE=n
++CONFIG_DRM_DW_HDMI=n
++CONFIG_DRM_DW_HDMI_AHB_AUDIO=n
++CONFIG_DRM_DW_HDMI_CEC=n
++CONFIG_DRM_DW_HDMI_I2S_AUDIO=n
++CONFIG_DRM_FBDEV_EMULATION=n
++CONFIG_DRM_FBDEV_OVERALLOC=100
++CONFIG_DRM_GEM_CMA_HELPER=n
++CONFIG_DRM_I2C_ADV7511=n
++CONFIG_DRM_I2C_ADV7511_AUDIO=n
++CONFIG_DRM_I2C_ADV7511_CEC=n
++CONFIG_DRM_I2C_NXP_TDA998X=n
++CONFIG_DRM_KMS_CMA_HELPER=n
++CONFIG_DRM_KMS_FB_HELPER=n
++CONFIG_DRM_KMS_HELPER=n
++CONFIG_DRM_MIPI_DSI=n
++CONFIG_DRM_PANEL=n
++CONFIG_DRM_PANEL_BRIDGE=n
++CONFIG_DRM_PANEL_LVDS=n
++CONFIG_DRM_PANEL_ORIENTATION_QUIRKS=n
++CONFIG_DRM_RCAR_CMM=n
++CONFIG_DRM_RCAR_DU=n
++CONFIG_DRM_RCAR_DW_HDMI=n
++CONFIG_DRM_RCAR_LVDS=n
++CONFIG_DRM_RCAR_VSP=n
++CONFIG_DRM_RCAR_WRITEBACK=n
++CONFIG_DRM_RZG2L_MIPI_DSI=n
++CONFIG_DRM_THINE_THC63LVD1024=n
++CONFIG_DT_IDLE_STATES=n
++CONFIG_DUMMY_CONSOLE=n
++CONFIG_E1000E=n
++CONFIG_EDAC_SUPPORT=n
++CONFIG_EFI=n
++CONFIG_EFIVAR_FS=n
++CONFIG_EFI_ARMSTUB_DTB_LOADER=n
++CONFIG_EFI_EARLYCON=n
++CONFIG_EFI_ESRT=n
++CONFIG_EFI_GENERIC_STUB=n
++CONFIG_EFI_GENERIC_STUB_INITRD_CMDLINE_LOADER=n
++CONFIG_EFI_PARAMS_FROM_FDT=n
++CONFIG_EFI_RUNTIME_WRAPPERS=n
++CONFIG_EFI_STUB=n
++CONFIG_ENABLE_MUST_CHECK=n
++CONFIG_ETHERNET=n
++CONFIG_ETHTOOL_NETLINK=n
++CONFIG_EXT4_FS_POSIX_ACL=n
++CONFIG_EXT4_USE_FOR_EXT2=n
++CONFIG_EXTCON=n
++CONFIG_EXTCON_USB_GPIO=n
++CONFIG_FAIR_GROUP_SCHED=n
++CONFIG_FANOTIFY=n
++CONFIG_FB=n
++CONFIG_FB_CFB_COPYAREA=n
++CONFIG_FB_CFB_FILLRECT=n
++CONFIG_FB_CFB_IMAGEBLIT=n
++CONFIG_FB_CMDLINE=n
++CONFIG_FB_DEFERRED_IO=n
++CONFIG_FB_MODE_HELPERS=n
++CONFIG_FB_NOTIFY=n
++CONFIG_FB_SYS_COPYAREA=n
++CONFIG_FB_SYS_FILLRECT=n
++CONFIG_FB_SYS_FOPS=n
++CONFIG_FB_SYS_IMAGEBLIT=n
++CONFIG_FIXED_PHY=n
++CONFIG_FONT_8x16=n
++CONFIG_FONT_8x8=n
++CONFIG_FONT_SUPPORT=n
++CONFIG_FRAMEBUFFER_CONSOLE=n
++CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=n
++CONFIG_FRAME_VECTOR=n
++CONFIG_FREEZER=n
++CONFIG_FS_POSIX_ACL=n
++CONFIG_FUJITSU_ERRATUM_010001=n
++CONFIG_FW_CACHE=n
++CONFIG_GENERIC_IRQ_MIGRATION=n
++CONFIG_GPIO_BD9571MWV=n
++CONFIG_GPIO_CDEV_V1=n
++CONFIG_GPIO_PCA953X=n
++CONFIG_GPIO_PCA953X_IRQ=n
++CONFIG_GPIO_SYSFS=n
++CONFIG_GPT_RZG2L=n
++CONFIG_GRACE_PERIOD=n
++CONFIG_HAS_IOPORT_MAP=n
++CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=n
++CONFIG_HAVE_HW_BREAKPOINT=n
++CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL=n
++CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=n
++CONFIG_HAVE_KVM_EVENTFD=n
++CONFIG_HAVE_KVM_IRQCHIP=n
++CONFIG_HAVE_KVM_IRQFD=n
++CONFIG_HAVE_KVM_IRQ_BYPASS=n
++CONFIG_HAVE_KVM_IRQ_ROUTING=n
++CONFIG_HAVE_KVM_MSI=n
++CONFIG_HAVE_KVM_VCPU_RUN_PID_CHANGE=n
++CONFIG_HAVE_MOD_ARCH_SPECIFIC=n
++CONFIG_HAVE_NET_DSA=n
++CONFIG_HAVE_SCHED_AVG_IRQ=n
++CONFIG_HAVE_UID16=n
++CONFIG_HDMI=n
++CONFIG_HIBERNATE_CALLBACKS=n
++CONFIG_HIBERNATION=n
++CONFIG_HIBERNATION_SNAPSHOT_DEV=n
++CONFIG_HID=n
++CONFIG_HID_A4TECH=n
++CONFIG_HID_APPLE=n
++CONFIG_HID_BELKIN=n
++CONFIG_HID_CHERRY=n
++CONFIG_HID_CHICONY=n
++CONFIG_HID_CYPRESS=n
++CONFIG_HID_EZKEY=n
++CONFIG_HID_GENERIC=n
++CONFIG_HID_ITE=n
++CONFIG_HID_KENSINGTON=n
++CONFIG_HID_LOGITECH=n
++CONFIG_HID_MICROSOFT=n
++CONFIG_HID_MONTEREY=n
++CONFIG_HID_REDRAGON=n
++CONFIG_HIGH_RES_TIMERS=n
++CONFIG_HOTPLUG_CPU=n
++CONFIG_HOTPLUG_PCI=n
++CONFIG_HOTPLUG_PCI_PCIE=n
++CONFIG_HVC_DRIVER=n
++CONFIG_HVC_IRQ=n
++CONFIG_HVC_XEN=n
++CONFIG_HVC_XEN_FRONTEND=n
++CONFIG_HWSPINLOCK=n
++CONFIG_HW_PERF_EVENTS=n
++CONFIG_I2C=n
++CONFIG_I2C_ALGOBIT=n
++CONFIG_I2C_BOARDINFO=n
++CONFIG_I2C_CHARDEV=n
++CONFIG_I2C_COMPAT=n
++CONFIG_I2C_HELPER_AUTO=n
++CONFIG_I2C_MUX=n
++CONFIG_I2C_MUX_PCA954x=n
++CONFIG_I2C_SMBUS=n
++CONFIG_IIO=n
++CONFIG_IKCONFIG_PROC=n
++CONFIG_INET_DIAG=n
++CONFIG_INET_TCP_DIAG=n
++CONFIG_INPUT_LEDS=n
++CONFIG_INPUT_MISC=n
++CONFIG_INPUT_MOUSEDEV=n
++CONFIG_INPUT_TOUCHSCREEN=n
++CONFIG_INPUT_UINPUT=n
++CONFIG_INPUT_XEN_KBDDEV_FRONTEND=n
++CONFIG_INTERVAL_TREE=n
++CONFIG_IOMMU_API=n
++CONFIG_IOMMU_IOVA=n
++CONFIG_IOMMU_IO_PGTABLE=n
++CONFIG_IOMMU_IO_PGTABLE_LPAE=n
++CONFIG_IOMMU_SUPPORT=n
++CONFIG_IPC_NS=n
++CONFIG_IPMMU_VMSA_CTX_NUM=8
++CONFIG_IP_MULTICAST=n
++CONFIG_IP_PNP=n
++CONFIG_IP_PNP_BOOTP=n
++CONFIG_IP_PNP_DHCP=n
++CONFIG_IRQ_BYPASS_MANAGER=n
++CONFIG_IRQ_MSI_IOMMU=n
++CONFIG_IRQ_TIME_ACCOUNTING=n
++CONFIG_JFFS2_FS=n
++CONFIG_JFFS2_FS_DEBUG=0
++CONFIG_JFFS2_FS_WRITEBUFFER=n
++CONFIG_JFFS2_RTIME=n
++CONFIG_JFFS2_ZLIB=n
++CONFIG_JUMP_LABEL=n
++CONFIG_KCMP=n
++CONFIG_KEXEC=n
++CONFIG_KEXEC_CORE=n
++CONFIG_KEYS=n
++CONFIG_KSM=n
++CONFIG_KUSER_HELPERS=n
++CONFIG_KVM=n
++CONFIG_KVM_ARM_PMU=n
++CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=n
++CONFIG_KVM_MMIO=n
++CONFIG_KVM_VFIO=n
++CONFIG_LDISC_AUTOLOAD=n
++CONFIG_LEDS_CLASS=n
++CONFIG_LEDS_GPIO=n
++CONFIG_LEDS_PWM=n
++CONFIG_LEDS_TRIGGERS=n
++CONFIG_LEDS_TRIGGER_CPU=n
++CONFIG_LEDS_TRIGGER_DEFAULT_ON=n
++CONFIG_LEDS_TRIGGER_HEARTBEAT=n
++CONFIG_LEGACY_PTYS=n
++CONFIG_LOCALVERSION_AUTO=n
++CONFIG_LOCKD=n
++CONFIG_LOCKD_V4=n
++CONFIG_LOGO=n
++CONFIG_LOGO_LINUX_CLUT224=n
++CONFIG_LZ4_DECOMPRESS=n
++CONFIG_LZO_COMPRESS=n
++CONFIG_LZO_DECOMPRESS=n
++CONFIG_MAGIC_SYSRQ=n
++CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
++CONFIG_MAGIC_SYSRQ_SERIAL=n
++CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE=""
++CONFIG_MAILBOX=n
++CONFIG_MANDATORY_FILE_LOCKING=n
++CONFIG_MAX9611=n
++CONFIG_MDIO_BITBANG=n
++CONFIG_MDIO_BUS=n
++CONFIG_MDIO_DEVICE=n
++CONFIG_MDIO_DEVRES=n
++CONFIG_MEDIA_CONTROLLER=n
++CONFIG_MEDIA_PLATFORM_SUPPORT=n
++CONFIG_MEDIA_SDR_SUPPORT=n
++CONFIG_MEDIA_SUPPORT_FILTER=n
++CONFIG_MEDIA_TUNER=n
++CONFIG_MEDIA_USB_SUPPORT=n
++CONFIG_MEMCG_KMEM=n
++CONFIG_MEMCG_SWAP=n
++CONFIG_MEMORY=n
++CONFIG_MEMORY_BALLOON=n
++CONFIG_MEMORY_ISOLATION=n
++CONFIG_MFD_BD9571MWV=n
++CONFIG_MFD_CORE=n
++CONFIG_MICREL_PHY=n
++CONFIG_MIGRATION=n
++CONFIG_MII=n
++CONFIG_MISC_FILESYSTEMS=n
++CONFIG_MMU_NOTIFIER=n
++CONFIG_MQ_IOSCHED_DEADLINE=n
++CONFIG_MQ_IOSCHED_KYBER=n
++CONFIG_MTD_OF_PARTS=n
++CONFIG_MTD_SPI_NOR=n
++CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=n
++CONFIG_NETDEVICES=n
++CONFIG_NETFILTER=n
++CONFIG_NETFILTER_ADVANCED=n
++CONFIG_NETFILTER_INGRESS=n
++CONFIG_NETWORK_FILESYSTEMS=n
++CONFIG_NET_CORE=n
++CONFIG_NET_FAILOVER=n
++CONFIG_NET_INGRESS=n
++CONFIG_NET_NS=n
++CONFIG_NET_VENDOR_3COM=n
++CONFIG_NET_VENDOR_8390=n
++CONFIG_NET_VENDOR_ADAPTEC=n
++CONFIG_NET_VENDOR_AGERE=n
++CONFIG_NET_VENDOR_ALACRITECH=n
++CONFIG_NET_VENDOR_ALTEON=n
++CONFIG_NET_VENDOR_AMAZON=n
++CONFIG_NET_VENDOR_AMD=n
++CONFIG_NET_VENDOR_AQUANTIA=n
++CONFIG_NET_VENDOR_ARC=n
++CONFIG_NET_VENDOR_ATHEROS=n
++CONFIG_NET_VENDOR_AURORA=n
++CONFIG_NET_VENDOR_BROADCOM=n
++CONFIG_NET_VENDOR_BROCADE=n
++CONFIG_NET_VENDOR_CADENCE=n
++CONFIG_NET_VENDOR_CAVIUM=n
++CONFIG_NET_VENDOR_CHELSIO=n
++CONFIG_NET_VENDOR_CISCO=n
++CONFIG_NET_VENDOR_CORTINA=n
++CONFIG_NET_VENDOR_DEC=n
++CONFIG_NET_VENDOR_DLINK=n
++CONFIG_NET_VENDOR_EMULEX=n
++CONFIG_NET_VENDOR_EZCHIP=n
++CONFIG_NET_VENDOR_GOOGLE=n
++CONFIG_NET_VENDOR_HISILICON=n
++CONFIG_NET_VENDOR_HUAWEI=n
++CONFIG_NET_VENDOR_I825XX=n
++CONFIG_NET_VENDOR_INTEL=n
++CONFIG_NET_VENDOR_MARVELL=n
++CONFIG_NET_VENDOR_MELLANOX=n
++CONFIG_NET_VENDOR_MICREL=n
++CONFIG_NET_VENDOR_MICROCHIP=n
++CONFIG_NET_VENDOR_MICROSEMI=n
++CONFIG_NET_VENDOR_MYRI=n
++CONFIG_NET_VENDOR_NATSEMI=n
++CONFIG_NET_VENDOR_NETERION=n
++CONFIG_NET_VENDOR_NETRONOME=n
++CONFIG_NET_VENDOR_NI=n
++CONFIG_NET_VENDOR_NVIDIA=n
++CONFIG_NET_VENDOR_OKI=n
++CONFIG_NET_VENDOR_PACKET_ENGINES=n
++CONFIG_NET_VENDOR_PENSANDO=n
++CONFIG_NET_VENDOR_QLOGIC=n
++CONFIG_NET_VENDOR_QUALCOMM=n
++CONFIG_NET_VENDOR_RDC=n
++CONFIG_NET_VENDOR_REALTEK=n
++CONFIG_NET_VENDOR_RENESAS=n
++CONFIG_NET_VENDOR_ROCKER=n
++CONFIG_NET_VENDOR_SAMSUNG=n
++CONFIG_NET_VENDOR_SEEQ=n
++CONFIG_NET_VENDOR_SILAN=n
++CONFIG_NET_VENDOR_SIS=n
++CONFIG_NET_VENDOR_SMSC=n
++CONFIG_NET_VENDOR_SOCIONEXT=n
++CONFIG_NET_VENDOR_SOLARFLARE=n
++CONFIG_NET_VENDOR_STMICRO=n
++CONFIG_NET_VENDOR_SUN=n
++CONFIG_NET_VENDOR_SYNOPSYS=n
++CONFIG_NET_VENDOR_TEHUTI=n
++CONFIG_NET_VENDOR_TI=n
++CONFIG_NET_VENDOR_VIA=n
++CONFIG_NET_VENDOR_WIZNET=n
++CONFIG_NET_VENDOR_XILINX=n
++CONFIG_NEW_LEDS=n
++CONFIG_NFS_COMMON=n
++CONFIG_NFS_DISABLE_UDP_SUPPORT=n
++CONFIG_NFS_FS=n
++CONFIG_NFS_USE_KERNEL_DNS=n
++CONFIG_NFS_V2=n
++CONFIG_NFS_V3=n
++CONFIG_NFS_V4=n
++CONFIG_NFS_V4_1=n
++CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
++CONFIG_NFS_V4_2=n
++CONFIG_NOP_USB_XCEIV=n
++CONFIG_NO_HZ_COMMON=n
++CONFIG_NO_HZ_IDLE=n
++CONFIG_NVMEM=n
++CONFIG_NVMEM_SYSFS=n
++CONFIG_OF_DYNAMIC=n
++CONFIG_OF_MDIO=n
++CONFIG_OF_NET=n
++CONFIG_OF_OVERLAY=n
++CONFIG_OF_RESOLVE=n
++CONFIG_OID_REGISTRY=n
++CONFIG_OLD_SIGSUSPEND3=n
++CONFIG_OPTEE=n
++CONFIG_OPTEE_SHM_NUM_PRIV_PAGES=1
++CONFIG_PAGE_COUNTER=n
++CONFIG_PAGE_POOL=n
++CONFIG_PAGE_REPORTING=n
++CONFIG_PARAVIRT=n
++CONFIG_PCI=n
++CONFIG_PCIEASPM=n
++CONFIG_PCIEASPM_DEFAULT=n
++CONFIG_PCIEPORTBUS=n
++CONFIG_PCIE_PME=n
++CONFIG_PCIE_RCAR=n
++CONFIG_PCIE_RCAR_EP=n
++CONFIG_PCIE_RCAR_HOST=n
++CONFIG_PCI_ATS=n
++CONFIG_PCI_DOMAINS=n
++CONFIG_PCI_DOMAINS_GENERIC=n
++CONFIG_PCI_ECAM=n
++CONFIG_PCI_ENDPOINT=n
++CONFIG_PCI_ENDPOINT_CONFIGFS=n
++CONFIG_PCI_EPF_TEST=n
++CONFIG_PCI_HOST_COMMON=n
++CONFIG_PCI_HOST_GENERIC=n
++CONFIG_PCI_IOV=n
++CONFIG_PCI_LABEL=n
++CONFIG_PCI_MSI=n
++CONFIG_PCI_MSI_ARCH_FALLBACKS=n
++CONFIG_PCI_MSI_IRQ_DOMAIN=n
++CONFIG_PCI_QUIRKS=n
++CONFIG_PCI_SYSCALL=n
++CONFIG_PERF_EVENTS=n
++CONFIG_PHYLIB=n
++CONFIG_PHY_RCAR_GEN3_USB2=n
++CONFIG_PHY_RCAR_GEN3_USB3=n
++CONFIG_PID_NS=n
++CONFIG_PM_GENERIC_DOMAINS_SLEEP=n
++CONFIG_PM_SLEEP=n
++CONFIG_PM_SLEEP_SMP=n
++CONFIG_PM_STD_PARTITION=""
++CONFIG_PNFS_FILE_LAYOUT=n
++CONFIG_PNFS_FLEXFILE_LAYOUT=n
++CONFIG_POEG_RZG2L=n
++CONFIG_POSIX_MQUEUE=n
++CONFIG_POSIX_MQUEUE_SYSCTL=n
++CONFIG_POWER_SUPPLY_HWMON=n
++CONFIG_PREEMPT_NOTIFIERS=n
++CONFIG_PREEMPT_RCU=n
++CONFIG_PREVENT_FIRMWARE_BUILD=n
++CONFIG_PRINT_QUOTA_WARNING=n
++CONFIG_PROC_PID_CPUSET=n
++CONFIG_PROC_VMCORE=n
++CONFIG_PROFILING=n
++CONFIG_PWM=n
++CONFIG_PWM_RCAR=n
++CONFIG_PWM_RENESAS_TPU=n
++CONFIG_PWM_SYSFS=n
++CONFIG_PWRSEQ_EMMC=n
++CONFIG_PWRSEQ_SIMPLE=n
++CONFIG_QCOM_FALKOR_ERRATUM_E1041=n
++CONFIG_QUOTA=n
++CONFIG_QUOTACTL=n
++CONFIG_RAVB=n
++CONFIG_RCAR_CPU_TOPOLOGY=n
++CONFIG_RCAR_DMAC=n
++CONFIG_RCAR_GEN3_THERMAL=n
++CONFIG_RCAR_THERMAL=n
++CONFIG_RCAR_THERMAL_EMS=n
++CONFIG_RCU_TRACE=n
++CONFIG_RD_BZIP2=n
++CONFIG_RD_GZIP=n
++CONFIG_RD_LZ4=n
++CONFIG_RD_LZMA=n
++CONFIG_RD_LZO=n
++CONFIG_RD_XZ=n
++CONFIG_RD_ZSTD=n
++CONFIG_REALTEK_PHY=n
++CONFIG_REGMAP=n
++CONFIG_REGMAP_I2C=n
++CONFIG_REGMAP_IRQ=n
++CONFIG_REGMAP_MMIO=n
++CONFIG_REGMAP_SPI=n
++CONFIG_REGULATOR_BD9571MWV=n
++CONFIG_REGULATOR_PWM=n
++CONFIG_RENESAS_MFIS_ECC=n
++CONFIG_RENESAS_OSTM=n
++CONFIG_RENESAS_POE3=n
++CONFIG_RENESAS_RPCIF=n
++CONFIG_RENESAS_RZG2LWDT=n
++CONFIG_RENESAS_TIMER_MTU3=n
++CONFIG_RENESAS_USB_DMAC=n
++CONFIG_RENESAS_WDT=n
++CONFIG_RESET_RZG2L_USBPHY_CTRL=n
++CONFIG_RODATA_FULL_DEFAULT_ENABLED=n
++CONFIG_ROOT_NFS=n
++CONFIG_RTC_CLASS=n
++CONFIG_RTC_DRV_RX8581=n
++CONFIG_RTC_HCTOSYS=n
++CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
++CONFIG_RTC_I2C_AND_SPI=n
++CONFIG_RTC_INTF_DEV=n
++CONFIG_RTC_INTF_PROC=n
++CONFIG_RTC_INTF_SYSFS=n
++CONFIG_RTC_LIB=n
++CONFIG_RTC_NVMEM=n
++CONFIG_RTC_SYSTOHC=n
++CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
++CONFIG_RUNTIME_TESTING_MENU=n
++CONFIG_RZG2L_ADC=n
++CONFIG_RZG2L_THERMAL=n
++CONFIG_SATA_HOST=n
++CONFIG_SATA_RCAR=n
++CONFIG_SCHED_AUTOGROUP=n
++CONFIG_SCHED_HRTICK=n
++CONFIG_SCHED_INFO=n
++CONFIG_SCHED_MC=n
++CONFIG_SCHED_THERMAL_PRESSURE=n
++CONFIG_SCSI_LOWLEVEL=n
++CONFIG_SCSI_SAS_ATA=n
++CONFIG_SCSI_SAS_HOST_SMP=n
++CONFIG_SDR_PLATFORM_DRIVERS=n
++CONFIG_SECCOMP=n
++CONFIG_SECCOMP_FILTER=n
++CONFIG_SECTION_MISMATCH_WARN_ONLY=n
++CONFIG_SET_FS=n
++CONFIG_SGL_ALLOC=n
++CONFIG_SLAB_MERGE_DEFAULT=n
++CONFIG_SLUB_CPU_PARTIAL=n
++CONFIG_SND=n
++CONFIG_SND_AUDIO_GRAPH_CARD=n
++CONFIG_SND_DRIVERS=n
++CONFIG_SND_HDA_PREALLOC_SIZE=64
++CONFIG_SND_JACK=n
++CONFIG_SND_JACK_INPUT_DEV=n
++CONFIG_SND_PCI=n
++CONFIG_SND_PCM=n
++CONFIG_SND_PCM_ELD=n
++CONFIG_SND_PCM_IEC958=n
++CONFIG_SND_PCM_TIMER=n
++CONFIG_SND_PROC_FS=n
++CONFIG_SND_SIMPLE_CARD=n
++CONFIG_SND_SIMPLE_CARD_UTILS=n
++CONFIG_SND_SOC=n
++CONFIG_SND_SOC_HDMI_CODEC=n
++CONFIG_SND_SOC_I2C_AND_SPI=n
++CONFIG_SND_SOC_PCM5102A=n
++CONFIG_SND_SOC_RCAR=n
++CONFIG_SND_SOC_RZ=n
++CONFIG_SND_SOC_WM8978=n
++CONFIG_SND_SUPPORT_OLD_API=n
++CONFIG_SND_TIMER=n
++CONFIG_SND_VERBOSE_PROCFS=n
++CONFIG_SOUND=n
++CONFIG_SPARSEMEM_VMEMMAP=n
++CONFIG_SPI=n
++CONFIG_SPI_DYNAMIC=n
++CONFIG_SPI_MASTER=n
++CONFIG_SPI_MEM=n
++CONFIG_SPI_RPCIF=n
++CONFIG_SPI_RSPI=n
++CONFIG_SPI_SH_MSIOF=n
++CONFIG_SPI_SLAVE=n
++CONFIG_SPI_SPIDEV=n
++CONFIG_SQUASHFS=n
++CONFIG_SQUASHFS_DECOMP_SINGLE=n
++CONFIG_SQUASHFS_FILE_CACHE=n
++CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
++CONFIG_SQUASHFS_ZLIB=n
++CONFIG_STACKPROTECTOR=n
++CONFIG_STACKPROTECTOR_PER_TASK=n
++CONFIG_STACKPROTECTOR_STRONG=n
++CONFIG_STANDALONE=n
++CONFIG_STRICT_DEVMEM=n
++CONFIG_STRICT_MODULE_RWX=n
++CONFIG_SUNRPC=n
++CONFIG_SUNRPC_BACKCHANNEL=n
++CONFIG_SUNRPC_GSS=n
++CONFIG_SUSPEND=n
++CONFIG_SUSPEND_FREEZER=n
++CONFIG_SWAP=n
++CONFIG_SWIOTLB_XEN=n
++CONFIG_SWPHY=n
++CONFIG_SYMBOLIC_ERRNAME=n
++CONFIG_SYNC_FILE=n
++CONFIG_SYSVIPC=n
++CONFIG_SYSVIPC_COMPAT=n
++CONFIG_SYSVIPC_SYSCTL=n
++CONFIG_SYS_HYPERVISOR=n
++CONFIG_TASKSTATS=n
++CONFIG_TASKS_RCU=n
++CONFIG_TASKS_RCU_GENERIC=n
++CONFIG_TASK_DELAY_ACCT=n
++CONFIG_TASK_IO_ACCOUNTING=n
++CONFIG_TASK_XACCT=n
++CONFIG_TEE=n
++CONFIG_THERMAL=n
++CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=n
++CONFIG_THERMAL_EMULATION=n
++CONFIG_THERMAL_GOV_STEP_WISE=n
++CONFIG_THERMAL_HWMON=n
++CONFIG_THERMAL_OF=n
++CONFIG_TICK_ONESHOT=n
++CONFIG_TIME_NS=n
++CONFIG_TOUCHSCREEN_PROPERTIES=n
++CONFIG_TOUCHSCREEN_USB_3M=n
++CONFIG_TOUCHSCREEN_USB_COMPOSITE=n
++CONFIG_TOUCHSCREEN_USB_DMC_TSC10=n
++CONFIG_TOUCHSCREEN_USB_E2I=n
++CONFIG_TOUCHSCREEN_USB_EASYTOUCH=n
++CONFIG_TOUCHSCREEN_USB_EGALAX=n
++CONFIG_TOUCHSCREEN_USB_ELO=n
++CONFIG_TOUCHSCREEN_USB_ETT_TC45USB=n
++CONFIG_TOUCHSCREEN_USB_ETURBO=n
++CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=n
++CONFIG_TOUCHSCREEN_USB_GOTOP=n
++CONFIG_TOUCHSCREEN_USB_GUNZE=n
++CONFIG_TOUCHSCREEN_USB_IDEALTEK=n
++CONFIG_TOUCHSCREEN_USB_IRTOUCH=n
++CONFIG_TOUCHSCREEN_USB_ITM=n
++CONFIG_TOUCHSCREEN_USB_JASTEC=n
++CONFIG_TOUCHSCREEN_USB_NEXIO=n
++CONFIG_TOUCHSCREEN_USB_PANJIT=n
++CONFIG_TOUCHSCREEN_USB_ZYTRONIC=n
++CONFIG_TRACE_CLOCK=n
++CONFIG_TRANSPARENT_HUGEPAGE=n
++CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=n
++CONFIG_TUN=n
++CONFIG_TYPEC=n
++CONFIG_TYPEC_HD3SS3220=n
++CONFIG_UCS2_STRING=n
++CONFIG_UID16=n
++CONFIG_UNINLINE_SPIN_UNLOCK=n
++CONFIG_USB=n
++CONFIG_USB_ARCH_HAS_HCD=n
++CONFIG_USB_AUTOSUSPEND_DELAY=2
++CONFIG_USB_BDC_UDC=n
++CONFIG_USB_COMMON=n
++CONFIG_USB_DEFAULT_PERSIST=n
++CONFIG_USB_EHCI_HCD=n
++CONFIG_USB_EHCI_HCD_PLATFORM=n
++CONFIG_USB_EHCI_PCI=n
++CONFIG_USB_EHCI_ROOT_HUB_TT=n
++CONFIG_USB_EHCI_TT_NEWSCHED=n
++CONFIG_USB_ETH=n
++CONFIG_USB_ETH_RNDIS=n
++CONFIG_USB_F_ACM=n
++CONFIG_USB_F_ECM=n
++CONFIG_USB_F_MASS_STORAGE=n
++CONFIG_USB_F_OBEX=n
++CONFIG_USB_F_RNDIS=n
++CONFIG_USB_F_SERIAL=n
++CONFIG_USB_F_SUBSET=n
++CONFIG_USB_GADGET=n
++CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
++CONFIG_USB_GADGET_VBUS_DRAW=2
++CONFIG_USB_GSPCA=n
++CONFIG_USB_G_SERIAL=n
++CONFIG_USB_HID=n
++CONFIG_USB_HSIC_USB3503=n
++CONFIG_USB_LIBCOMPOSITE=n
++CONFIG_USB_MASS_STORAGE=n
++CONFIG_USB_NET_DRIVERS=n
++CONFIG_USB_OHCI_HCD=n
++CONFIG_USB_OHCI_HCD_PCI=n
++CONFIG_USB_OHCI_HCD_PLATFORM=n
++CONFIG_USB_OTG=n
++CONFIG_USB_PCI=n
++CONFIG_USB_PHY=n
++CONFIG_USB_RENESAS_USB3=n
++CONFIG_USB_RENESAS_USBHS=n
++CONFIG_USB_RENESAS_USBHS_HCD=n
++CONFIG_USB_RENESAS_USBHS_UDC=n
++CONFIG_USB_ROLE_SWITCH=n
++CONFIG_USB_SNP_CORE=n
++CONFIG_USB_SNP_UDC_PLAT=n
++CONFIG_USB_STORAGE=n
++CONFIG_USB_SUPPORT=n
++CONFIG_USB_ULPI=n
++CONFIG_USB_ULPI_VIEWPORT=n
++CONFIG_USB_U_ETHER=n
++CONFIG_USB_U_SERIAL=n
++CONFIG_USB_VIDEO_CLASS=n
++CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=n
++CONFIG_USB_XHCI_HCD=n
++CONFIG_USB_XHCI_PCI=n
++CONFIG_USB_XHCI_PLATFORM=n
++CONFIG_USB_XHCI_RCAR=n
++CONFIG_USER_NS=n
++CONFIG_UTS_NS=n
++CONFIG_VFIO=n
++CONFIG_VFIO_IOMMU_TYPE1=n
++CONFIG_VFIO_PCI=n
++CONFIG_VFIO_PCI_INTX=n
++CONFIG_VFIO_PCI_MMAP=n
++CONFIG_VFIO_VIRQFD=n
++CONFIG_VGA_ARB=n
++CONFIG_VGA_ARB_MAX_GPUS=16
++CONFIG_VHOST_MENU=n
++CONFIG_VIDEOBUF2_CORE=n
++CONFIG_VIDEOBUF2_DMA_CONTIG=n
++CONFIG_VIDEOBUF2_MEMOPS=n
++CONFIG_VIDEOBUF2_V4L2=n
++CONFIG_VIDEOBUF2_VMALLOC=n
++CONFIG_VIDEO_RCAR_CSI2=n
++CONFIG_VIDEO_RCAR_DRIF=n
++CONFIG_VIDEO_RCAR_VIN=n
++CONFIG_VIDEO_RENESAS_FCP=n
++CONFIG_VIDEO_RENESAS_FDP1=n
++CONFIG_VIDEO_RENESAS_VSP1=n
++CONFIG_VIDEO_RENESAS_VSP_ALPHA_BIT_ARGB1555=0
++CONFIG_VIDEO_V4L2=n
++CONFIG_VIDEO_V4L2_I2C=n
++CONFIG_VIDEO_V4L2_SUBDEV_API=n
++CONFIG_VIRTIO=n
++CONFIG_VIRTIO_BALLOON=n
++CONFIG_VIRTIO_BLK=n
++CONFIG_VIRTIO_CONSOLE=n
++CONFIG_VIRTIO_MENU=n
++CONFIG_VIRTIO_MMIO=n
++CONFIG_VIRTIO_NET=n
++CONFIG_VIRTIO_PCI=n
++CONFIG_VIRTIO_PCI_LEGACY=n
++CONFIG_VIRTUALIZATION=n
++CONFIG_VMAP_STACK=n
++CONFIG_VT_CONSOLE_SLEEP=n
++CONFIG_VT_HW_CONSOLE_BINDING=n
++CONFIG_WATCHDOG=n
++CONFIG_WATCHDOG_CORE=n
++CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=n
++CONFIG_WIRELESS=n
++CONFIG_WQ_POWER_EFFICIENT_DEFAULT=n
++CONFIG_XARRAY_MULTI=n
++CONFIG_XEN=n
++CONFIG_XENFS=n
++CONFIG_XEN_AUTO_XLATE=n
++CONFIG_XEN_BACKEND=n
++CONFIG_XEN_BALLOON=n
++CONFIG_XEN_BLKDEV_FRONTEND=n
++CONFIG_XEN_COMPAT_XENFS=n
++CONFIG_XEN_DEV_EVTCHN=n
++CONFIG_XEN_DOM0=n
++CONFIG_XEN_EFI=n
++CONFIG_XEN_FBDEV_FRONTEND=n
++CONFIG_XEN_GNTDEV=n
++CONFIG_XEN_GRANT_DEV_ALLOC=n
++CONFIG_XEN_NETDEV_FRONTEND=n
++CONFIG_XEN_PRIVCMD=n
++CONFIG_XEN_SCRUB_PAGES_DEFAULT=n
++CONFIG_XEN_SYS_HYPERVISOR=n
++CONFIG_XEN_XENBUS_FRONTEND=n
++CONFIG_XXHASH=n
++CONFIG_XZ_DEC=n
++CONFIG_XZ_DEC_ARM=n
++CONFIG_XZ_DEC_ARMTHUMB=n
++CONFIG_XZ_DEC_BCJ=n
++CONFIG_XZ_DEC_IA64=n
++CONFIG_XZ_DEC_POWERPC=n
++CONFIG_XZ_DEC_SPARC=n
++CONFIG_XZ_DEC_X86=n
++CONFIG_ZLIB_DEFLATE=n
++CONFIG_ZLIB_INFLATE=n
++CONFIG_ZSTD_DECOMPRESS=n
++#==================================
++CONFIG_CMA=y
++CONFIG_COMPAT=y
++CONFIG_COMPAT_32BIT_TIME=y
++CONFIG_COMPAT_BINFMT_ELF=y
++CONFIG_COMPAT_OLD_SIGACTION=y
++CONFIG_DEVFREQ_GOV_PASSIVE=y
++CONFIG_DEVFREQ_GOV_PERFORMANCE=y
++CONFIG_DEVFREQ_GOV_POWERSAVE=y
++CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
++CONFIG_DEVFREQ_GOV_USERSPACE=y
++CONFIG_DEVMEM=y
++CONFIG_DMADEVICES=y
++CONFIG_DMA_CMA=y
++CONFIG_DMA_ENGINE=y
++CONFIG_DMA_OF=y
++CONFIG_DMA_SHARED_BUFFER=y
++CONFIG_DMA_VIRTUAL_CHANNELS=y
++CONFIG_DRM=y
++CONFIG_DRM_BRIDGE=y
++CONFIG_DRM_DW_HDMI=y
++CONFIG_DRM_I2C_ADV7511=y
++CONFIG_DRM_I2C_ADV7511_CEC=y
++CONFIG_DRM_RCAR_CMM=y
++CONFIG_DRM_RCAR_DU=y
++CONFIG_DRM_RCAR_DW_HDMI=y
++CONFIG_DRM_RCAR_LVDS=y
++CONFIG_DRM_RCAR_VSP=y
++CONFIG_DRM_RCAR_WRITEBACK=y
++CONFIG_DRM_RZG2L_MIPI_DSI=y
++CONFIG_FB_CMDLINE=y
++CONFIG_FRAME_VECTOR=y
++CONFIG_HDMI=y
++CONFIG_HWMON=y
++CONFIG_I2C=y
++CONFIG_I2C_ALGOBIT=y
++CONFIG_I2C_BOARDINFO=y
++CONFIG_I2C_RIIC=y
++CONFIG_INPUT_HISI_POWERKEY=y
++CONFIG_INPUT_PM8941_PWRKEY=y
++CONFIG_IOMMU_DMA=y
++CONFIG_IPMMU_VMSA=y
++CONFIG_KCMP=y
++CONFIG_MEDIA_ATTACH=y
++CONFIG_MEDIA_CONTROLLER=y
++CONFIG_MEDIA_TUNER=y
++CONFIG_MEMCG=y
++CONFIG_MODULES=y
++CONFIG_MODULES_TREE_LOOKUP=y
++CONFIG_MODULE_UNLOAD=y
++CONFIG_OF_IOMMU=y
++CONFIG_RENESAS_DMA=y
++CONFIG_RZ_DMAC=y
++CONFIG_V4L2_FWNODE=y
++CONFIG_V4L2_MEM2MEM_DEV=y
++CONFIG_V4L_MEM2MEM_DRIVERS=y
++CONFIG_V4L_PLATFORM_DRIVERS=y
++CONFIG_VIDEOBUF2_CORE=y
++CONFIG_VIDEOBUF2_DMA_CONTIG=y
++CONFIG_VIDEOBUF2_MEMOPS=y
++CONFIG_VIDEOBUF2_V4L2=y
++CONFIG_VIDEOBUF2_VMALLOC=y
++CONFIG_VIDEOMODE_HELPERS=y
++CONFIG_VIDEO_ADV748X=y
++CONFIG_VIDEO_DEV=y
++CONFIG_VIDEO_IMX219=y
++CONFIG_VIDEO_OV5645=y
++CONFIG_VIDEO_RENESAS_FCP=y
++CONFIG_VIDEO_RENESAS_FDP1=y
++CONFIG_VIDEO_RENESAS_VSP1=y
++CONFIG_VIDEO_RZG2L_CRU=y
++CONFIG_VIDEO_RZG2L_CSI2=y
++CONFIG_VIDEO_V4L2=y
++CONFIG_VIDEO_V4L2_I2C=y
++CONFIG_VIDEO_V4L2_SUBDEV_API=y
+-- 
+2.17.1
+
diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0002-arm64-dts-renesas-disable-OSTM2-I2C0-and-CRU.patch b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0002-arm64-dts-renesas-disable-OSTM2-I2C0-and-CRU.patch
new file mode 100644
index 0000000..08bc373
--- /dev/null
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0002-arm64-dts-renesas-disable-OSTM2-I2C0-and-CRU.patch
@@ -0,0 +1,51 @@
+From 185a5dd587a23cf25a53a4516ac5af356d7fbeaf Mon Sep 17 00:00:00 2001
+From: vudang <vu.dang.te@renasas.com>
+Date: Thu, 27 Oct 2022 10:54:21 +0700
+Subject: [PATCH 2/6] arm64: dts: renesas: disable OSTM2, I2C0 and CRU
+
+Disable OSTM2, I2C0 and CRU in Linux which are used in RTOS.
+
+Signed-off-by: vudang <vu.dang.te@renasas.com>
+---
+ arch/arm64/boot/dts/renesas/rz-smarc-common.dtsi | 4 ++--
+ arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi | 2 +-
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/arch/arm64/boot/dts/renesas/rz-smarc-common.dtsi b/arch/arm64/boot/dts/renesas/rz-smarc-common.dtsi
+index 0fdb4820f3f0..1ba30dcc6e39 100644
+--- a/arch/arm64/boot/dts/renesas/rz-smarc-common.dtsi
++++ b/arch/arm64/boot/dts/renesas/rz-smarc-common.dtsi
+@@ -164,7 +164,7 @@
+ 	pinctrl-0 = <&i2c0_pins>;
+ 	pinctrl-names = "default";
+ 
+-	status = "okay";
++	status = "disabled";
+ 
+ 	ov5645: camera@3c {
+ 		compatible = "ovti,ov5645";
+@@ -331,7 +331,7 @@
+ };
+ 
+ &cru {
+-	status = "okay";
++	status = "disabled";
+ };
+ 
+ &csi2 {
+diff --git a/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi b/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi
+index c5973d8b1057..68a783f395ae 100644
+--- a/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi
++++ b/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi
+@@ -189,7 +189,7 @@
+ };
+ 
+ &ostm2 {
+-	status = "okay";
++	status = "disabled";
+ };
+ 
+ &pinctrl {
+-- 
+2.17.1
+
diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0003-arm64-dts-renesas-change-default-bootargs.patch b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0003-arm64-dts-renesas-change-default-bootargs.patch
new file mode 100644
index 0000000..884f6a7
--- /dev/null
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0003-arm64-dts-renesas-change-default-bootargs.patch
@@ -0,0 +1,27 @@
+From fdb26935eefd55ec11de0f550fd34cec7c9ad9d4 Mon Sep 17 00:00:00 2001
+From: vudang <vu.dang.te@renasas.com>
+Date: Mon, 26 Sep 2022 09:54:19 +0700
+Subject: [PATCH 3/6] arm64: dts: renesas: change default bootargs
+
+Signed-off-by: vudang <vu.dang.te@renasas.com>
+---
+ arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi b/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi
+index 68a783f395ae..6eaab20d1cb1 100644
+--- a/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi
++++ b/arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi
+@@ -29,7 +29,8 @@
+ 	};
+ 
+ 	chosen {
+-		bootargs = "ignore_loglevel rw root=/dev/nfs ip=on";
++		/* bootargs = "ignore_loglevel rw root=/dev/nfs ip=on"; */
++                bootargs = "quiet loglevel=3 root=/dev/mmcblk0p1 rootwait";
+ 	};
+ 
+ 	memory@48000000 {
+-- 
+2.17.1
+
diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0004-clk-renesas-r9a07g044-Set-SCIF2-OSTM2-CRU-I2C0-as-cr.patch b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0004-clk-renesas-r9a07g044-Set-SCIF2-OSTM2-CRU-I2C0-as-cr.patch
new file mode 100644
index 0000000..c86d7f4
--- /dev/null
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0004-clk-renesas-r9a07g044-Set-SCIF2-OSTM2-CRU-I2C0-as-cr.patch
@@ -0,0 +1,32 @@
+From b4d8d98130977078f7337a8947029e01709c5bd3 Mon Sep 17 00:00:00 2001
+From: vudang <vu.dang.te@renasas.com>
+Date: Thu, 27 Oct 2022 10:41:53 +0700
+Subject: [PATCH 4/6] clk: renesas: r9a07g044: Set SCIF2, OSTM2, CRU, I2C0 as
+ critical
+
+Signed-off-by: vudang <vu.dang.te@renasas.com>
+---
+ drivers/clk/renesas/r9a07g044-cpg.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/clk/renesas/r9a07g044-cpg.c b/drivers/clk/renesas/r9a07g044-cpg.c
+index 523ebc365bbe..a5c98c891f99 100644
+--- a/drivers/clk/renesas/r9a07g044-cpg.c
++++ b/drivers/clk/renesas/r9a07g044-cpg.c
+@@ -472,6 +472,13 @@ static const unsigned int r9a07g044_crit_mod_clks[] __initconst = {
+ 	MOD_CLK_BASE + R9A07G044_IA55_PCLK,
+ 	MOD_CLK_BASE + R9A07G044_IA55_CLK,
+ 	MOD_CLK_BASE + R9A07G044_DMAC_ACLK,
++        MOD_CLK_BASE + R9A07G044_SCIF2_CLK_PCK,
++        MOD_CLK_BASE + R9A07G044_OSTM2_PCLK,
++        MOD_CLK_BASE + R9A07G044_CRU_SYSCLK,
++        MOD_CLK_BASE + R9A07G044_CRU_VCLK,
++        MOD_CLK_BASE + R9A07G044_CRU_PCLK,
++        MOD_CLK_BASE + R9A07G044_CRU_ACLK,
++        MOD_CLK_BASE + R9A07G044_I2C0_PCLK,
+ };
+ 
+ const struct rzg2l_cpg_info r9a07g044_cpg_info = {
+-- 
+2.17.1
+
diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0005-driver-DRP-AI-add-DPR-AI-support-for-RZ-V2L-board.patch b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0005-driver-DRP-AI-add-DPR-AI-support-for-RZ-V2L-board.patch
new file mode 100644
index 0000000..a69644e
--- /dev/null
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0005-driver-DRP-AI-add-DPR-AI-support-for-RZ-V2L-board.patch
@@ -0,0 +1,5142 @@
+From f10c51fb610a2ac799d35d616db07a9db90e4f8d Mon Sep 17 00:00:00 2001
+From: Vu Dang <vu.dang.te@renesas.com>
+Date: Mon, 31 Oct 2022 13:22:07 +0700
+Subject: [PATCH 5/6] driver: DRP-AI: add DPR-AI support for RZ/V2L board
+
+Apply these patches:
+(from meta-rz-features/recipes-drpai/recipes-kernel/linux/linux-renesas)
+	0001-ov5645-Add-VGA-720x480-and-720p-resloutions.patch
+	0002-ov5645-Add-pixel-rate-support-for-each-mode.patch
+	0003-rzg2l-csi-Add-BGR24-and-YUYV-support.patch
+	0004-rzg2l-dma-Add-BGR24-and-YUYV-support.patch
+	0005-update-ov5645-VGA-setting.patch
+	0006-update-cpg-function-for-drp.patch
+	0007-enable-u-dma-buf-function.patch
+	0008-enable-drpai-drv.patch
+
+Signed-off-by: Vu Dang <vu.dang.te@renasas.com>
+---
+ arch/arm64/boot/dts/renesas/r9a07g054.dtsi    |   19 +
+ .../boot/dts/renesas/r9a07g054l2-dev.dts      |   14 +
+ .../boot/dts/renesas/r9a07g054l2-smarc.dts    |   15 +
+ drivers/Kconfig                               |    3 +
+ drivers/Makefile                              |    1 +
+ drivers/clk/renesas/r9a07g044-cpg.c           |   17 +-
+ drivers/drpai/Kconfig                         |   14 +
+ drivers/drpai/Makefile                        |    7 +
+ drivers/drpai/drpai-core.c                    | 1189 ++++++++
+ drivers/drpai/drpai-core.h                    |   97 +
+ drivers/drpai/drpai-if.c                      | 2603 +++++++++++++++++
+ drivers/drpai/drpai-reg.h                     |  275 ++
+ drivers/media/i2c/ov5645.c                    |  408 ++-
+ drivers/media/platform/rzg2l-cru/rzg2l-csi2.c |    2 +
+ drivers/media/platform/rzg2l-cru/rzg2l-dma.c  |    8 +-
+ include/linux/drpai.h                         |   22 +
+ include/uapi/linux/drpai.h                    |   99 +
+ 17 files changed, 4787 insertions(+), 6 deletions(-)
+ create mode 100644 drivers/drpai/Kconfig
+ create mode 100644 drivers/drpai/Makefile
+ create mode 100644 drivers/drpai/drpai-core.c
+ create mode 100644 drivers/drpai/drpai-core.h
+ create mode 100644 drivers/drpai/drpai-if.c
+ create mode 100644 drivers/drpai/drpai-reg.h
+ create mode 100644 include/linux/drpai.h
+ create mode 100644 include/uapi/linux/drpai.h
+
+diff --git a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
+index 3f7556dd4e7d..632757c4eba5 100644
+--- a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
++++ b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
+@@ -1541,6 +1541,25 @@
+ 				};
+ 			};
+ 		};
++		
++		drpai0: drpai@12C00000 {
++			compatible = "renesas,rzv2l-drpai";
++			reg = <0 0x13000000 0 0x1000000>,
++				  <0 0x12C00000 0 0x400000>;
++			clocks = <&cpg CPG_MOD R9A07G054_STPAI_INITCLK>,
++					 <&cpg CPG_MOD R9A07G054_STPAI_ACLK>,
++					 <&cpg CPG_MOD R9A07G054_STPAI_MCLK>,
++					 <&cpg CPG_MOD R9A07G054_STPAI_DCLKIN>,
++					 <&cpg CPG_MOD R9A07G054_STPAI_ACLK_DRP>;
++			resets = <&cpg R9A07G054_STPAI_ARESETN>;
++			power-domains = <&cpg>;
++			clock-names = "intclk","aclk_drp","mclk","dclkin","aclk";
++			interrupts = <GIC_SPI 440 IRQ_TYPE_LEVEL_HIGH>,
++						 <GIC_SPI 441 IRQ_TYPE_LEVEL_HIGH>,
++						 <GIC_SPI 442 IRQ_TYPE_LEVEL_HIGH>,
++						 <GIC_SPI 443 IRQ_TYPE_LEVEL_HIGH>;
++            status = "okay";
++		};
+ 	};
+ 
+ 	thermal-zones {
+diff --git a/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts b/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts
+index f9a7b730ec9e..b836dc8b4262 100755
+--- a/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts
++++ b/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts
+@@ -67,6 +67,14 @@
+ 	vspm_if {
+ 		compatible = "renesas,vspm_if";
+ 	};
++	udmabuf@0 {
++		compatible = "ikwzm,u-dma-buf";
++		device-name = "udmabuf0";
++		minor-number = <0>;
++		size = <0x4000000>; // 64MiB
++		dma-coherent;
++		memory-region = <&image_buf0>;
++	};
+ };
+ 
+ &ehci0 {
+@@ -84,3 +92,9 @@
+ &ohci1 {
+ 	memory-region = <&global_cma>;
+ };
++
++&drpai0 {
++    memory-region = <&drp_reserved>;
++    linux-memory-region = < &{/memory@48000000} >; 
++    status = "okay";
++};
+diff --git a/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts b/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts
+index 651aa6b8297b..55cb9b65aabf 100644
+--- a/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts
++++ b/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts
+@@ -39,6 +39,15 @@
+ 			reg = <0x0 0xB4000000 0x0 0x03000000>;
+ 		};
+ 	};
++
++	udmabuf@0 {
++		compatible = "ikwzm,u-dma-buf";
++		device-name = "udmabuf0";
++		minor-number = <0>;
++		size = <0x4000000>; // 64MiB
++		dma-coherent;
++		memory-region = <&image_buf0>;
++	};
+ };
+ 
+ &pinctrl {
+@@ -46,3 +55,9 @@
+ 	/delete-node/ sd0-dev-sel-hog;
+ 	/delete-node/ sd1-pwr-en-hog;
+ };
++
++&drpai0 {
++    memory-region = <&drp_reserved>;
++    linux-memory-region = < &{/memory@48000000} >; 
++    status = "okay";
++};
+diff --git a/drivers/Kconfig b/drivers/Kconfig
+index dcecc9f6e33f..63f231eb5708 100644
+--- a/drivers/Kconfig
++++ b/drivers/Kconfig
+@@ -235,4 +235,7 @@ source "drivers/interconnect/Kconfig"
+ source "drivers/counter/Kconfig"
+ 
+ source "drivers/most/Kconfig"
++
++source "drivers/drpai/Kconfig"
++
+ endmenu
+diff --git a/drivers/Makefile b/drivers/Makefile
+index 576228037718..354b8fd483bc 100644
+--- a/drivers/Makefile
++++ b/drivers/Makefile
+@@ -189,3 +189,4 @@ obj-$(CONFIG_GNSS)		+= gnss/
+ obj-$(CONFIG_INTERCONNECT)	+= interconnect/
+ obj-$(CONFIG_COUNTER)		+= counter/
+ obj-$(CONFIG_MOST)		+= most/
++obj-$(CONFIG_DRPAI)		+= drpai/
+diff --git a/drivers/clk/renesas/r9a07g044-cpg.c b/drivers/clk/renesas/r9a07g044-cpg.c
+index a5c98c891f99..57e56b89ab47 100644
+--- a/drivers/clk/renesas/r9a07g044-cpg.c
++++ b/drivers/clk/renesas/r9a07g044-cpg.c
+@@ -118,7 +118,7 @@ static const char * const sel_gpu2[] = { ".pll6", ".pll3_div2_2" };
+ static const struct {
+ 	struct cpg_core_clk common[53];
+ #ifdef CONFIG_CLK_R9A07G054
+-	struct cpg_core_clk drp[0];
++	struct cpg_core_clk drp[1];
+ #endif
+ } core_clks __initconst = {
+ 	.common = {
+@@ -201,9 +201,11 @@ static const struct {
+ 		DEF_FIXED("SD1_DIV4", CLK_SD1_DIV4, R9A07G044_CLK_SD1, 1, 4),
+ 		DEF_DIV("G", R9A07G044_CLK_G, CLK_SEL_GPU2, DIVGPU, dtable_1_8,
+ 			CLK_DIVIDER_HIWORD_MASK),
++		
+ 	},
+ #ifdef CONFIG_CLK_R9A07G054
+ 	.drp = {
++		DEF_FIXED("DRP", R9A07G054_CLK_DRP_M, CLK_PLL3, 1, 5),
+ 	},
+ #endif
+ };
+@@ -211,7 +213,7 @@ static const struct {
+ static const struct {
+ 	struct rzg2l_mod_clk common[101];
+ #ifdef CONFIG_CLK_R9A07G054
+-	struct rzg2l_mod_clk drp[0];
++	struct rzg2l_mod_clk drp[5];
+ #endif
+ } mod_clks = {
+ 	.common = {
+@@ -392,6 +394,16 @@ static const struct {
+ 	},
+ #ifdef CONFIG_CLK_R9A07G054
+ 	.drp = {
++		DEF_MOD("drp_inclk",	R9A07G054_STPAI_INITCLK, CLK_EXTAL,
++					0x5E8, 0),
++		DEF_MOD("drp_aclk_drp",	R9A07G054_STPAI_ACLK, R9A07G054_CLK_DRP_M,
++					0x5E8, 1),
++		DEF_MOD("drp_mclk",	R9A07G054_STPAI_MCLK, R9A07G054_CLK_DRP_M,
++					0x5E8, 2),
++		DEF_MOD("drp_dclkin",	R9A07G054_STPAI_DCLKIN, CLK_PLL3_DIV2,
++					0x5E8, 3),
++		DEF_MOD("drp_aclk",	R9A07G054_STPAI_ACLK_DRP, CLK_PLL3_DIV2_4,
++					0x5E8, 4),
+ 	},
+ #endif
+ };
+@@ -465,6 +477,7 @@ static struct rzg2l_reset r9a07g044_resets[] = {
+ 	DEF_RST(R9A07G044_MIPI_DSI_PRESET_N, 0x868, 2),
+ 	DEF_RST(R9A07G044_LCDC_RESET_N, 0x86c, 0),
+ 	DEF_RST(R9A07G044_MTU_X_PRESET_MTU3, 0x838, 0),
++	DEF_RST(R9A07G054_STPAI_ARESETN, 0x8E8, 0),
+ };
+ 
+ static const unsigned int r9a07g044_crit_mod_clks[] __initconst = {
+diff --git a/drivers/drpai/Kconfig b/drivers/drpai/Kconfig
+new file mode 100644
+index 000000000000..e626673edf4a
+--- /dev/null
++++ b/drivers/drpai/Kconfig
+@@ -0,0 +1,14 @@
++#
++# DRP-AI subsystem configuration
++#
++
++menu "DRP-AI support"
++
++config DRPAI
++	tristate "DRP-AI support"
++	default y
++	help
++	  DRP-AI is a peripheral hardware that accelerates AI.
++	  If you want DRP-AI support, you should say Y here.
++
++endmenu
+diff --git a/drivers/drpai/Makefile b/drivers/drpai/Makefile
+new file mode 100644
+index 000000000000..86915ad9f1b2
+--- /dev/null
++++ b/drivers/drpai/Makefile
+@@ -0,0 +1,7 @@
++# SPDX-License-Identifier: GPL-2.0
++#
++# Makefile for DRP-AI.
++#
++
++obj-$(CONFIG_DRPAI)	+= drpai-core.o drpai-if.o
++
+diff --git a/drivers/drpai/drpai-core.c b/drivers/drpai/drpai-core.c
+new file mode 100644
+index 000000000000..346078789ba8
+--- /dev/null
++++ b/drivers/drpai/drpai-core.c
+@@ -0,0 +1,1189 @@
++/*
++ * Driver for the Renesas RZ/V2L DRP-AI unit
++ *
++ * Copyright (C) 2021 Renesas Electronics Corporation
++ *
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifdef __KERNEL__
++#include <linux/types.h>
++#include <linux/module.h>
++#include <asm/io.h>
++#include <linux/delay.h>
++#else
++#include "r_typedefs.h"
++#endif
++#include <linux/drpai.h>
++#include "drpai-core.h"
++#include "drpai-reg.h"
++#include <linux/reset.h>
++
++#define DRP_ERRINT_MSK_REG_NUM              (6)
++#define DRP_ERRINT_STATUS_REG_NUM           (6)
++#define AIMAC_ERRINT_MSK_REG_NUM            (34)
++#define AIMAC_ERRINT_STATUS_REG_NUM         (35)
++#define SET_STPC_CLKGEN_CTRL                (0x00000001)
++#define SET_STPC_CLKGEN_RST                 (0x00000000)
++#define SET_STPC_CLKGEN_STBYWAIT_EN         (0x00000001)
++#define SET_STPC_CLKGEN_STBYWAIT_DI         (0x00000000)
++#define SET_STPC_CLKGEN_DIV                 (0x00020001)
++#define SET_STPC_CLKE_EN                    (0x100F030F)
++#define SET_STPC_CLKE_DI                    (0x00000000)
++#define SET_STPC_SFTRST_EN                  (0xFFFFFFFF)
++#define SET_STPC_SFTRST_DI                  (0x21F000F0)
++#define SET_DSCC_DCTL_CR                    (0x00000000)
++#define SET_DSCC_DCTL                       (0x00310001)
++#define SET_EXD0_STPC_CLKGEN_CTRL           (0x00000001)
++#define SET_EXD0_STPC_CLKGEN_RST            (0x00000000)
++#define SET_EXD0_STPC_CLKGEN_STBYWAI_EN     (0x00000001)
++#define SET_EXD0_STPC_CLKGEN_STBYWAI_DI     (0x00000000)
++#define SET_EXD0_STPC_CLKGEN_DIV            (0x00010000)
++#define SET_EXDX_STPC_CLKE_EN               (0x100F000F)
++#define SET_EXDX_STPC_CLKE_DI               (0x00000000)
++#define SET_CLKRSTCON_CLKE_EN               (0x00000001)
++#define SET_CLKRSTCON_CLKE_DI               (0x00000000)
++#define SET_EXDX_STPC_SFTRST_EN             (0xB1FF03FF)
++#define SET_EXDX_STPC_SFTRST_DI             (0xA1F003F0)
++#define SET_CLKRSTCON_SFTRST_EN             (0x0000001F)
++#define SET_CLKRSTCON_SFTRST_DI             (0x00000000)
++#define SET_EXD1_ODIF_INTMSK                (0x0300FFF7)
++#define SET_AID_DSCC_DCTL_CR                (0x00000000)
++#define SET_AID_DSCC_DCTL                   (0x00000001)
++#define SET_SYNCTBL_TBLX                    (0x0000FFFF)
++#define SET_IDMACIF_DSC_EN                  (0x00040001)
++#define SET_IDMACIF_MEMR_EN                 (0x00040101)
++#define SET_DSCC_DMA_EN                     (0x00000001)
++#define SET_DSCC_DMA_DI                     (0x00000000)
++#define DRPAI_RESERVED_DSCC_PAMON           (0)
++#define DRPAI_RESERVED_AID_DSCC_PAMON       (1)
++#define DRPAI_RESERVED_STPC_ERRINT_STS      (2)
++#define DRPAI_RESERVED_INTMON_ERRINT        (3)
++#define DRPAI_RESERVED_EXD1_ODIF_INT_IRQ    (4)
++#define DRPAI_RESERVED_EXD1_ODIF_INT_NOW    (5)
++#define DRPAI_RESERVED_SYNCTBL_TBL12        (6)
++#define DRPAI_RESERVED_SYNCTBL_TBL13        (7)
++#define DRPAI_RESERVED_SYNCTBL_TBL14        (8)
++#define DRPAI_RESERVED_SYNCTBL_TBL15        (9)
++
++/* Base address */
++extern void __iomem *g_drp_base_addr[DRP_CH_NUM];
++extern void __iomem *g_aimac_base_address[AIMAC_CH_NUM];
++extern struct drpai_priv *drpai_priv;
++
++static int32_t drp_init(int32_t ch);
++static int32_t drp_start(int32_t ch, uint32_t desc);
++static int32_t aimac_init(int32_t ch);
++static int32_t aimac_start(int32_t ch, uint32_t desc);
++static void reg_bit_clear(volatile void __iomem *reg_address, uint32_t bit);
++static void aimac_clear_synctbl_tbl(int32_t ch);
++static int8_t check_dma_reg_stop(void __iomem *base, uint32_t offset);
++static int8_t check_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset);
++static int8_t wait_for_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset);
++static int8_t wait_for_desc_prefetch_stop(void __iomem *base, uint32_t offset);
++
++static uint32_t exd0_odif_int_val;
++static uint32_t stpc_errint_sts_val;
++static uint32_t intmon_errint_val;
++
++/* DRP ERRINT */
++const static uint32_t drp_errint_msk_reg_tbl[DRP_ERRINT_MSK_REG_NUM][2] =
++{
++    {IDIF_EINTMSK       ,0x00F0F0F0}, {IDIF_EINTMSK_DSC ,0x00000000},
++    {ODIF_EINTMSK       ,0x07F0F0F0}, {IDMAC_INTME      ,0x55550000},
++    {ODMAC_INTME        ,0x5555FF80}, {RAC_EINTM        ,0x00000000},
++};
++const static uint32_t drp_errint_status_reg_tbl[DRP_ERRINT_STATUS_REG_NUM] =
++{
++    IDIF_EINT, IDIF_EINT_DSC, ODIF_EINT, IDMAC_INTSE,
++    ODMAC_INTSE, RAC_EINTS
++};
++const static char* drp_errint_status_reg_name_tbl[DRP_ERRINT_STATUS_REG_NUM] =
++{
++    "IDIF_EINT","IDIF_EINT_DSC","ODIF_EINT","IDMAC_INTSE",
++    "ODMAC_INTSE","RAC_EINTS"
++};
++/* AI-MAC ERRINT */
++const static uint32_t aimac_errint_msk_reg_tbl[AIMAC_ERRINT_MSK_REG_NUM][2] =
++{
++    {AID_IDIF_EINTMSK   ,0x07FEFEFE}, {AID_IDMAC_INTME      ,0x55550000},
++    {AIMRAC_EINTM       ,0x00000000}, {CMDSEL_ERRMSK        ,0x00000000},
++    {PRAM_INTMASK       ,0x00000000}, {OSEL_DO_MSK0         ,0x00000000},
++    {OSEL_DO_MSK1       ,0x00000000}, {OSEL_DO_MSK2         ,0x00000000},
++    {OSEL_DO_MSK3       ,0x00000000}, {OSEL_DO_MSK4         ,0x00000000},
++    {OSEL_DO_MSK5       ,0x00000000}, {OSEL_DO_MSK6         ,0x00000000},
++    {OSEL_DO_MSK7       ,0x00000000}, {OSEL_DO_MSK8         ,0x00000000},
++    {OSEL_DO_EN0        ,0x00000001}, {OSEL_DO_EN1          ,0x00000001},
++    {OSEL_DO_EN2        ,0x00000001}, {OSEL_DO_EN3          ,0x00000001},
++    {OSEL_DO_EN4        ,0x00000001}, {OSEL_DO_EN5          ,0x00000001},
++    {OSEL_DO_EN6        ,0x00000001}, {OSEL_DO_EN7          ,0x00000001},
++    {OSEL_DO_EN8        ,0x00000001}, {MACTOP_ERR_MSK       ,0x00000000},
++    {EXD0_IDIF_EINTMSK  ,0x07F0F0F0}, {EXD1_IDIF_EINTMSK    ,0x07F0F0F0},
++    {EXD0_ODIF_EINTMSK  ,0x07F0F0F0}, {EXD1_ODIF_EINTMSK    ,0x07F0F0F0},
++    {EXD0_IDMAC_INTME   ,0x55550000}, {EXD1_IDMAC_INTME     ,0x55550000},
++    {EXD0_ODMAC_INTME   ,0x55550000}, {EXD1_ODMAC_INTME     ,0x55550000},
++    {EXD0_RAC_EINTM     ,0x00000000}, {EXD1_RAC_EINTM       ,0x00000000},
++};
++const static uint32_t aimac_errint_status_reg_tbl[AIMAC_ERRINT_STATUS_REG_NUM] =
++{
++    AID_IDIF_EINT,AID_IDMAC_INTSE,AIMRAC_EINTS,CMDSEL_ERRSTS,PRAM_INT,
++    OSEL_DO_ESTS0,OSEL_DO_ESTS1,OSEL_DO_ESTS2,OSEL_DO_ESTS3,OSEL_DO_ESTS4,
++    OSEL_DO_ESTS5,OSEL_DO_ESTS6,OSEL_DO_ESTS7,OSEL_DO_ESTS8,OSEL_DO_FESTS0,
++    OSEL_DO_FESTS1,OSEL_DO_FESTS2,OSEL_DO_FESTS3,OSEL_DO_FESTS4,OSEL_DO_FESTS5,
++    OSEL_DO_FESTS6,OSEL_DO_FESTS7,OSEL_DO_FESTS8,MACTOP_ERR_STS,MACCTL_FERR_STS,
++    EXD0_IDIF_EINT,EXD1_IDIF_EINT,EXD0_ODIF_EINT,EXD1_ODIF_EINT,EXD0_IDMAC_INTSE,
++    EXD1_IDMAC_INTSE,EXD0_ODMAC_INTSE,EXD1_ODMAC_INTSE,EXD0_RAC_EINTS,EXD1_RAC_EINTS
++};
++const static char* aimac_errint_status_reg_name_tbl[AIMAC_ERRINT_STATUS_REG_NUM] =
++{
++    "AID_IDIF_EINT","AID_IDMAC_INTSE","AIMRAC_EINTS","CMDSEL_ERRSTS","PRAM_INT",
++    "OSEL_DO_ESTS0","OSEL_DO_ESTS1","OSEL_DO_ESTS2","OSEL_DO_ESTS3","OSEL_DO_ESTS4",
++    "OSEL_DO_ESTS5","OSEL_DO_ESTS6","OSEL_DO_ESTS7","OSEL_DO_ESTS8","OSEL_DO_FESTS0",
++    "OSEL_DO_FESTS1","OSEL_DO_FESTS2","OSEL_DO_FESTS3","OSEL_DO_FESTS4","OSEL_DO_FESTS5",
++    "OSEL_DO_FESTS6","OSEL_DO_FESTS7","OSEL_DO_FESTS8","MACTOP_ERR_STS","MACCTL_FERR_STS",
++    "EXD0_IDIF_EINT","EXD1_IDIF_EINT","EXD0_ODIF_EINT","EXD1_ODIF_EINT","EXD0_IDMAC_INTSE",
++    "EXD1_IDMAC_INTSE","EXD0_ODMAC_INTSE","EXD1_ODMAC_INTSE","EXD0_RAC_EINTS","EXD1_RAC_EINTS"
++};
++
++static int32_t drp_init(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    int32_t ret;
++    uint32_t loop;
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++
++    if (DRP_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    /* Enable DRP clock */
++    iowrite32(SET_STPC_CLKGEN_CTRL, g_drp_base_addr[ch] + STPC_CLKGEN_CTRL);
++
++    /* Unreset the DRPCLKGEN module */
++    iowrite32(SET_STPC_CLKGEN_RST, g_drp_base_addr[ch] + STPC_CLKGEN_RST);
++
++    /* Shift to standby mode */
++    iowrite32(SET_STPC_CLKGEN_STBYWAIT_EN, g_drp_base_addr[ch] + STPC_CLKGEN_STBYWAIT);
++
++    /* DRP clock operating frequency setting */
++    /* Div divided by 4 (DCLK=315MHz), set to dynamic frequency mode */
++    /* Div divided by 4 (DCLK=315MHz) -> When Config is loaded       */
++    /* Dynamic frequency mode -> When DRP application is running     */
++    iowrite32(SET_STPC_CLKGEN_DIV, g_drp_base_addr[ch] + STPC_CLKGEN_DIV);
++    iowrite32(SET_STPC_CLKGEN_STBYWAIT_DI, g_drp_base_addr[ch] + STPC_CLKGEN_STBYWAIT);
++
++    /* Enable DMA channel clock */
++    iowrite32(SET_STPC_CLKE_EN, g_drp_base_addr[ch] + STPC_CLKE);
++
++    /* Release Soft reset */
++    spin_lock_irqsave(&priv->lock, flags);
++    iowrite32(SET_STPC_SFTRST_DI, g_drp_base_addr[ch] + STPC_SFTRST);
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    /* Data input channel settings */
++    iowrite32(SET_IDMACIF_DSC_EN, g_drp_base_addr[ch] + IDIF_DMACTLI0);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + IDIF_DMACTLI1);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + IDIF_DMACTLI2);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + IDIF_DMACTLI3);
++
++    /* Data output channel settings */
++    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO0);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO1);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO2);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO3);
++
++    /* Configuration light */
++    iowrite32(SET_IDMACIF_DSC_EN, g_drp_base_addr[ch] + IDIF_DMACTLCW);
++
++/* ISP */
++    /* Unmasks ODMAC interrupts */
++    iowrite32(0xFFFFFFF0, g_drp_base_addr[ch] + ODIF_INTMSK);
++/* ISP */
++
++    /* DRP error interrupt mask release */
++    for (loop = 0; loop < DRP_ERRINT_MSK_REG_NUM; loop++)
++    {
++        iowrite32(drp_errint_msk_reg_tbl[loop][1],
++               g_drp_base_addr[ch] + drp_errint_msk_reg_tbl[loop][0]);
++    }
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++static int32_t drp_start(int32_t ch, uint32_t desc)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++
++    if (DRP_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++/* ISP */
++    uint32_t reg_val;
++
++    /* Clear interrupt factor */
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);
++    writel(reg_val, g_drp_base_addr[ch] + ODIF_INT);            /* Clear */
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);            /* Dummy read */
++
++    /* Reading the number of interrupts */
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO0);
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO1);
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO2);
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO3);
++
++    /* Unmasks ODMAC interrupts */
++    iowrite32(0xFFFFFFF0, g_drp_base_addr[ch] + ODIF_INTMSK);
++/* ISP */
++
++    /* Set descriptor start address */
++    iowrite32(desc, g_drp_base_addr[ch] + DSCC_DPA);
++
++    /* Clear prefetch of input descriptor */
++    iowrite32(SET_DSCC_DCTL_CR, g_drp_base_addr[ch] + DSCC_DCTL);
++
++    /* Start prefetch of input descriptor */
++    iowrite32(SET_DSCC_DCTL, g_drp_base_addr[ch] + DSCC_DCTL);
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++static int32_t aimac_init(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++    uint32_t loop;
++
++    if (AIMAC_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    /* Unreset MCLKGEN module */
++    iowrite32(SET_EXD0_STPC_CLKGEN_RST, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_RST);
++
++    /* Shift to standby mode */
++    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_EN, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_STBYWAIT);
++
++    /* AIMAC clock operating frequency setting */
++    /* Div divided by 2 (MCLK=630MHz), set to fixed frequency mode */
++    iowrite32(SET_EXD0_STPC_CLKGEN_DIV, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_DIV);
++
++    /* Clock activation */
++    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_DI, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_STBYWAIT);
++
++    /* Enable Clock */
++    iowrite32(SET_EXDX_STPC_CLKE_EN, g_aimac_base_address[ch] + EXD0_STPC_CLKE);
++    iowrite32(SET_EXDX_STPC_CLKE_EN, g_aimac_base_address[ch] + EXD1_STPC_CLKE);
++    iowrite32(SET_CLKRSTCON_CLKE_EN, g_aimac_base_address[ch] + CLKRSTCON_CLKE);
++
++    /* Release soft reset */
++    iowrite32(SET_EXDX_STPC_SFTRST_DI, g_aimac_base_address[ch] + EXD0_STPC_SFTRST);
++    iowrite32(SET_EXDX_STPC_SFTRST_DI, g_aimac_base_address[ch] + EXD1_STPC_SFTRST);
++    iowrite32(SET_CLKRSTCON_SFTRST_DI, g_aimac_base_address[ch] + CLKRSTCON_SFTRST);
++
++    /* DMA channel settings */
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI0);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI1);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI2);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI3);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO0);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO1);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO2);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO3);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI0);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI1);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI2);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI3);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO0);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO1);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO2);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO3);
++    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + AID_IDIF_DMACTLI0);
++
++    /* DRP-AI processing completion interrupt mask release */
++    iowrite32(SET_EXD1_ODIF_INTMSK, g_aimac_base_address[ch] + EXD1_ODIF_INTMSK);
++
++    /* AI-MAC error interrupt mask release */
++    for (loop = 0; loop < AIMAC_ERRINT_MSK_REG_NUM; loop++)
++    {
++        iowrite32(aimac_errint_msk_reg_tbl[loop][1],
++               g_aimac_base_address[ch] + aimac_errint_msk_reg_tbl[loop][0]);
++    }
++
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++static int32_t aimac_start(int32_t ch, uint32_t desc)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++
++    if (AIMAC_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    /* Initialization of register value storage variable */
++    spin_lock_irqsave(&priv->lock, flags);
++    exd0_odif_int_val = 0;
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    /* Set the start address of AIMAC descriptor */
++    iowrite32(desc, g_aimac_base_address[ch] + AID_DSCC_DPA);
++
++    /* Start descriptor read */
++    iowrite32(SET_AID_DSCC_DCTL_CR, g_aimac_base_address[ch] + AID_DSCC_DCTL);
++    iowrite32(SET_AID_DSCC_DCTL, g_aimac_base_address[ch] + AID_DSCC_DCTL);
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++int32_t R_DRPAI_DRP_Open(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++
++    if (DRP_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    ret = drp_init(ch);
++    if (R_DRPAI_SUCCESS != ret)
++    {
++        return ret;
++    }
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++int32_t R_DRPAI_DRP_Start(int32_t ch, uint32_t desc)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++
++    if (DRP_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    ret = drp_start(ch, desc);
++    if (R_DRPAI_SUCCESS != ret)
++    {
++        return ret;
++    }
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++/* ISP */
++int32_t R_DRPAI_DRP_Nmlint(int32_t ch, drpai_odif_intcnto_t *odif_intcnto)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    uint32_t reg_val;
++
++    /* Clear interrupt factor */
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);
++    writel(reg_val, g_drp_base_addr[ch] + ODIF_INT);            /* Clear */
++    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);            /* Dummy read */
++
++    /* Reading the number of interrupts */
++    odif_intcnto->ch0 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO0);
++    odif_intcnto->ch1 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO1);
++    odif_intcnto->ch2 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO2);
++    odif_intcnto->ch3 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO3);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return 0;
++}
++/* ISP */
++
++int32_t R_DRPAI_DRP_Errint(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    uint32_t reg_val;
++    uint32_t loop;
++
++    printk(KERN_ERR "DRP-AI DRP ERROR\n");
++
++    /* Show descriptor pointer */
++    reg_val = ioread32(g_drp_base_addr[ch] + DSCC_PAMON);
++    printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
++    reg_val = ioread32(g_aimac_base_address[ch] + AID_DSCC_PAMON);
++    printk(KERN_ERR "AID_DSCC_PAMON  : 0x%08X\n", reg_val);
++
++    /* Error interrupt cause register */
++    stpc_errint_sts_val = ioread32(g_drp_base_addr[ch] + STPC_ERRINT_STS);
++    printk(KERN_ERR "STPC_ERRINT_STS : 0x%08X\n", stpc_errint_sts_val);
++
++    /* Error display of each module */
++    reg_val = ioread32(g_drp_base_addr[ch] + DRP_ERRINTSTATUS);
++    printk(KERN_ERR "DRP_ERRINTSTATUS : 0x%08X\n", reg_val);
++    if (0 != reg_val)
++    {
++        reg_val = ioread32(g_drp_base_addr[ch] + STPC_SFTRST);
++        reg_val |= DRPAI_BIT31;
++        iowrite32(reg_val, g_drp_base_addr[ch] + STPC_SFTRST);
++    }
++    for (loop = 0; loop < DRP_ERRINT_STATUS_REG_NUM; loop++)
++    {
++        reg_val = ioread32(g_drp_base_addr[ch] + drp_errint_status_reg_tbl[loop]);
++        iowrite32(reg_val, g_drp_base_addr[ch] + drp_errint_status_reg_tbl[loop]);
++        printk(KERN_ERR "%s : 0x%08X\n", drp_errint_status_reg_name_tbl[loop], reg_val);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return 0;
++}
++
++int32_t R_DRPAI_AIMAC_Open(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++
++    if (AIMAC_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    ret = aimac_init(ch);
++    if (R_DRPAI_SUCCESS != ret)
++    {
++        return ret;
++    }
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++int32_t R_DRPAI_AIMAC_Start(int32_t ch, uint32_t desc)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++
++    if (AIMAC_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    ret = aimac_start(ch, desc);
++    if (R_DRPAI_SUCCESS != ret)
++    {
++        return ret;
++    }
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++int32_t R_DRPAI_AIMAC_Nmlint(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    volatile uint32_t dummy;
++
++    /* Debug information */
++    exd0_odif_int_val = ioread32(g_aimac_base_address[ch] + EXD1_ODIF_INT);
++
++    /* Clear interrupt factor */
++    iowrite32(0x00000008, g_aimac_base_address[ch] + EXD1_ODIF_INT);   /* Clear */
++    dummy = ioread32(g_aimac_base_address[ch] + EXD1_ODIF_INT);        /* Dummy read */
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return 0;
++}
++
++int32_t R_DRPAI_AIMAC_Errint(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    uint32_t reg_val;
++    uint8_t i;
++
++    printk(KERN_ERR "DRP-AI AI-MAC ERROR\n");
++
++    /* Show descriptor pointer */
++    reg_val = ioread32(g_drp_base_addr[ch] + DSCC_PAMON);
++    printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
++    reg_val = ioread32(g_aimac_base_address[ch] + AID_DSCC_PAMON);
++    printk(KERN_ERR "AID_DSCC_PAMON  : 0x%08X\n", reg_val);
++
++    /* Error interrupt cause register */
++    intmon_errint_val = ioread32(g_aimac_base_address[ch] + INTMON_ERRINT);
++    printk(KERN_ERR "INTMON_ERRINT : 0x%08X\n", intmon_errint_val);
++
++    for (i = 0; i < AIMAC_ERRINT_STATUS_REG_NUM; i++)
++    {
++        reg_val = ioread32(g_aimac_base_address[ch] + aimac_errint_status_reg_tbl[i]);
++        iowrite32(reg_val, g_aimac_base_address[ch] + aimac_errint_status_reg_tbl[i]);
++        printk(KERN_ERR "%s : 0x%08X\n",aimac_errint_status_reg_name_tbl[i], reg_val);
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    return 0;
++}
++
++int32_t R_DRPAI_Status(int32_t ch, drpai_status_t *drpai_status)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++
++    if (DRP_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++    if (AIMAC_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    /* DRP Address of descriptor */
++    drpai_status->reserved[DRPAI_RESERVED_DSCC_PAMON] = ioread32(g_drp_base_addr[ch] + DSCC_PAMON);
++
++    /* AI-MAC Address of descriptor */
++    drpai_status->reserved[DRPAI_RESERVED_AID_DSCC_PAMON] = ioread32(g_aimac_base_address[ch] + AID_DSCC_PAMON);
++
++    /* DRP-AI processing complete interrupt status */
++    drpai_status->reserved[DRPAI_RESERVED_EXD1_ODIF_INT_IRQ] = exd0_odif_int_val;
++    drpai_status->reserved[DRPAI_RESERVED_EXD1_ODIF_INT_NOW] = ioread32(g_aimac_base_address[ch] + EXD1_ODIF_INT);
++
++    /* AI-MAC synchronization information */
++    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL12] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL12);
++    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL13] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL13);
++    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL14] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL14);
++    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL15] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL15);
++
++    /* DRP error information */
++    drpai_status->reserved[DRPAI_RESERVED_STPC_ERRINT_STS] = stpc_errint_sts_val;
++
++    /* AI-MAC error information */
++    drpai_status->reserved[DRPAI_RESERVED_INTMON_ERRINT] = intmon_errint_val;
++
++    ret = R_DRPAI_SUCCESS;
++    goto end;
++
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++static void reg_bit_clear(volatile void __iomem *reg_address, uint32_t bit)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    uint32_t tmp_reg;
++
++    /* Read register value */
++    tmp_reg = ioread32(reg_address);
++    /* Clear the target bit */
++    tmp_reg = tmp_reg & (~bit);
++
++    iowrite32(tmp_reg, reg_address);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++}
++
++static void aimac_clear_synctbl_tbl(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL0);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL1);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL2);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL3);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL4);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL5);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL6);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL7);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL8);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL9);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL10);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL11);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL12);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL13);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL14);
++    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL15);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++}
++
++static int8_t check_dma_reg_stop(void __iomem *base, uint32_t offset)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    uint32_t reg_val;
++    int8_t ret;
++
++    reg_val = ioread32(base + offset);
++    if(!((0 == (reg_val & DRPAI_BIT1)) || (DRPAI_BIT19 == (reg_val & DRPAI_BIT19))))
++    {
++        ret = -1;
++    }
++    else
++    {
++        ret = 0;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    return ret;
++}
++
++static int8_t check_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t i;
++    int32_t ret;
++
++    for(i = 0; i < num_offset; i++)
++    {
++        if(0 != check_dma_reg_stop(base, offset[i]))
++        {
++            goto not_stop;
++        }
++        else
++        {
++            ; // Do nothing
++        }
++    }
++
++    ret = 0;
++    goto end;
++not_stop:
++    ret = -1;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++static int8_t wait_for_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    bool is_stop = false;
++    int8_t ret;
++    int32_t i;
++
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        udelay(1);
++        i++;
++        if(0 != check_dma_stop(base, offset, num_offset))
++        {
++            ; // Do nothing
++        }
++        else
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        usleep_range(100, 200);
++        i++;
++        if(0 != check_dma_stop(base, offset, num_offset))
++        {
++            ; // Do nothing
++        }
++        else
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    if(true == is_stop)
++    {
++        ret = 0;
++    }
++    else
++    {
++        ret = -1;
++#ifdef  DRPAI_DRV_DEBUG
++        uint32_t reg_val;
++        for(i = 0; i < num_offset; i++) {
++            reg_val = ioread32(base + offset[i]);
++            DRPAI_DEBUG_PRINT(KERN_INFO "%s: offset: %08X = 0x%08X\n", __func__, offset[i], reg_val);
++        }
++#endif
++    }
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++static int8_t wait_for_desc_prefetch_stop(void __iomem *base, uint32_t offset)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    bool is_stop = false;
++    int8_t ret;
++    int32_t i;
++    uint32_t reg_val;
++
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        udelay(1);
++        i++;
++        reg_val = ioread32(base + offset);
++        if(0 != (reg_val & DRPAI_BIT1))
++        {
++            ; // Do nothing
++        }
++        else
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        usleep_range(100, 200);
++        i++;
++        reg_val = ioread32(base + offset);
++        if(0 != (reg_val & DRPAI_BIT1))
++        {
++            ; // Do nothing
++        }
++        else
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    if(true == is_stop)
++    {
++        ret = 0;
++    }
++    else
++    {
++        ret = -1;
++        DRPAI_DEBUG_PRINT(KERN_INFO "%s: offset: %08X = 0x%08X\n", __func__, offset, reg_val);
++    }
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++int32_t R_DRPAI_DRP_Reset(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++    uint32_t offset_buf[4];
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "%s: (pid %d)\n", __func__, current->pid);
++    
++    if (DRP_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    /* Descriptor prefetch stop */
++    reg_bit_clear(g_drp_base_addr[ch] + DSCC_DCTL, DRPAI_BIT0);
++    if(0 != wait_for_desc_prefetch_stop(g_drp_base_addr[ch], DSCC_DCTL))
++    {
++        goto err_reset;
++    }
++    
++    /* Forced stop of writing configuration data */
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLCW, DRPAI_BIT18);
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLCW, DRPAI_BIT0);
++    offset_buf[0] = IDIF_DMACTLCW;
++    if(0 != wait_for_dma_stop(g_drp_base_addr[ch], offset_buf, 1))
++    {
++        goto err_reset;
++    }
++
++    /* Forced stop of data input / output */
++    /* IDIF_DMACTLI0,I1,I2,I3 */
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI0, DRPAI_BIT18);
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI1, DRPAI_BIT18);
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI2, DRPAI_BIT18);
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI3, DRPAI_BIT18);
++
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI0, DRPAI_BIT0);
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI1, DRPAI_BIT0);
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI2, DRPAI_BIT0);
++    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI3, DRPAI_BIT0);
++
++    aimac_clear_synctbl_tbl(ch);
++
++    offset_buf[0] = IDIF_DMACTLI0;
++    offset_buf[1] = IDIF_DMACTLI1;
++    offset_buf[2] = IDIF_DMACTLI2;
++    offset_buf[3] = IDIF_DMACTLI3;
++    if(0 != wait_for_dma_stop(g_drp_base_addr[ch], offset_buf, 4)){
++        goto err_reset;
++    }
++
++    /* ODIF_DMACTLO0,O1,O2,O3 */
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO0, DRPAI_BIT18);
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO1, DRPAI_BIT18);
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO2, DRPAI_BIT18);
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO3, DRPAI_BIT18);
++
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO0, DRPAI_BIT0);
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO1, DRPAI_BIT0);
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO2, DRPAI_BIT0);
++    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO3, DRPAI_BIT0);
++
++    aimac_clear_synctbl_tbl(ch);
++
++    offset_buf[0] = ODIF_DMACTLO0;
++    offset_buf[1] = ODIF_DMACTLO1;
++    offset_buf[2] = ODIF_DMACTLO2;
++    offset_buf[3] = ODIF_DMACTLO3;
++    if(0 != wait_for_dma_stop(g_drp_base_addr[ch], offset_buf, 4))
++    {
++        goto err_reset;
++    }
++
++    /* Set DRP core as fixed frequency mode  */
++    iowrite32((SET_STPC_CLKGEN_DIV & 0xFFFFFFFE), g_drp_base_addr[ch] + STPC_CLKGEN_DIV);
++
++    /* Soft reset */
++    spin_lock_irqsave(&priv->lock, flags);
++    iowrite32(0xFFFFFFFF, g_drp_base_addr[ch] + STPC_SFTRST);
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++err_reset:
++    ret = R_DRPAI_ERR_RESET;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++int32_t R_DRPAI_AIMAC_Reset(int32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++    uint32_t offset_buf[4];
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "%s: (pid %d)\n", __func__, current->pid);
++
++    if (DRP_CH_NUM <= ch)
++    {
++        goto err_invalid_arg;
++    }
++
++    /* Descriptor prefetch stop */
++    reg_bit_clear(g_aimac_base_address[ch] + AID_DSCC_DCTL, DRPAI_BIT0);
++    if(0 != wait_for_desc_prefetch_stop(g_aimac_base_address[ch], AID_DSCC_DCTL))
++    {
++        goto err_reset;
++    }
++
++    /* Forced stop of inputting parameters (weights and bias values) */
++    reg_bit_clear(g_aimac_base_address[ch] + AID_IDIF_DMACTLI0, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + AID_IDIF_DMACTLI0, DRPAI_BIT0);
++
++    aimac_clear_synctbl_tbl(ch);
++
++    offset_buf[0] = AID_IDIF_DMACTLI0;
++    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 1))
++    {
++        goto err_reset;
++    }
++
++    /* Forced stop of data input / output */
++    /* EXD0_IDIF_DMACTLI0,I1,I2,I3 */
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI0, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI1, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI2, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI3, DRPAI_BIT18);
++
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI0, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI1, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI2, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI3, DRPAI_BIT0);
++
++    aimac_clear_synctbl_tbl(ch);
++
++    offset_buf[0] = EXD0_IDIF_DMACTLI0;
++    offset_buf[1] = EXD0_IDIF_DMACTLI1;
++    offset_buf[2] = EXD0_IDIF_DMACTLI2;
++    offset_buf[3] = EXD0_IDIF_DMACTLI3;
++    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
++    {
++        goto err_reset;
++    }
++
++    /* EXD1_IDIF_DMACTLI0,I1,I2,I3 */
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI0, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI1, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI2, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI3, DRPAI_BIT18);
++
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI0, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI1, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI2, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI3, DRPAI_BIT0);
++
++    aimac_clear_synctbl_tbl(ch);
++
++    offset_buf[0] = EXD1_IDIF_DMACTLI0;
++    offset_buf[1] = EXD1_IDIF_DMACTLI1;
++    offset_buf[2] = EXD1_IDIF_DMACTLI2;
++    offset_buf[3] = EXD1_IDIF_DMACTLI3;
++    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
++    {
++        goto err_reset;
++    }
++
++    /* EXD0_ODIF_DMACTLO0,O1,O2,O3 */
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO0, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO1, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO2, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO3, DRPAI_BIT18);
++
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO0, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO1, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO2, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO3, DRPAI_BIT0);
++
++    aimac_clear_synctbl_tbl(ch);
++
++    offset_buf[0] = EXD0_ODIF_DMACTLO0;
++    offset_buf[1] = EXD0_ODIF_DMACTLO1;
++    offset_buf[2] = EXD0_ODIF_DMACTLO2;
++    offset_buf[3] = EXD0_ODIF_DMACTLO3;
++    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
++    {
++        goto err_reset;
++    }
++
++    /* EXD1_ODIF_DMACTLO0,O1,O2,O3 */
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO0, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO1, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO2, DRPAI_BIT18);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO3, DRPAI_BIT18);
++
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO0, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO1, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO2, DRPAI_BIT0);
++    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO3, DRPAI_BIT0);
++
++    aimac_clear_synctbl_tbl(ch);
++
++    offset_buf[0] = EXD1_ODIF_DMACTLO0;
++    offset_buf[1] = EXD1_ODIF_DMACTLO1;
++    offset_buf[2] = EXD1_ODIF_DMACTLO2;
++    offset_buf[3] = EXD1_ODIF_DMACTLO3;
++    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
++    {
++        goto err_reset;
++    }
++
++    /* Soft reset */
++    iowrite32(0xB1FF03FF, g_aimac_base_address[ch] + EXD0_STPC_SFTRST);
++    iowrite32(0xB1FF03FF, g_aimac_base_address[ch] + EXD1_STPC_SFTRST);
++    iowrite32(0x0000001F, g_aimac_base_address[ch] + CLKRSTCON_SFTRST);
++
++    /* Stop clock */
++    iowrite32(0x00000000, g_aimac_base_address[ch] + EXD0_STPC_CLKE);
++    iowrite32(0x00000000, g_aimac_base_address[ch] + EXD1_STPC_CLKE);
++    iowrite32(0x00000000, g_aimac_base_address[ch] + CLKRSTCON_CLKE);
++
++    /* Stop MCLKGEN */
++    iowrite32(0x00000001, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_STBYWAIT);
++
++    ret =  R_DRPAI_SUCCESS;
++    goto end;
++
++err_invalid_arg:
++    ret = R_DRPAI_ERR_INVALID_ARG;
++    goto end;
++err_reset:
++    ret = R_DRPAI_ERR_RESET;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return ret;
++}
++
++int32_t R_DRPAI_CPG_Reset(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int32_t ret;
++    int32_t i = 0;
++    int r_data;
++    struct drpai_priv *priv = drpai_priv;
++    bool is_stop = false;
++	
++	/* Access reset controller interface */
++	reset_control_assert(priv->rstc);
++    reset_control_deassert(priv->rstc);
++
++	/* Check reset status */
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        udelay(1);
++        i++;
++		r_data = reset_control_status(priv->rstc);
++        if(1 == r_data)
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        usleep_range(100, 200);
++        i++;
++		r_data = reset_control_status(priv->rstc);
++        if(1 == r_data)
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    if(true == is_stop)
++    {
++        ret =  R_DRPAI_SUCCESS;
++    }
++    else
++    {
++        ret = R_DRPAI_ERR_RESET;
++        DRPAI_DEBUG_PRINT(KERN_INFO "%s: CPG Reset failed. Reset Control Status: %d\n", __func__,  r_data);
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    return ret;
++}
++
++
++MODULE_DESCRIPTION("RZ/V2L DRP-AI driver");
++MODULE_AUTHOR("Renesas Electronics Corporation");
++MODULE_LICENSE("GPL v2");
+diff --git a/drivers/drpai/drpai-core.h b/drivers/drpai/drpai-core.h
+new file mode 100644
+index 000000000000..309025905539
+--- /dev/null
++++ b/drivers/drpai/drpai-core.h
+@@ -0,0 +1,97 @@
++/*
++ * Driver for the Renesas RZ/V2L DRP-AI unit
++ *
++ * Copyright (C) 2021 Renesas Electronics Corporation
++ *
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifndef R_DRPAI_CORE_H
++#define R_DRPAI_CORE_H
++
++#ifdef __KERNEL__
++#include <linux/types.h>
++#include <linux/semaphore.h>
++#else /* __KERNEL__ */
++#include "r_typedefs.h"
++#endif /* __KERNEL__ */
++
++#define CH0                             (0)
++#define CH1                             (1)
++#define CH2                             (2)
++#define CH3                             (3)
++#define DRP_CH_NUM                      (1)
++#define AIMAC_CH_NUM                    (1)
++#define MAC256_CH_NUM                   (4)
++
++/* Error code */
++#define R_DRPAI_SUCCESS                 (0)
++#define R_DRPAI_ERR_INVALID_ARG         (-1)
++#define R_DRPAI_ERR_RESET               (-2)
++
++#define RST_CPG_WAIT (10)
++#define RST_MAX_TIMEOUT (100)
++
++// #define   DRPAI_DRV_DEBUG
++#ifdef  DRPAI_DRV_DEBUG
++#define DRPAI_DEBUG_PRINT(...)      printk(__VA_ARGS__)
++#else
++#define DRPAI_DEBUG_PRINT(...)
++#endif
++
++/* Type definitions */
++struct drpai_priv {
++    struct platform_device *pdev;
++    const char *dev_name;
++    drpai_status_t drpai_status;
++    spinlock_t lock;
++    struct semaphore sem;
++    refcount_t count;
++    void __iomem *drp_base;
++    void __iomem *aimac_base;
++    struct clk *clk_int;
++    struct clk *clk_aclk_drp;
++    struct clk *clk_mclk;
++    struct clk *clk_dclkin;
++    struct clk *clk_aclk;
++    struct reset_control *rstc;
++    uint32_t aimac_irq_flag;
++/* ISP */
++    void (*isp_finish_loc)(int);
++/* ISP */
++};
++
++/* ISP */
++typedef struct drpai_odif_intcnto
++{
++    uint32_t    ch0;
++    uint32_t    ch1;
++    uint32_t    ch2;
++    uint32_t    ch3;
++} drpai_odif_intcnto_t;
++/* ISP */
++
++int32_t R_DRPAI_DRP_Open(int32_t ch);
++int32_t R_DRPAI_DRP_Start(int32_t ch, uint32_t desc);
++/* ISP */
++int32_t R_DRPAI_DRP_Nmlint(int32_t ch, drpai_odif_intcnto_t *odif_intcnto);
++/* ISP */
++int32_t R_DRPAI_DRP_Errint(int32_t ch);
++int32_t R_DRPAI_AIMAC_Open(int32_t ch);
++int32_t R_DRPAI_AIMAC_Start(int32_t ch, uint32_t desc);
++int32_t R_DRPAI_AIMAC_Nmlint(int32_t ch);
++int32_t R_DRPAI_AIMAC_Errint(int32_t ch);
++int32_t R_DRPAI_Status(int32_t ch, drpai_status_t *drpai_status);
++int32_t R_DRPAI_DRP_Reset(int32_t ch);
++int32_t R_DRPAI_AIMAC_Reset(int32_t ch);
++int32_t R_DRPAI_CPG_Reset(void);
++
++#endif /* R_DRPAI_CORE_H */
+diff --git a/drivers/drpai/drpai-if.c b/drivers/drpai/drpai-if.c
+new file mode 100644
+index 000000000000..dafa00282600
+--- /dev/null
++++ b/drivers/drpai/drpai-if.c
+@@ -0,0 +1,2603 @@
++/*
++ * Driver for the Renesas RZ/V2L DRP-AI unit
++ *
++ * Copyright (C) 2021 Renesas Electronics Corporation
++ *
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <asm/cacheflush.h>
++#include <asm/current.h>
++#include <asm/io.h>
++#include <asm/uaccess.h>
++#include <linux/cdev.h>
++#include <linux/device.h>
++#include <linux/dma-mapping.h>
++#include <linux/fs.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/miscdevice.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/pm.h>
++#include <linux/poll.h>
++#include <linux/sched.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++#include <linux/wait.h>
++#include <linux/fs.h>
++#include <asm/uaccess.h>
++#include <linux/buffer_head.h>
++#include <linux/dma-mapping.h> /* ISP */
++#include <linux/drpai.h>    /* Header file for DRP-AI Driver */
++#include "drpai-core.h"     /* Header file for DRP-AI Core */
++#include <linux/delay.h>
++#include <linux/clk.h>
++#include <linux/reset.h>
++
++#define DRPAI_DRIVER_VERSION         "1.10"
++#define DRPAI_DEV_NUM               (1)
++#define DRPAI_DRIVER_NAME           "drpai"     /* Device name */
++#define DRPAI_64BYTE_ALIGN          (0x3F)      /* Check 64-byte alignment */
++#define DRPAI_STATUS_IDLE_RW        (10)
++#define DRPAI_STATUS_ASSIGN         (11)
++#define DRPAI_STATUS_DUMP_REG       (12)
++#define DRPAI_STATUS_READ_MEM       (13)
++#define DRPAI_STATUS_READ_REG       (14)
++#define DRPAI_STATUS_WRITE          (15)
++#define DRPAI_STATUS_ASSIGN_PARAM   (16)
++#define DRPAI_STATUS_WRITE_PARAM    (17)
++
++#define MAX_SEM_TIMEOUT (msecs_to_jiffies(1000))
++#define HEAD_SENTINEL (UINT_MAX)
++
++/* ISP */
++#define DRPAI_SGL_DRP_DESC_SIZE     (80)
++#define DRPAI_DESC_CMD_SIZE         (16)
++#define DRPAI_CMA_SIZE              ((DRPAI_SGL_DRP_DESC_SIZE * 1) + DRPAI_DESC_CMD_SIZE + 64)
++/* ISP */
++
++#define DRP_PARAM_MAX_LINE_LENGTH (512)
++#define DRP_PARAM_raddr           (0)
++#define DRP_PARAM_waddr           (4)
++#define DRP_PARAM_IMG_IWIDTH      (8)
++#define DRP_PARAM_IMG_IHEIGHT     (10)
++#define DRP_PARAM_IMG_OWIDTH      (16)
++#define DRP_PARAM_IMG_OHEIGHT     (18)
++#define DRP_PARAM_CROP_POS_X      (48)
++#define DRP_PARAM_CROP_POS_Y      (50)
++#define DRP_LIB_NAME_CROP         (",drp_lib:crop,")
++#define DRP_PARAM_ATTR_OFFSET_ADD ("OFFSET_ADD:")
++#define DRP_PARAM_ATTR_PROP_INPUT (",prop:input,")
++#define DRP_PARAM_ATTR_PROP_OUTPUT (",prop:output,")
++
++/* A function called from the kernel */
++static int drpai_probe(struct platform_device *pdev);
++static int drpai_remove(struct platform_device *pdev);
++static int drpai_open(struct inode *inode, struct file *file);
++static int drpai_close(struct inode *inode, struct file *file);
++static int drpai_flush(struct file *file, fl_owner_t id);
++static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
++static ssize_t  drpai_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
++static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
++static unsigned int drpai_poll( struct file* filp, poll_table* wait );
++static irqreturn_t irq_drp_errint(int irq, void *dev);
++static irqreturn_t irq_mac_nmlint(int irq, void *dev);
++static irqreturn_t irq_mac_errint(int irq, void *dev);
++
++/* ISP */
++static irqreturn_t irq_drp_nmlint(int irq, void *dev);
++
++/* Function called from the kernel */
++int drpai_open_k(void);
++int drpai_close_k(void);
++int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result));
++/* ISP */
++
++
++/* Internal function */
++static int drpai_regist_driver(void);
++static int drpai_regist_device(struct platform_device *pdev);
++static void drpai_unregist_driver(void);
++static void drpai_unregist_device(void);
++static void drpai_init_device(uint32_t ch);
++static int8_t drpai_reset_device(uint32_t ch);
++static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg);
++static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg);
++static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg);
++static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg);
++static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned long arg);
++static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg);
++static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg);
++static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg);
++static int8_t get_param_attr(char *line, char *attr, unsigned long *rvalue);
++static int8_t drp_param_change16(uint32_t base, uint32_t offset, uint16_t value);
++static int8_t drp_param_change32(uint32_t base, uint32_t offset, uint32_t value);
++static int8_t drpai_flush_dcache_input_area(drpai_data_t *input);
++/* ISP */
++static int drpai_drp_config_init(void);
++static void drpai_drp_config_uninit(void);
++static int drpai_drp_cpg_init(void);
++/* ISP */
++
++/* Linux device driver initialization */
++static const unsigned int MINOR_BASE = 0;
++static const unsigned int MINOR_NUM  = DRPAI_DEV_NUM;       /* Minor number */
++static unsigned int drpai_major;                    /* Major number (decided dinamically) */
++static struct cdev drpai_cdev;                      /* Character device object */
++static struct class *drpai_class = NULL;            /* class object */
++struct device *drpai_device_array[DRPAI_DEV_NUM];
++
++static DECLARE_WAIT_QUEUE_HEAD(drpai_waitq);
++
++struct drpai_priv *drpai_priv;
++
++struct drpai_rw_status {
++    uint32_t rw_status;
++    uint32_t read_count;
++    uint32_t write_count;
++    uint32_t drp_reg_offset_count;
++    uint32_t aimac_reg_offset_count;
++    drpai_data_t drpai_data;
++    struct list_head list;
++    drpai_assign_param_t assign_param;
++    char *param_info;
++    atomic_t inout_flag;
++};
++
++static DEFINE_SEMAPHORE(rw_sem);
++static struct drpai_rw_status *drpai_rw_sentinel;
++
++/* Virtual base address of register */
++void __iomem *g_drp_base_addr[DRP_CH_NUM];
++void __iomem *g_aimac_base_address[AIMAC_CH_NUM];
++static resource_size_t drp_size;
++static resource_size_t aimac_size;
++static resource_size_t drpai_region_base_addr;
++static resource_size_t drpai_region_size;
++static resource_size_t drpai_linux_mem_start;
++static resource_size_t drpai_linux_mem_size;
++
++/* ISP */
++static char* p_dmabuf_vaddr;
++static dma_addr_t p_dmabuf_phyaddr;
++static unsigned char drp_single_desc_bin[] =
++{
++  0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++  0x00, 0x80, 0x00, 0x01, 0x00, 0x91, 0x81, 0x50, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
++  0x07, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++  0x00, 0x80, 0x00, 0x01, 0x00, 0x91, 0x81, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
++  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
++};
++
++drpai_odif_intcnto_t odif_intcnto;
++/* ISP */
++
++/* handler table */
++static struct file_operations s_mydevice_fops = {
++    .open           = drpai_open,
++    .release        = drpai_close,
++    .write          = drpai_write,
++    .read           = drpai_read,
++    .unlocked_ioctl = drpai_ioctl,
++    .compat_ioctl   = drpai_ioctl, /* for 32-bit App */
++    .poll           = drpai_poll,
++    .flush          = drpai_flush,
++};
++static const struct of_device_id drpai_match[] = {
++
++    { .compatible = "renesas,rzv2l-drpai",},
++    { /* sentinel */ }
++};
++static struct platform_driver drpai_platform_driver = {
++    .driver = {
++        .name   = "drpai-rz",
++        .of_match_table = drpai_match,
++    },
++    .probe      = drpai_probe,
++    .remove     = drpai_remove,
++};
++
++static int drpai_probe(struct platform_device *pdev)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    drpai_regist_driver();
++    drpai_regist_device(pdev);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return 0;
++}
++
++static int drpai_remove(struct platform_device *pdev)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    drpai_unregist_driver();
++    drpai_unregist_device();
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return 0;
++}
++
++static int drpai_open(struct inode *inode, struct file *file)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int result = 0;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++    struct drpai_rw_status *drpai_rw_status = 0;
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) major %d minor %d\n", __func__, current->pid, imajor(inode), iminor(inode));
++
++    /* Allocate drpai_rw_status to each file descriptor */
++    drpai_rw_status = kzalloc(sizeof(struct drpai_rw_status), GFP_KERNEL);
++    if (!drpai_rw_status) 
++    {
++        result = -ENOMEM;
++        goto end;
++    }
++    /* Initialization flag */
++    drpai_rw_status->rw_status  = DRPAI_STATUS_IDLE_RW;
++    drpai_rw_status->param_info = NULL;
++    INIT_LIST_HEAD(&drpai_rw_status->list);
++    atomic_set(&drpai_rw_status->inout_flag, 0);
++    DRPAI_DEBUG_PRINT("[%s](pid %d) Generated list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
++    file->private_data = drpai_rw_status;
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
++    {
++        result = -ETIMEDOUT;
++        goto end;
++    }
++
++    if(likely((1 == refcount_read(&priv->count)) && (1 == atomic_long_read(&file->f_count))))
++    {
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) Initialize DRP-AI\n", __func__, current->pid);
++
++        /* CPG Reset */
++        if(drpai_drp_cpg_init())
++        {
++            result = -EIO;
++            goto end;
++        }
++
++        /* Initialize DRP-AI */
++        drpai_init_device(0);
++
++        /* Reset DRP-AI */
++        if(R_DRPAI_SUCCESS != drpai_reset_device(0))
++        {
++            result = -EIO;
++            goto end;
++        }
++
++        /* Initialize DRP-AI */
++        drpai_init_device(0);
++
++        /* INIT -> IDLE */
++        spin_lock_irqsave(&priv->lock, flags);
++        priv->drpai_status.status = DRPAI_STATUS_IDLE;
++        spin_unlock_irqrestore(&priv->lock, flags);
++    }
++    /* Increment reference count */
++    refcount_inc(&priv->count);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    result = 0;
++    goto end;
++end:
++    if((-ENOMEM != result) || (-ETIMEDOUT != result))
++    {
++        up(&priv->sem);
++    }
++    if((0 != drpai_rw_status) && (0 != result))
++    {
++        kfree(file->private_data);
++        file->private_data = NULL;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return result;
++}
++
++static int drpai_close(struct inode *inode, struct file *file)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) major %d minor %d\n", __func__, current->pid, imajor(inode), iminor(inode));
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return 0;
++}
++
++static int drpai_flush(struct file *file, fl_owner_t id)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int result = 0;
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++    struct drpai_rw_status *drpai_rw_status = file->private_data;
++    struct drpai_rw_status *entry;
++    struct list_head *listitr;
++
++    if(unlikely(down_interruptible(&rw_sem))) 
++    {
++        result = -ERESTART;
++        goto end;
++    }
++
++    DRPAI_DEBUG_PRINT("[%s](pid %d) HEAD  list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
++    if(!list_empty(&drpai_rw_sentinel->list))
++    {
++        if((DRPAI_STATUS_ASSIGN   == drpai_rw_status->rw_status) || 
++           (DRPAI_STATUS_READ_MEM == drpai_rw_status->rw_status) ||
++           (DRPAI_STATUS_WRITE    == drpai_rw_status->rw_status))
++           {
++                DRPAI_DEBUG_PRINT("[%s](pid %d) Deleted list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
++                list_del(&drpai_rw_status->list);
++           }
++    }
++    up(&rw_sem);
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++    {
++        result = -ETIMEDOUT;
++        goto end;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
++
++    if(1 == atomic_long_read(&file->f_count))
++    {
++        if(2 == refcount_read(&priv->count))
++        {
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start DRP-AI reset\n", __func__, current->pid);
++            if(R_DRPAI_SUCCESS != drpai_reset_device(0))
++            {
++                result = -EIO;
++                goto end;
++            }
++
++            //CPG clock disable
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) CPG clock disable\n", __func__, current->pid);
++            clk_disable_unprepare(priv->clk_int);
++            clk_disable_unprepare(priv->clk_aclk_drp);
++            clk_disable_unprepare(priv->clk_mclk);
++            clk_disable_unprepare(priv->clk_dclkin);
++            clk_disable_unprepare(priv->clk_aclk);  
++
++            /* IDLE -> INIT */
++            /* RUN  -> INIT */
++            spin_lock_irqsave(&priv->lock, flags);
++            priv->drpai_status.status = DRPAI_STATUS_INIT;
++            priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
++            spin_unlock_irqrestore(&priv->lock, flags);
++
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) done DRP-AI reset\n", __func__, current->pid);
++        }
++        /* Decrement referenece count*/
++        refcount_dec(&priv->count);
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
++
++    goto end;
++end:
++    if((-ERESTART != result) || (-ETIMEDOUT != result))
++    {
++        up(&priv->sem);
++    }
++    if(1 == atomic_long_read(&file->f_count))
++    {
++        /* Free memory */
++        if(NULL != drpai_rw_status->param_info)
++        {
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) vfree is called\n", __func__, current->pid);
++            vfree(drpai_rw_status->param_info);
++            drpai_rw_status->param_info = NULL;
++        }
++        if(file->private_data) 
++        {
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) kfree is called\n", __func__, current->pid);
++            kfree(file->private_data);
++            file->private_data = NULL;
++        }
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return result;
++}
++
++static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    ssize_t result = 0;
++    uint8_t *kbuf = NULL;
++    volatile void *p_drpai_cma = 0;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++
++    if(unlikely(down_trylock(&rw_sem)))
++    {
++        result = -ERESTART;
++        goto end;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    /* Check status */
++    if (!((DRPAI_STATUS_ASSIGN == drpai_rw_status->rw_status) || 
++          (DRPAI_STATUS_WRITE == drpai_rw_status->rw_status) ||
++          (DRPAI_STATUS_ASSIGN_PARAM == drpai_rw_status->rw_status) ||
++          (DRPAI_STATUS_WRITE_PARAM == drpai_rw_status->rw_status)))
++    {
++        result = -EACCES;
++        goto end;
++    }
++
++    /* Check Argument */
++    if (NULL == buf)
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if (0 == count)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    switch(drpai_rw_status->rw_status)
++    {
++        case DRPAI_STATUS_ASSIGN:
++            /* DRPAI_STATUS_ASSIGN -> DRPAI_STATUS_WRITE */
++            drpai_rw_status->rw_status = DRPAI_STATUS_WRITE;
++            break;
++        case DRPAI_STATUS_ASSIGN_PARAM:
++            /* DRPAI_STATUS_ASSIGN_PARAM -> DRPAI_STATUS_WRITE_PARAM */
++            drpai_rw_status->rw_status = DRPAI_STATUS_WRITE_PARAM;
++            break;
++        default:
++            ; /* Do nothing */
++            break;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    switch(drpai_rw_status->rw_status)
++    {
++        case DRPAI_STATUS_WRITE:
++            /* Secure Kbuf area */
++            kbuf = vmalloc(count);
++            if (NULL == kbuf)
++            {
++                result = -ENOMEM;
++                goto end;
++            }
++            /* Copy arguments from user space to kernel space */
++            if (copy_from_user(kbuf, buf, count))
++            {
++                result = -EFAULT;
++                goto end;
++            }
++
++            /* Expand to DRP for CMA */
++            p_drpai_cma = phys_to_virt(drpai_rw_status->drpai_data.address + drpai_rw_status->write_count);
++            if (p_drpai_cma == 0)
++            {
++                result = -EFAULT;
++                goto end;
++            }
++            if ( !( drpai_rw_status->drpai_data.size >= (drpai_rw_status->write_count + count) ) )
++            {
++                count = drpai_rw_status->drpai_data.size - drpai_rw_status->write_count;
++            }
++            memcpy(p_drpai_cma, kbuf, count);
++            drpai_rw_status->write_count = drpai_rw_status->write_count + count;
++
++            /* DRPAI_STATUS_WRITE -> DRPAI_STATUS_IDLE_RW */
++            if (drpai_rw_status->drpai_data.size <= drpai_rw_status->write_count)
++            {
++                p_drpai_cma = phys_to_virt(drpai_rw_status->drpai_data.address);
++                if (p_drpai_cma == 0)
++                {
++                    result = -EFAULT;
++                    goto end;
++                }
++                __flush_dcache_area(p_drpai_cma, drpai_rw_status->drpai_data.size);
++                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
++                DRPAI_DEBUG_PRINT("[%s](pid %d) Deleted list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
++                list_del(&drpai_rw_status->list);
++                drpai_rw_status->drpai_data.address = 0x0;
++                drpai_rw_status->drpai_data.size    = 0x0;
++            }
++            result = count;
++            break;
++        case DRPAI_STATUS_WRITE_PARAM:
++            if ( !( drpai_rw_status->assign_param.info_size >= (drpai_rw_status->write_count + count) ) )
++            {
++                count = drpai_rw_status->assign_param.info_size - drpai_rw_status->write_count;
++            }
++            /* Copy arguments from user space to kernel space */
++            if (copy_from_user(&drpai_rw_status->param_info[drpai_rw_status->write_count], buf, count))
++            {
++                result = -EFAULT;
++                goto end;
++            }
++            drpai_rw_status->write_count = drpai_rw_status->write_count + count;
++            /* DRPAI_STATUS_WRITE_PARAM -> DRPAI_STATUS_IDLE_RW */
++            if (drpai_rw_status->assign_param.info_size <= drpai_rw_status->write_count)
++            {
++                DRPAI_DEBUG_PRINT("[%s](pid %d) Status is changed \n", __func__, current->pid);
++                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
++            }
++            result = count;
++            break;
++        default:
++            ; /* Do nothing */
++            break;
++    }
++    goto end;
++end:
++    if(-ERESTART != result)
++    {
++        up(&rw_sem);
++    }
++    if (NULL != kbuf)
++    {
++        /* Free kbuf */
++        vfree(kbuf);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw3:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return result;
++}
++
++static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    ssize_t result = 0;
++    uint8_t *kbuf = NULL;
++    volatile void *p_drpai_cma = 0;
++    uint32_t reg_val;
++    uint32_t i;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++    struct drpai_priv *priv = drpai_priv;
++
++    if(unlikely(down_trylock(&rw_sem)))
++    {
++        result = -ERESTART;
++        goto end;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    /* Check status */
++    if (!((DRPAI_STATUS_ASSIGN  == drpai_rw_status->rw_status) ||
++        (DRPAI_STATUS_DUMP_REG  == drpai_rw_status->rw_status) ||
++        (DRPAI_STATUS_READ_MEM  == drpai_rw_status->rw_status) ||
++        (DRPAI_STATUS_READ_REG  == drpai_rw_status->rw_status)))
++    {
++        result = -EACCES;
++        goto end;
++    }
++
++    /* Check Argument */
++    if (NULL == buf)
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if (0 == count)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    /* Secure Kbuf area */
++    kbuf = vmalloc(count);
++    if (NULL == kbuf)
++    {
++        result = -ENOMEM;
++        goto end;
++    }
++
++    switch(drpai_rw_status->rw_status)
++    {
++        case DRPAI_STATUS_ASSIGN:
++            /* DRPAI_STATUS_ASSIGN -> DRPAI_STATUS_READ_MEM */
++            drpai_rw_status->rw_status = DRPAI_STATUS_READ_MEM;
++            break;
++        case DRPAI_STATUS_DUMP_REG:
++            /* DRPAI_STATUS_DUMP_REG -> DRPAI_STATUS_READ_REG */
++            drpai_rw_status->rw_status = DRPAI_STATUS_READ_REG;
++            break;
++        default:
++            ; /* Do nothing */
++            break;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    switch(drpai_rw_status->rw_status)
++    {
++        case DRPAI_STATUS_READ_MEM:
++            /* Read DRP-AI memory */
++            p_drpai_cma = phys_to_virt(drpai_rw_status->drpai_data.address + drpai_rw_status->read_count);
++            if (p_drpai_cma == 0)
++            {
++                result = -EFAULT;
++                goto end;
++            }
++            if ( !( drpai_rw_status->drpai_data.size >= (drpai_rw_status->read_count + count) ) )
++            {
++                count = drpai_rw_status->drpai_data.size - drpai_rw_status->read_count;
++            }
++            memcpy(kbuf, p_drpai_cma, count);
++            drpai_rw_status->read_count = drpai_rw_status->read_count + count;
++
++            /* DRPAI_STATUS_READ -> DRPAI_STATUS_IDLE_RW */
++            if (drpai_rw_status->drpai_data.size <= drpai_rw_status->read_count)
++            {
++                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
++                DRPAI_DEBUG_PRINT("[%s](pid %d) Deleted list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
++                list_del(&drpai_rw_status->list);
++                drpai_rw_status->drpai_data.address = 0x0;
++                drpai_rw_status->drpai_data.size    = 0x0;
++            }
++            i = count;
++            break;
++        case DRPAI_STATUS_READ_REG:
++            /* Read DRP-AI register */
++            if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++            {
++                result = -ETIMEDOUT;
++                goto end;
++            }
++            for (i = 0; i < count; i+=4)
++            {
++                if (drp_size > drpai_rw_status->read_count)
++                {
++                    reg_val = ioread32(g_drp_base_addr[0] + drpai_rw_status->drp_reg_offset_count);
++                    *(kbuf + i)     = (uint8_t)reg_val;
++                    *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
++                    *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
++                    *(kbuf + i + 3) = (uint8_t)(reg_val >> 24);
++                    drpai_rw_status->drp_reg_offset_count+=4;
++                }
++                else
++                {
++                    reg_val = ioread32(g_aimac_base_address[0] + drpai_rw_status->aimac_reg_offset_count);
++                    *(kbuf + i)     = (uint8_t)reg_val;
++                    *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
++                    *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
++                    *(kbuf + i + 3) = (uint8_t)(reg_val >> 24);
++                    drpai_rw_status->aimac_reg_offset_count+=4;
++                }
++                drpai_rw_status->read_count+=4;
++
++                /* DRPAI_STATUS_READ_REG -> DRPAI_STATUS_IDLE_RW */
++                if ((drp_size + aimac_size) <= drpai_rw_status->read_count)
++                {
++                    drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
++                    i+=4;
++                    break;
++                }
++            }
++            up(&priv->sem);
++            break;
++        default:
++            ; /* Do nothing */
++            break;
++    }
++
++    /* Copy arguments from kernel space to user space */
++    if (copy_to_user(buf, kbuf, count))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++
++    result = i;
++    goto end;
++end:
++    if(-ERESTART != result)
++    {
++        up(&rw_sem);
++    }
++    if (NULL != kbuf)
++    {
++        /* Free kbuf */
++        vfree(kbuf);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw3:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return result;
++}
++
++static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    long result = 0;
++
++    switch (cmd) {
++    case DRPAI_ASSIGN:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_ASSIGN)](pid %d)\n", current->pid);
++        result = drpai_ioctl_assign(filp, cmd, arg);
++        break;
++    case DRPAI_START:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_START)](pid %d)\n", current->pid);
++        result = drpai_ioctl_start(filp, cmd, arg);
++        break;
++    case DRPAI_RESET:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_RESET)](pid %d)\n", current->pid);
++        result = drpai_ioctl_reset(filp, cmd, arg);
++        break;
++    case DRPAI_GET_STATUS:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_GET_STATUS)](pid %d)\n", current->pid);
++        result = drpai_ioctl_get_status(filp, cmd, arg);
++        break;
++    case DRPAI_REG_DUMP:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_REG_DUMP)](pid %d)\n", current->pid);
++        result = drpai_ioctl_reg_dump(filp, cmd, arg);
++        break;
++    case DRPAI_ASSIGN_PARAM:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_ASSIGN_PARAM)](pid %d)\n", current->pid);
++        result = drpai_ioctl_assign_param(filp, cmd, arg);
++        break;
++    case DRPAI_PREPOST_CROP:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_PREPOST_CROP)](pid %d)\n", current->pid);
++        result = drpai_ioctl_prepost_crop(filp, cmd, arg);
++        break;
++    case DRPAI_PREPOST_INADDR:
++        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_PREPOST_INADDR)](pid %d)\n", current->pid);
++        result = drpai_ioctl_prepost_inaddr(filp, cmd, arg);
++        break;
++    default:
++        DRPAI_DEBUG_PRINT(KERN_WARNING "unsupported command %d\n", cmd);
++        result = -EFAULT;
++        break;
++    }
++    goto end;
++
++end:
++    return result;
++}
++
++static unsigned int drpai_poll( struct file* filp, poll_table* wait )
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    unsigned int retmask = 0;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++
++    spin_lock_irqsave(&priv->lock, flags);
++
++    poll_wait( filp, &drpai_waitq,  wait );
++
++    if (1 == priv->aimac_irq_flag)
++    {
++        retmask |= ( POLLIN  | POLLRDNORM );
++    }
++
++    spin_unlock_irqrestore(&priv->lock, flags);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return retmask;
++}
++
++/* ISP */
++static irqreturn_t irq_drp_nmlint(int irq, void *dev)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++    drpai_odif_intcnto_t local_odif_intcnto;
++
++    spin_lock_irqsave(&priv->lock, flags);
++    /* For success ISP call back*/
++    void (*finish_callback)(int);
++    finish_callback = priv->isp_finish_loc;
++    /* For success ISP call back*/
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
++
++    /* DRP normal interrupt processing */
++    R_DRPAI_DRP_Nmlint(0, &local_odif_intcnto);
++
++    odif_intcnto.ch0 += local_odif_intcnto.ch0;
++    odif_intcnto.ch1 += local_odif_intcnto.ch1;
++    odif_intcnto.ch2 += local_odif_intcnto.ch2;
++    odif_intcnto.ch3 += local_odif_intcnto.ch3;
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO0 : 0x%08X\n", local_odif_intcnto.ch0);
++    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO1 : 0x%08X\n", local_odif_intcnto.ch1);
++    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO2 : 0x%08X\n", local_odif_intcnto.ch2);
++    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO3 : 0x%08X\n", local_odif_intcnto.ch3);
++
++    if  ((1 == odif_intcnto.ch0) &&
++        (1 == odif_intcnto.ch1) &&
++        (1 == odif_intcnto.ch2) &&
++        (1 == odif_intcnto.ch3))
++     {
++        /* Internal state update */
++        priv->drpai_status.status = DRPAI_STATUS_IDLE;
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
++        /* For success ISP call back*/
++        if(NULL != finish_callback)
++        {
++            (*finish_callback)(0);
++        }
++     }
++    priv->isp_finish_loc = NULL;
++    spin_unlock_irqrestore(&priv->lock, flags);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return IRQ_HANDLED;
++}
++/* ISP */
++
++static irqreturn_t irq_drp_errint(int irq, void *dev)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++
++    spin_lock_irqsave(&priv->lock, flags);
++/* ISP */
++/* For error ISP call back*/
++    void (*finish_callback)(int);
++    finish_callback = priv->isp_finish_loc;
++
++    if(NULL != finish_callback)
++    {
++        (*finish_callback)(-5);
++    }
++/* For error ISP call back*/
++/* ISP */
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
++
++    /* DRP error interrupt processing */
++    R_DRPAI_DRP_Errint(0);
++
++/* ISP */
++    /* Internal state update */
++    priv->drpai_status.err = DRPAI_ERRINFO_DRP_ERR;
++    priv->drpai_status.status = DRPAI_STATUS_IDLE;
++    priv->aimac_irq_flag = 1;
++    
++    /* Wake up the process when it's not ISP mode*/
++    if(NULL == finish_callback)
++    {
++        wake_up_interruptible( &drpai_waitq );
++    }
++    priv->isp_finish_loc = NULL;
++/* ISP */
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
++    spin_unlock_irqrestore(&priv->lock, flags);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return IRQ_HANDLED;
++}
++
++static irqreturn_t irq_mac_nmlint(int irq, void *dev)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++
++    spin_lock_irqsave(&priv->lock, flags);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
++
++    /* AI-MAC normal interrupt processing */
++    R_DRPAI_AIMAC_Nmlint(0);
++
++    /* Internal state update */
++    priv->drpai_status.status = DRPAI_STATUS_IDLE;
++    priv->aimac_irq_flag = 1;
++    
++    /* Wake up the process */
++    wake_up_interruptible( &drpai_waitq );
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
++    spin_unlock_irqrestore(&priv->lock, flags);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return IRQ_HANDLED;
++}
++static irqreturn_t irq_mac_errint(int irq, void *dev)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++
++    spin_lock_irqsave(&priv->lock, flags);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
++
++    /* AI-MAC error interrupt processing */
++    R_DRPAI_AIMAC_Errint(0);
++
++    /* Internal state update */
++    priv->drpai_status.err = DRPAI_ERRINFO_AIMAC_ERR;
++    priv->drpai_status.status = DRPAI_STATUS_IDLE;
++    priv->aimac_irq_flag = 1;
++    
++    /* Wake up the process */
++    wake_up_interruptible( &drpai_waitq );
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
++    spin_unlock_irqrestore(&priv->lock, flags);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return IRQ_HANDLED;
++}
++
++static int drpai_regist_driver(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int alloc_ret = 0;
++    int cdev_err = 0;
++    dev_t dev;
++
++    printk(KERN_INFO "DRP-AI Driver version : %s\n", DRPAI_DRIVER_VERSION);
++
++    /* Get free major number. */
++    alloc_ret = alloc_chrdev_region(&dev, MINOR_BASE, MINOR_NUM, DRPAI_DRIVER_NAME);
++    if (alloc_ret != 0) {
++        printk(KERN_ERR "alloc_chrdev_region = %d\n", alloc_ret);
++        return -1;
++    }
++
++    /* Save major number. */
++    drpai_major = MAJOR(dev);
++    dev = MKDEV(drpai_major, MINOR_BASE);
++
++    /* Initialize cdev and registration handler table. */
++    cdev_init(&drpai_cdev, &s_mydevice_fops);
++    drpai_cdev.owner = THIS_MODULE;
++
++    /* Registration cdev */
++    cdev_err = cdev_add(&drpai_cdev, dev, MINOR_NUM);
++    if (cdev_err != 0) {
++        printk(KERN_ERR  "cdev_add = %d\n", cdev_err);
++        unregister_chrdev_region(dev, MINOR_NUM);
++        return -1;
++    }
++
++    /* Cleate class "/sys/class/drpai/" */
++    drpai_class = class_create(THIS_MODULE, DRPAI_DRIVER_NAME);
++    if (IS_ERR(drpai_class)) {
++        printk(KERN_ERR  "class_create = %d\n", drpai_class);
++        cdev_del(&drpai_cdev);
++        unregister_chrdev_region(dev, MINOR_NUM);
++        return -1;
++    }
++
++    int minor;
++    /* Make "/sys/class/drpai/drpai*" */
++    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
++        drpai_device_array[minor - MINOR_BASE] =
++        device_create(drpai_class, NULL, MKDEV(drpai_major, minor), NULL, DRPAI_DRIVER_NAME "%d", minor);
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return 0;
++}
++
++static int drpai_regist_device(struct platform_device *pdev)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    struct resource *res;
++    struct resource reserved_res;
++    struct device_node *np;
++    struct drpai_priv *priv;
++    struct drpai_rw_status *drpai_rw_status;
++    int irq, ret;
++    void __iomem *base;
++
++    /* Intialize DRP-AI status to control */
++    priv = devm_kzalloc(&pdev->dev, sizeof(struct drpai_priv), GFP_KERNEL);
++    if (!priv) {
++        dev_err(&pdev->dev, "cannot allocate private data\n");
++        return -ENOMEM;
++    }
++
++    platform_set_drvdata(pdev, priv);
++    priv->pdev = pdev;
++    priv->dev_name = dev_name(&pdev->dev);
++    spin_lock_init(&priv->lock);
++    sema_init(&priv->sem, DRPAI_DEV_NUM);
++    refcount_set(&priv->count, 1);
++    priv->drpai_status.status = DRPAI_STATUS_INIT; 
++    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
++    drpai_priv = priv;
++/* ISP */
++    /* Call back function pointer initialization */
++    drpai_priv->isp_finish_loc = NULL;
++/* ISP */
++
++    /* Initialize list head */
++    drpai_rw_status = devm_kzalloc(&pdev->dev, sizeof(struct drpai_rw_status), GFP_KERNEL);
++    if (!drpai_rw_status) {
++        dev_err(&pdev->dev, "cannot allocate sentinel data\n");
++        return -ENOMEM;
++    }
++    drpai_rw_status->rw_status  = HEAD_SENTINEL;
++    drpai_rw_status->param_info = NULL;
++    INIT_LIST_HEAD(&drpai_rw_status->list);
++    atomic_set(&drpai_rw_status->inout_flag, 0);
++    drpai_rw_sentinel = drpai_rw_status;
++    DRPAI_DEBUG_PRINT("[%s](pid %d) HEAD  list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
++
++    /* Get reserved memory region from Device tree.*/
++    np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
++    if (!np) {
++        dev_err(&pdev->dev, "No %s specified\n", "memory-region");
++        return -ENOMEM;
++    }
++
++    /* Convert memory region to a struct resource */
++    ret = of_address_to_resource(np, 0, &reserved_res);
++    if (ret) {
++        dev_err(&pdev->dev, "No memory address assigned to the region\n");
++        return -ENOMEM;
++    }
++    drpai_region_base_addr = reserved_res.start;
++    drpai_region_size = resource_size(&reserved_res);
++    printk(KERN_INFO "DRP-AI memory region start 0x%08X, size 0x%08X\n", drpai_region_base_addr, drpai_region_size);
++
++    /* Get linux memory region from Device tree.*/
++    np = of_parse_phandle(pdev->dev.of_node, "linux-memory-region", 0);
++    if (!np) {
++        dev_err(&pdev->dev, "No %s specified\n", "linux-memory-region");
++        return -ENOMEM;
++    }
++
++    /* read linux start address and size */
++    ret = of_address_to_resource(np, 0, &reserved_res);
++    if (ret) {
++        dev_err(&pdev->dev, "No address assigned to the linux-memory-region\n");
++        return -ENOMEM;
++    }
++    drpai_linux_mem_start = reserved_res.start;
++    drpai_linux_mem_size = resource_size(&reserved_res);
++    printk(KERN_INFO "linux-memory-region start 0x%08X, size 0x%08X\n", drpai_linux_mem_start, drpai_linux_mem_size);
++
++    /* Convert DRP base address from physical to virtual */
++    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++    if (!res) {
++        dev_err(&pdev->dev, "cannot get resources (reg)\n");
++        return -EINVAL;
++    }
++    priv->drp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
++    if (!priv->drp_base) {
++        dev_err(&pdev->dev, "cannot ioremap\n");
++        return -EINVAL;
++    }
++    g_drp_base_addr[0] = priv->drp_base;
++    drp_size = resource_size(res);
++    printk(KERN_INFO "DRP base address 0x%08X, size 0x%08X\n", res->start, drp_size);
++
++    /* Convert AI-MAC base address from physical to virtual */
++    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
++    if (!res) {
++        dev_err(&pdev->dev, "cannot get resources (reg)\n");
++        return -EINVAL;
++    }
++    priv->aimac_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
++    if (!priv->aimac_base) {
++        dev_err(&pdev->dev, "cannot ioremap\n");
++        return -EINVAL;
++    }
++    g_aimac_base_address[0] = priv->aimac_base;
++    aimac_size = resource_size(res);
++    printk(KERN_INFO "AI-MAC base address 0x%08X, size 0x%08X\n", res->start, aimac_size);
++
++    /* Registering an interrupt handler */
++/* ISP */
++    irq = platform_get_irq(pdev, 0);
++    ret = devm_request_irq(&pdev->dev, irq, irq_drp_nmlint, 0, "drpa nmlint", priv);
++    if (ret) {
++        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
++        return ret;
++    }
++/* ISP */
++    irq = platform_get_irq(pdev, 1);
++    ret = devm_request_irq(&pdev->dev, irq, irq_drp_errint, 0, "drpa errint", priv);
++    if (ret) {
++        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
++        return ret;
++    }
++    irq = platform_get_irq(pdev, 2);
++    ret = devm_request_irq(&pdev->dev, irq, irq_mac_nmlint, 0, "drpa mac_nmlint", priv);
++    if (ret) {
++        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
++        return ret;
++    }
++    irq = platform_get_irq(pdev, 3);
++    ret = devm_request_irq(&pdev->dev, irq, irq_mac_errint, 0, "drpa mac_errint", priv);
++    if (ret) {
++        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
++        return ret;
++    }
++
++	/* Get clock controller info */
++	priv->clk_int = devm_clk_get(&pdev->dev, "intclk");
++	if (IS_ERR(priv->clk_int)) {
++		dev_err(&pdev->dev, "missing controller clock");
++		return PTR_ERR(priv->clk_int);
++	}
++	
++	priv->clk_aclk_drp = devm_clk_get(&pdev->dev, "aclk_drp");
++	if (IS_ERR(priv->clk_aclk_drp)) {
++		dev_err(&pdev->dev, "missing controller clock");
++		return PTR_ERR(priv->clk_aclk_drp);
++	}
++	
++	priv->clk_mclk = devm_clk_get(&pdev->dev, "mclk");
++	if (IS_ERR(priv->clk_mclk)) {
++		dev_err(&pdev->dev, "missing controller clock");
++		return PTR_ERR(priv->clk_mclk);
++	}
++	
++	priv->clk_dclkin = devm_clk_get(&pdev->dev, "dclkin");
++	if (IS_ERR(priv->clk_dclkin)) {
++		dev_err(&pdev->dev, "missing controller clock");
++		return PTR_ERR(priv->clk_dclkin);
++	}
++	
++	priv->clk_aclk = devm_clk_get(&pdev->dev, "aclk");
++	if (IS_ERR(priv->clk_aclk)) {
++		dev_err(&pdev->dev, "missing controller clock");
++		return PTR_ERR(priv->clk_aclk);
++	}
++
++    /* Get reset controller info */
++    priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
++    if (IS_ERR(priv->rstc))
++    {
++        DRPAI_DEBUG_PRINT(KERN_INFO "failed to get DRP cpg reset\n");        
++    }
++    else
++    {
++        DRPAI_DEBUG_PRINT(KERN_INFO "OK!!!! get DRP cpg reset\n");        
++    } 
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return 0;
++}
++
++static void drpai_unregist_driver(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    DRPAI_DEBUG_PRINT(KERN_INFO "drpai_unregist_driver");
++
++    dev_t dev = MKDEV(drpai_major, MINOR_BASE);
++
++    int minor;
++    /* Delete "/sys/class/mydevice/mydevice*". */
++    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
++        device_destroy(drpai_class, MKDEV(drpai_major, minor));
++    }
++
++    /* Destroy "/sys/class/mydevice/". */
++    class_destroy(drpai_class);
++
++    /* Delete cdev from kernel. */
++    cdev_del(&drpai_cdev);
++
++    /* Unregistration */
++    unregister_chrdev_region(dev, MINOR_NUM);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++}
++
++static void drpai_unregist_device(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    /* Do nothing */
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++}
++
++static int8_t drpai_reset_device(uint32_t ch)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    int8_t retval;
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++
++    /* Reset DRP */
++    if(R_DRPAI_SUCCESS != R_DRPAI_DRP_Reset(ch)) {
++        goto err_reset;
++    }
++
++    /* Reset AI-MAC */
++    if(R_DRPAI_SUCCESS != R_DRPAI_AIMAC_Reset(ch)) {
++        goto err_reset;
++    }
++
++    /* Reset CPG register */
++    if(R_DRPAI_SUCCESS != R_DRPAI_CPG_Reset()) {
++        goto err_reset;
++    }
++
++    retval = R_DRPAI_SUCCESS;
++    goto end;
++err_reset:
++    retval = R_DRPAI_ERR_RESET;
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return retval;
++}
++
++static void drpai_init_device(uint32_t ch)
++{
++	unsigned long flags;
++    struct drpai_priv *priv = drpai_priv;
++    
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    spin_lock_irqsave(&priv->lock, flags);
++    priv->aimac_irq_flag = 1;
++    spin_unlock_irqrestore(&priv->lock, flags);
++    (void)R_DRPAI_DRP_Open(0);
++    (void)R_DRPAI_AIMAC_Open(0);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++}
++
++static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    long result = 0;
++    volatile void *p_virt_address = 0;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++    struct drpai_rw_status *entry;
++    struct list_head *listitr;
++    drpai_data_t drpai_data_buf;
++
++    if(unlikely(down_trylock(&rw_sem)))
++    {
++        result = -ERESTART;
++        goto end;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) (pid %d)\n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    /* Check NULL */
++    if (NULL == arg)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    /* Check status */
++    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
++    {
++        result = -EACCES;
++        goto end;
++    }
++
++    /* Copy arguments from user space to kernel space */
++    if (copy_from_user(&drpai_data_buf, (void __user *)arg, sizeof(drpai_data_t)))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    /* Check Argument */
++    if (0 != (drpai_data_buf.address & DRPAI_64BYTE_ALIGN))
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    if ((drpai_region_base_addr > drpai_data_buf.address) || 
++       ((drpai_region_base_addr + drpai_region_size) <= (drpai_data_buf.address + drpai_data_buf.size)))
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    /* Check the assigned address */
++    DRPAI_DEBUG_PRINT("[%s](pid %d) list %px prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
++    if(!list_empty(&drpai_rw_sentinel->list))
++    {   
++        DRPAI_DEBUG_PRINT("[%s](pid %d) List is not empty\n", __func__, current->pid);
++        list_for_each(listitr, &drpai_rw_sentinel->list)
++        {
++            entry = list_entry(listitr, struct drpai_rw_status, list);
++            DRPAI_DEBUG_PRINT("[%s](pid %d) rw_status %d list %px prev %px next %px\n", __func__, current->pid, entry->rw_status, &entry->list, entry->list.prev, entry->list.next);
++            if(HEAD_SENTINEL != entry->rw_status)
++            {
++                if( !( (entry->drpai_data.address > (drpai_data_buf.address + drpai_data_buf.size - 1)) ||
++                       ((entry->drpai_data.address + entry->drpai_data.size - 1) < drpai_data_buf.address) ))
++                {
++                    result = -EINVAL;
++                    goto end;
++                }
++            }
++        }
++    }
++
++    /* Data cache invalidate. DRP-AI W -> CPU R */
++    p_virt_address = phys_to_virt(drpai_data_buf.address);
++    if (p_virt_address == 0)
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    __inval_dcache_area(p_virt_address, drpai_data_buf.size);
++
++    /* Initialization of read / write processing variables */
++    drpai_rw_status->drpai_data  = drpai_data_buf;
++    drpai_rw_status->rw_status   = DRPAI_STATUS_ASSIGN;
++    drpai_rw_status->write_count = 0;
++    drpai_rw_status->read_count  = 0;
++    /* Register assigned status */
++    list_add(&drpai_rw_status->list, &drpai_rw_sentinel->list);
++    DRPAI_DEBUG_PRINT("[%s](pid %d) Registered list %px prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
++
++    goto end;
++end:
++    if(-ERESTART != result)
++    {
++        up(&rw_sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    int result = 0;
++    drpai_data_t proc[DRPAI_INDEX_NUM];
++    volatile void *p_drp_param = 0;
++    volatile void *p_drp_desc = 0;
++    volatile void *p_aimac_desc = 0;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++    int i;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++    {
++        result = -ETIMEDOUT;
++        goto end;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
++
++    /* Check NULL */
++    if (NULL == arg)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    /* Check status */
++    spin_lock_irqsave(&priv->lock, flags);
++    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
++    {
++        spin_unlock_irqrestore(&priv->lock, flags);
++        result = -EBUSY;
++        goto end;
++    }
++    spin_unlock_irqrestore(&priv->lock, flags);
++    /* Copy arguments from user space to kernel space */
++    if (copy_from_user(&proc[0], (void __user *)arg, sizeof(proc)))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    /* Check Argument */
++    for (i = DRPAI_INDEX_DRP_DESC; i < DRPAI_INDEX_NUM; i++)
++    {
++        if (0 != (proc[i].address & DRPAI_64BYTE_ALIGN))
++        {
++            result = -EINVAL;
++            goto end;
++        }
++        if ((drpai_region_base_addr > proc[i].address) || 
++           ((drpai_region_base_addr + drpai_region_size) <= (proc[i].address + proc[i].size)))
++            {
++                result = -EINVAL;
++                goto end;
++            }
++    }
++
++    /* Check if input is in linux memory region */
++    if(0 == atomic_read(&drpai_rw_status->inout_flag))
++    {
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) Use arg variable\n", __func__, current->pid);
++        if(0 != drpai_flush_dcache_input_area(&proc[DRPAI_INDEX_INPUT]))
++        {
++            result = -EFAULT;
++            goto end;
++        }
++        /* Change input address to value specified by user app. */
++        if(0 != drp_param_change32(proc[DRPAI_INDEX_DRP_PARAM].address, 0, proc[DRPAI_INDEX_INPUT].address))
++        {
++            result = -EFAULT;
++            goto end;
++        }
++    }
++    
++    /* drp_desc.bin */
++    p_drp_desc = phys_to_virt(proc[DRPAI_INDEX_DRP_DESC].address);
++    if (p_drp_desc == 0)
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    /* Changed link descriptor of drp_desc.bin */
++    if (0 != (proc[DRPAI_INDEX_DRP_DESC].size & 0x0F))
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    iowrite8(0x08, p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13);
++    __flush_dcache_area(p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13, 1);
++
++    /* aimac_desc.bin */
++    p_aimac_desc = phys_to_virt(proc[DRPAI_INDEX_AIMAC_DESC].address);
++    if (p_aimac_desc == 0)
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    /* Changed link descriptor of drp_desc.bin */
++    if (0 != (proc[DRPAI_INDEX_AIMAC_DESC].size & 0x0F))
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    iowrite8(0x08, p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13);
++    __flush_dcache_area(p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13, 1);
++
++    spin_lock_irqsave(&priv->lock, flags);
++    /* Init drpai_status.err */
++    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
++    /* IDLE -> RUN */
++    priv->drpai_status.status = DRPAI_STATUS_RUN;
++    priv->aimac_irq_flag = 0;
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
++
++    /* Kick */
++    (void)R_DRPAI_DRP_Start(0, proc[DRPAI_INDEX_DRP_DESC].address);
++    (void)R_DRPAI_AIMAC_Start(0, proc[DRPAI_INDEX_AIMAC_DESC].address);
++
++    goto end;
++end:
++    if(-ETIMEDOUT != result)
++    {
++        up(&priv->sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    long result = 0;
++    struct drpai_priv *priv = drpai_priv;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++    unsigned long flags;
++/* ISP */
++    void (*finish_callback)(int);
++    spin_lock_irqsave(&priv->lock, flags);
++    finish_callback = drpai_priv->isp_finish_loc;
++    spin_unlock_irqrestore(&priv->lock, flags);
++/* ISP */
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++    {
++        result = -ETIMEDOUT;
++        goto end;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
++    {
++        result = -EIO;
++        goto end;
++    }
++    drpai_init_device(0);
++
++    /* Update internal state */
++    spin_lock_irqsave(&priv->lock, flags);
++    priv->drpai_status.err    = DRPAI_ERRINFO_RESET;
++    priv->drpai_status.status = DRPAI_STATUS_IDLE;
++
++    /* Wake up the process */
++    wake_up_interruptible( &drpai_waitq );
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++/* ISP */
++/* For reset ISP call back*/    
++    if(NULL != finish_callback)
++    {
++        /* ERROR No.: ERESTART*/
++        (*finish_callback)(-85);
++    }
++    spin_lock_irqsave(&priv->lock, flags);    
++    drpai_priv->isp_finish_loc = NULL;
++    spin_unlock_irqrestore(&priv->lock, flags);
++/* For reset ISP call back*/
++/* ISP */
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    result = 0;
++    goto end;
++end:
++    if(-ETIMEDOUT != result)
++    {
++        up(&priv->sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    long result = 0;
++    drpai_status_t local_drpai_status;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++    {
++        result = -ETIMEDOUT;
++        goto end;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    /* Check NULL */
++    if (NULL == arg)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    /* Get the internal state of DRP-AI */
++    spin_lock_irqsave(&priv->lock, flags);
++    (void)R_DRPAI_Status(0, &priv->drpai_status);
++
++    /* Copy arguments from kernel space to user space */
++    local_drpai_status = priv->drpai_status;
++    spin_unlock_irqrestore(&priv->lock, flags);
++    if (copy_to_user((void __user *)arg, &local_drpai_status, sizeof(drpai_status_t)))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++
++    /* Check status */
++    if (DRPAI_STATUS_RUN == local_drpai_status.status)
++    {
++        result = -EBUSY;
++        goto end;
++    }
++
++    /* Check DRP-AI H/W error */
++    if ((DRPAI_ERRINFO_DRP_ERR == local_drpai_status.err) || (DRPAI_ERRINFO_AIMAC_ERR == local_drpai_status.err))
++    {
++        result = -EIO;
++        goto end;
++    }
++
++    goto end;
++end:
++    if(-ETIMEDOUT != result)
++    {
++        up(&priv->sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return result;
++}
++
++static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    long result = 0;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++
++    if(unlikely(down_timeout(&rw_sem, MAX_SEM_TIMEOUT)))
++    {
++        result = -ETIMEDOUT;
++        goto end;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    /* Check of writing and reading completion of DRP-AI obj file */
++    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
++    {
++        result = -EACCES;
++        goto end;
++    }
++
++    /* Initialization of register dump processing variables */
++    drpai_rw_status->rw_status              = DRPAI_STATUS_DUMP_REG;
++    drpai_rw_status->read_count             = 0;
++    drpai_rw_status->drp_reg_offset_count   = 0;
++    drpai_rw_status->aimac_reg_offset_count = 0;
++
++    goto end;
++end:
++    if(-ETIMEDOUT != result)
++    {
++        up(&rw_sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    long result = 0;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++    drpai_assign_param_t drpai_assign_param_buf;
++    char *vbuf;
++
++    if(unlikely(down_trylock(&rw_sem)))
++    {
++        result = -ERESTART;
++        goto end;
++    }
++	/* Check NULL */
++    if (NULL == arg)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    /* Check status */
++    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
++    {
++        result = -EACCES;
++        goto end;
++    }
++    if(drpai_rw_status->param_info)
++    {
++        result = -EFAULT;
++        goto end;
++    }
++
++    /* Copy arguments from user space to kernel space */
++    if (copy_from_user(&drpai_assign_param_buf, (void __user *)arg, sizeof(drpai_assign_param_t)))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if(0 == drpai_assign_param_buf.obj.size)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    if ((drpai_region_base_addr > drpai_assign_param_buf.obj.address) || 
++        ((drpai_region_base_addr + drpai_region_size) <= (drpai_assign_param_buf.obj.address + drpai_assign_param_buf.obj.size)))
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    
++    /* Allocate memory for *_param_info.txt */
++    vbuf = vmalloc(drpai_assign_param_buf.info_size);
++    if(!vbuf){
++        result = -EFAULT;
++        goto end;
++    }
++
++    /* Initialization of read / write processing variables */
++    drpai_rw_status->rw_status    = DRPAI_STATUS_ASSIGN_PARAM;
++    drpai_rw_status->write_count  = 0;
++    drpai_rw_status->assign_param = drpai_assign_param_buf;
++    drpai_rw_status->param_info   = vbuf;
++
++end:
++    if(-ERESTART != result)
++    {
++        up(&rw_sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++/* Note: This function change line variable. so if you use, check your variables address */
++static int8_t get_param_attr(char *line, char *attr, unsigned long *rvalue)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int8_t result = 0;
++    char *ptr_stmp, *ptr_etmp;
++
++    ptr_stmp = strstr(line, attr);
++    ptr_stmp += strlen(attr);
++    ptr_etmp = strstr(line, ",");
++    *ptr_etmp = '\0';
++    if(0 != kstrtoul(ptr_stmp, 10, rvalue))
++    {
++        result = -1;
++        goto end;
++    }
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++static int8_t drp_param_change16(uint32_t base, uint32_t offset, uint16_t value)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    int8_t result = 0;
++    volatile void *virt_addr = 0;
++    virt_addr = phys_to_virt(base + offset);
++    if (0 == virt_addr)
++    {
++        result = -1;
++        goto end;
++    }
++    iowrite16(value, virt_addr);
++    __flush_dcache_area(virt_addr, sizeof(value));
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++static int8_t drp_param_change32(uint32_t base, uint32_t offset, uint32_t value)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int8_t result = 0;
++    volatile void *virt_addr = 0;
++    virt_addr = phys_to_virt(base + offset);
++    if (0 == virt_addr)
++    {
++        result = -1;
++        goto end;
++    }
++    iowrite32(value, virt_addr);
++    __flush_dcache_area(virt_addr, sizeof(value));
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++static int8_t drpai_flush_dcache_input_area(drpai_data_t *input)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    int8_t result = 0;
++    drpai_data_t proc = *input;
++    uint32_t flush_addr, flush_size;
++    uint32_t input_saddr, input_eaddr, linux_mem_saddr, linux_mem_eaddr;
++    volatile void *p_input = 0;
++
++    input_saddr      = proc.address;
++    input_eaddr      = proc.address + proc.size - 1;
++    linux_mem_saddr  = drpai_linux_mem_start;
++    linux_mem_eaddr  = drpai_linux_mem_start + drpai_linux_mem_size - 1;
++    if ((input_saddr >= linux_mem_saddr) && 
++        (input_eaddr <= linux_mem_eaddr))
++    {
++        flush_addr = proc.address;
++        flush_size = proc.size;
++    }
++    else if ((input_saddr >= linux_mem_saddr) &&
++             (input_saddr <= linux_mem_eaddr) &&
++             (input_eaddr >  linux_mem_eaddr))
++    {
++        flush_addr = proc.address;
++        flush_size = (drpai_linux_mem_start + drpai_linux_mem_size) - proc.address;
++    }
++    else if((input_eaddr >= linux_mem_saddr) &&
++            (input_eaddr <= linux_mem_eaddr) &&
++            (input_saddr <  linux_mem_saddr))
++    {
++        flush_addr = drpai_linux_mem_start;
++        flush_size = (proc.address + proc.size) - drpai_linux_mem_start;
++    }
++    else
++    {
++        flush_addr = 0;
++        flush_size = 0;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) flush_addr = 0x%08X, flush_size = 0x%08X\n", __func__, current->pid, flush_addr, flush_size);
++    if (0 != flush_size)
++    {
++        /* Input data area cache flush */
++        p_input = phys_to_virt(flush_addr);
++        if (0 == p_input)
++        {
++            result = -1;
++            goto end;
++        }
++        __flush_dcache_area(p_input, flush_size);
++    }
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    long result = 0;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++    drpai_crop_t crop_param_buf;
++    char buf[DRP_PARAM_MAX_LINE_LENGTH];
++    char *ptr, *prev_ptr;
++    unsigned long offset_add0, offset_add1;
++    int mode = 0;
++
++    /* Check the internal state of DRP-AI */
++    spin_lock_irqsave(&priv->lock, flags);
++    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
++    {
++        spin_unlock_irqrestore(&priv->lock, flags);
++        result = -EBUSY;
++        goto end;
++    }
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    if(unlikely(down_trylock(&rw_sem)))
++    {
++        result = -ERESTART;
++        goto end;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    /* Check NULL */
++    if (NULL == arg)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    if((NULL == drpai_rw_status->param_info) ||
++       (DRPAI_STATUS_ASSIGN_PARAM == drpai_rw_status->rw_status) ||
++       (DRPAI_STATUS_WRITE_PARAM  == drpai_rw_status->rw_status))
++    {
++        result = -EACCES;
++        goto end;
++    }
++    /* Copy arguments from user space to kernel space */
++    if (copy_from_user(&crop_param_buf, (void __user *)arg, sizeof(drpai_crop_t)))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    /* Check if there is in drpai dedicated area */
++    if((drpai_rw_status->assign_param.obj.address != crop_param_buf.obj.address) ||
++       (drpai_rw_status->assign_param.obj.size != crop_param_buf.obj.size))
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    /* Search argument */
++    ptr = drpai_rw_status->param_info;
++    do
++    {
++        /* Save current pointer */
++        prev_ptr = ptr;
++
++        /* Get 1 line */
++        ptr = strchr(ptr, '\n');
++        if(NULL == ptr) {
++            result = -EFAULT;
++            goto end;
++        }
++        ptr += 1;
++        if(ptr - prev_ptr >= DRP_PARAM_MAX_LINE_LENGTH)
++        {
++            result = -EFAULT;
++            goto end;
++        }
++
++        /* Copy only 1line to buffer */
++        memset(buf, 0, sizeof(buf));
++        strncpy(buf, prev_ptr, ptr - prev_ptr);
++
++        if(0 == mode)
++        {
++            /* Check if there is DRP_LIB_NAME_CROP in this line */
++            if(NULL != strstr(buf, DRP_LIB_NAME_CROP))
++            {
++                mode += 1;
++                if(0 != get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add0))
++                {
++                    result = -EFAULT;
++                    goto end;
++                }
++            }
++        }
++        else if(1 == mode)
++        {
++            if(NULL != strstr(buf, DRP_PARAM_ATTR_OFFSET_ADD))
++            {
++                mode += 1;
++                if(0 != get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add1))
++                {
++                    result = -EFAULT;
++                    goto end;
++                }
++                break;
++            }
++        }
++    } while (ptr);
++
++    DRPAI_DEBUG_PRINT("[%s](pid %d) offset_add0=%d, offset_add1=%d\n", __func__, current->pid, offset_add0, offset_add1);
++
++    /* Change parameters of drp_param.bin to value specified by user app. */
++    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_IMG_OWIDTH, crop_param_buf.img_owidth))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_IMG_OHEIGHT, crop_param_buf.img_oheight))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_CROP_POS_X, crop_param_buf.pos_x))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_CROP_POS_Y, crop_param_buf.pos_y))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add1 + DRP_PARAM_IMG_IWIDTH, crop_param_buf.img_owidth))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add1 + DRP_PARAM_IMG_IHEIGHT, crop_param_buf.img_oheight))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++
++    goto end;
++end:
++    if((-EBUSY != result) || (-ERESTART != result))
++    {
++        up(&rw_sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    long result = 0;
++    struct drpai_priv *priv = drpai_priv;
++    struct drpai_rw_status *drpai_rw_status = filp->private_data;
++    drpai_inout_t inout_param_buf;
++    char buf[DRP_PARAM_MAX_LINE_LENGTH];
++    char *ptr, *prev_ptr;
++    unsigned long flags;
++    unsigned long offset_add;
++
++    /* Check the internal state of DRP-AI */
++    spin_lock_irqsave(&priv->lock, flags);
++    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
++    {
++        spin_unlock_irqrestore(&priv->lock, flags);
++        result = -EBUSY;
++        goto end;
++    }
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    if(unlikely(down_trylock(&rw_sem)))
++    {
++        result = -ERESTART;
++        goto end;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++
++    /* Check NULL */
++    if (NULL == arg)
++    {
++        result = -EINVAL;
++        goto end;
++    }
++    if((NULL == drpai_rw_status->param_info) ||
++       (DRPAI_STATUS_ASSIGN_PARAM == drpai_rw_status->rw_status) ||
++       (DRPAI_STATUS_WRITE_PARAM  == drpai_rw_status->rw_status))
++    {
++        result = -EACCES;
++        goto end;
++    }
++    /* Copy arguments from user space to kernel space */
++    if (copy_from_user(&inout_param_buf, (void __user *)arg, sizeof(drpai_inout_t)))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    /* Check if there is in drpai dedicated area */
++    if((drpai_rw_status->assign_param.obj.address != inout_param_buf.obj.address) ||
++       (drpai_rw_status->assign_param.obj.size != inout_param_buf.obj.size))
++    {
++        result = -EINVAL;
++        goto end;
++    }
++
++    /* Search argument */
++    ptr = drpai_rw_status->param_info;
++    do
++    {
++        /* Save current pointer */
++        prev_ptr = ptr;
++
++        /* Get 1 line */
++        ptr = strchr(ptr, '\n');
++        if(NULL == ptr) {
++            result = -EFAULT;
++            goto end;
++        }
++        ptr += 1;
++        if(ptr - prev_ptr >= DRP_PARAM_MAX_LINE_LENGTH)
++        {
++            result = -EFAULT;
++            goto end;
++        }
++
++        /* Copy only 1line to buffer */
++        memset(buf, 0, sizeof(buf));
++        strncpy(buf, prev_ptr, ptr - prev_ptr);
++
++        /* Check if there is DRP_PARAM_ATTR_PROP_INPUT in this line */
++        if(NULL != strstr(buf, DRP_PARAM_ATTR_PROP_INPUT))
++        {
++            if(NULL != strstr(buf, inout_param_buf.name))
++            {
++                if(0 != get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add))
++                {
++                    result = -EFAULT;
++                    goto end;
++                }
++                break;
++            }
++        }
++    } while (ptr);
++
++    DRPAI_DEBUG_PRINT("[%s](pid %d) offset_add=%d\n", __func__, current->pid, offset_add);
++
++    /* Check if input is in linux memory region */
++    if(0 != drpai_flush_dcache_input_area(&inout_param_buf.data))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    /* Change parameters of drp_param.bin to value specified by user app. */
++    if(0 != drp_param_change32(inout_param_buf.obj.address, offset_add + DRP_PARAM_raddr, inout_param_buf.data.address))
++    {
++        result = -EFAULT;
++        goto end;
++    }
++    atomic_set(&drpai_rw_status->inout_flag, 1);
++
++    goto end;
++end:
++    if((-EBUSY != result) || (-ERESTART != result))
++    {
++        up(&rw_sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++static int drpai_drp_cpg_init(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int result;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++    int r_data;
++    int32_t i = 0;
++    bool is_stop = false;
++
++    /* Access clock interface */
++    clk_prepare_enable(priv->clk_int);
++    clk_prepare_enable(priv->clk_aclk_drp);
++    clk_prepare_enable(priv->clk_mclk);
++    clk_prepare_enable(priv->clk_dclkin);
++    clk_prepare_enable(priv->clk_aclk);
++
++    r_data = reset_control_status(priv->rstc);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) drp reset_control_status before %d \n", __func__, current->pid, r_data);
++    
++    /* Access reset controller interface */
++    reset_control_reset(priv->rstc);
++
++    /* Check reset status */
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        udelay(1);
++        i++;
++        r_data = reset_control_status(priv->rstc);
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) drp reset_control_status %d \n", __func__, current->pid, r_data);
++        if(1 == r_data)
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    i = 0;
++    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
++    {
++        usleep_range(100, 200);
++        i++;
++        r_data = reset_control_status(priv->rstc);
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) drp reset_control_status %d \n", __func__, current->pid, r_data);
++        if(1 == r_data)
++        {
++            is_stop = true;
++            break;
++        }
++    }
++
++    if(true == is_stop)
++    {
++        result =  R_DRPAI_SUCCESS;
++    }
++    else
++    {
++        result = R_DRPAI_ERR_RESET;
++        DRPAI_DEBUG_PRINT(KERN_INFO "%s: CPG Reset failed. Reset Control Status: %d\n", __func__,  r_data);
++    }
++
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++/* ISP */
++static int drpai_drp_config_init(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int result;
++    struct drpai_priv *priv = drpai_priv;
++    struct device *dev = &priv->pdev->dev;
++    int i;
++
++    /* Get driver workspace from Linux CMA */
++    p_dmabuf_vaddr = dma_alloc_coherent(dev, DRPAI_CMA_SIZE, &p_dmabuf_phyaddr, GFP_DMA);
++    if (NULL == p_dmabuf_vaddr)
++    {
++        /* Error -ENOMEM */
++        result = -1;
++        goto end;
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) dmabuf:0x%08X, dmaphys:0x%08X\n", __func__, current->pid, p_dmabuf_vaddr, p_dmabuf_phyaddr);
++
++    /* 64bytes alignment adjustment */
++    if (0 != (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN))
++    {
++        p_dmabuf_vaddr = p_dmabuf_vaddr + (0x40 - (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN));
++        p_dmabuf_phyaddr = p_dmabuf_phyaddr + (0x40 - (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN));
++    }
++
++    /* Deploy drp_single_desc */
++    memcpy(p_dmabuf_vaddr, &drp_single_desc_bin[0], sizeof(drp_single_desc_bin));
++
++    __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
++
++    result = R_DRPAI_SUCCESS;
++
++    goto end;
++end:
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++static void drpai_drp_config_uninit(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    struct drpai_priv *priv = drpai_priv;
++    struct device *dev = &priv->pdev->dev;
++
++    dma_free_coherent(dev, DRPAI_CMA_SIZE, p_dmabuf_vaddr, p_dmabuf_phyaddr);
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++}
++
++int drpai_open_k(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++    
++    int result = 0;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++    
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++    {
++        result = -ETIMEDOUT;
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ETIMEDOUT.\n", __func__, current->pid);
++        goto end;
++    }  
++
++    if(drpai_drp_config_init())
++    {
++        result = -ENOMEM;
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ENOMEM.\n", __func__, current->pid);
++        goto end;
++    }
++
++    if(likely(1 == refcount_read(&priv->count)))
++    {
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) Initialize DRP-AI\n", __func__, current->pid);
++
++        /* CPG Reset */
++        if(drpai_drp_cpg_init())
++        {
++            result = -EIO;
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) DRP CPG HW error EIO.\n", __func__, current->pid);
++            goto end;
++        }
++
++        /* Initialize DRP-AI */
++        drpai_init_device(0);
++
++        /* Reset DRP-AI */
++        if(R_DRPAI_SUCCESS != drpai_reset_device(0))
++        {
++            result = -EIO;
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) DRP HW error EIO.\n", __func__, current->pid);
++            goto end;
++        }
++
++        /* Initialize DRP-AI */
++        drpai_init_device(0);
++
++        /* INIT -> IDLE */
++        spin_lock_irqsave(&priv->lock, flags);
++        priv->drpai_status.status = DRPAI_STATUS_IDLE;
++        spin_unlock_irqrestore(&priv->lock, flags);
++    }
++
++    /* Increment reference count */
++    refcount_inc(&priv->count);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
++    goto end;
++end:
++    if(-ETIMEDOUT != result)
++    {
++        /* Return semaphore when no ETIMEOUT */
++        up(&priv->sem);
++    }
++    if(-EIO == result)
++    {
++        /* Release Linux CMA when hardware error */
++        drpai_drp_config_uninit();
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++int drpai_close_k(void)
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int result = 0;
++    struct drpai_priv *priv = drpai_priv;
++    unsigned long flags;
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++    {
++        result = -ETIMEDOUT;
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ETIMEOUT.\n", __func__, current->pid);
++        goto end;
++    } 
++
++    /* Check status */
++    spin_lock_irqsave(&priv->lock, flags);
++    if (DRPAI_STATUS_INIT == priv->drpai_status.status)
++    {
++        spin_unlock_irqrestore(&priv->lock, flags);
++        result = -EACCES;        
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EACCES.\n", __func__, current->pid);
++        goto end;
++    }
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    if(2 == refcount_read(&priv->count))
++    {
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start DRP-AI reset\n", __func__, current->pid);
++        if(R_DRPAI_SUCCESS != drpai_reset_device(0))
++        {
++            result = -EIO;              
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EIO.\n", __func__, current->pid);
++            goto end;
++        }
++
++        // CPG clock disable
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) CPG clock disable\n", __func__, current->pid);
++        clk_disable_unprepare(priv->clk_int);
++        clk_disable_unprepare(priv->clk_aclk_drp);
++        clk_disable_unprepare(priv->clk_mclk);
++        clk_disable_unprepare(priv->clk_dclkin);
++        clk_disable_unprepare(priv->clk_aclk);  
++
++        /* IDLE -> INIT */
++        /* RUN  -> INIT */
++        spin_lock_irqsave(&priv->lock, flags);
++        priv->drpai_status.status = DRPAI_STATUS_INIT;
++        priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
++        spin_unlock_irqrestore(&priv->lock, flags);
++
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) done DRP-AI reset\n", __func__, current->pid);
++    }
++    /* Release Linux CMA */
++    drpai_drp_config_uninit();
++
++    /* Decrement referenece count*/
++    refcount_dec(&priv->count);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
++
++    goto end;
++end:
++    if(-ETIMEDOUT != result)
++    {
++        /* Return semaphore when no ETIMEOUT */
++        up(&priv->sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++
++    return result;
++}
++
++int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
++{
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
++
++    int result = 0;
++    int wait_ret = 0;
++    volatile void *p_drp_param = 0;
++    volatile void *p_input = 0;
++    volatile void *p_drpcfg = 0;
++    volatile void *p_weight = 0;
++    struct drpai_priv *priv = drpai_priv;
++    drpai_data_t *proc_k;
++    unsigned long flags;
++    int i;
++
++    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
++    {
++        result = -ETIMEDOUT;
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ETIMEOUT.\n", __func__, current->pid);
++        goto end;
++    }
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
++
++    /* Check H/W Error */
++    spin_lock_irqsave(&priv->lock, flags);
++    if ((DRPAI_ERRINFO_DRP_ERR == priv->drpai_status.err) || (DRPAI_ERRINFO_AIMAC_ERR == priv->drpai_status.err))
++    {
++        spin_unlock_irqrestore(&priv->lock, flags);
++        result = -EIO;   
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EIO.\n", __func__, current->pid);
++        goto end;
++    }
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    /* Check status */
++    spin_lock_irqsave(&priv->lock, flags);
++    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
++    {
++        spin_unlock_irqrestore(&priv->lock, flags);
++        result = -EBUSY;   
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EBUSY.\n", __func__, current->pid);
++        goto end;
++    }
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    /* Check status */
++    spin_lock_irqsave(&priv->lock, flags);
++    if (DRPAI_STATUS_INIT == priv->drpai_status.status)
++    {
++        spin_unlock_irqrestore(&priv->lock, flags);
++        result = -EACCES;   
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EACCES.\n", __func__, current->pid);
++        goto end;
++    }
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    /* Check NULL */
++    if (NULL == isp_finish)
++    {
++        result = -EINVAL; 
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EINVAL NULL function pointer.\n", __func__, current->pid);
++        goto end;
++    }
++    /* Referring the call back function info from ISP Lib */
++    priv->isp_finish_loc = isp_finish;  
++
++    /* Check NULL */
++    if (NULL == arg)
++    {
++        result = -EINVAL; 
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EINVAL NULL argument pointer.\n", __func__, current->pid);
++        goto end;
++    }
++    /* Referring the obj file info from ISP Lib */
++    proc_k = arg;
++
++    spin_lock_irqsave(&priv->lock, flags);
++    odif_intcnto.ch0 = 0;
++    odif_intcnto.ch1 = 0;
++    odif_intcnto.ch2 = 0;
++    odif_intcnto.ch3 = 0;
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
++    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
++
++    /* Check Argument 64-byte*/
++    for (i = 0; i < 2; i++)
++    {
++        if (0 != (proc_k[i].address & DRPAI_64BYTE_ALIGN))
++        {
++            result = -EINVAL; 
++            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EINVAL argument. Not 64-byte aligned.\n", __func__, current->pid);
++            goto end;
++        }
++    }
++
++    for (i = 0; i < 1; i++)
++    {
++        /* DRPcfg address and size settings */
++        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 4) = proc_k[i * 2].address;
++        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 8) = proc_k[i * 2].size;
++
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) cfg_address:0x%08X, cfg_size:0x%08X\n", __func__, current->pid, proc_k[i * 2].address, proc_k[i * 2].size);
++
++        /* DRP param address and size settings */
++        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 36) = proc_k[i * 2 + 1].address;
++        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 40) = proc_k[i * 2 + 1].size;
++
++        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) parm_address:0x%08X, parm_size:0x%08X\n", __func__, current->pid, proc_k[i * 2 + 1].address, proc_k[i * 2 + 1].size);
++
++    }
++    __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
++
++    spin_lock_irqsave(&priv->lock, flags);
++    /* Init drpai_status.err */
++    priv->drpai_status.err = DRPAI_ERRINFO_SUCCESS;
++
++    /* IDLE -> RUN */
++    priv->drpai_status.status = DRPAI_STATUS_RUN;
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
++    spin_unlock_irqrestore(&priv->lock, flags);
++
++    /* Kick */
++    (void)R_DRPAI_DRP_Start(0, p_dmabuf_phyaddr);
++    (void)R_DRPAI_AIMAC_Start(0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE));
++
++    goto end;
++end:
++    if(-ETIMEDOUT != result)
++    {
++        /* Return semaphore when no ETIMEOUT */
++        up(&priv->sem);
++    }
++    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
++    
++    return result;
++}
++
++/* Public to Kernel space */
++EXPORT_SYMBOL(drpai_open_k);
++EXPORT_SYMBOL(drpai_close_k);
++EXPORT_SYMBOL(drpai_start_k);
++/* ISP */
++
++module_platform_driver(drpai_platform_driver);
++MODULE_DEVICE_TABLE(of, drpai_match);
++MODULE_DESCRIPTION("RZ/V2L DRP-AI driver");
++MODULE_AUTHOR("Renesas Electronics Corporation");
++MODULE_LICENSE("GPL v2");
++
+diff --git a/drivers/drpai/drpai-reg.h b/drivers/drpai/drpai-reg.h
+new file mode 100644
+index 000000000000..82a6c2b373f0
+--- /dev/null
++++ b/drivers/drpai/drpai-reg.h
+@@ -0,0 +1,275 @@
++/*
++ * Driver for the Renesas RZ/V2L DRP-AI unit
++ *
++ * Copyright (C) 2021 Renesas Electronics Corporation
++ *
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifndef R_DRPAI_REG_H
++#define R_DRPAI_REG_H
++
++/*--------------------------------------------------------------------------------------------------
++  DRP Initialization register
++--------------------------------------------------------------------------------------------------*/
++/* Clock */
++#define STPC_CLKGEN_CTRL                (0x81D930)
++#define STPC_CLKGEN_RST                 (0x81D840)
++#define STPC_CLKGEN_STBYWAIT            (0x81D860)
++#define STPC_CLKGEN_DIV                 (0x81D848)
++#define STPC_CLKE                       (0x81D810)
++/* Soft reset */
++#define STPC_SFTRST                     (0x81D800)
++/* DMAC */
++#define IDIF_DMACTLCW                   (0x819900)
++#define IDIF_DMACTLI0                   (0x819100)
++#define IDIF_DMACTLI1                   (0x819200)
++#define IDIF_DMACTLI2                   (0x819300)
++#define IDIF_DMACTLI3                   (0x819400)
++#define ODIF_DMACTLO0                   (0x81A100)
++#define ODIF_DMACTLO1                   (0x81A200)
++#define ODIF_DMACTLO2                   (0x81A300)
++#define ODIF_DMACTLO3                   (0x81A400)
++#define ODIF_DMACTLCR                   (0x81A900)
++/* ISP */
++/* Normal Interrupt mask */
++#define ODIF_INTMSK                     (0x81A004)
++/* ISP */
++/* Err Interrupt mask */
++#define IDIF_EINTMSK                    (0x81900C)
++#define IDIF_EINTMSK_DSC                (0x819014)
++#define ODIF_EINTMSK                    (0x81A00C)
++#define IDMAC_INTME                     (0x81B024)
++#define ODMAC_INTME                     (0x81C024)
++#define RAC_EINTM                       (0x81D008)
++/*--------------------------------------------------------------------------------------------------
++  DRP boot sequence register
++--------------------------------------------------------------------------------------------------*/
++#define DSCC_DPA                        (0x818108)
++#define DSCC_DCTL                       (0x818100)
++/* ISP */
++/*--------------------------------------------------------------------------------------------------
++  DPP NMLINT register
++--------------------------------------------------------------------------------------------------*/
++#define ODIF_INT                        (0x81A000)
++#define ODIF_INTCNTO0                   (0x81A118)
++#define ODIF_INTCNTO1                   (0x81A218)
++#define ODIF_INTCNTO2                   (0x81A318)
++#define ODIF_INTCNTO3                   (0x81A418)
++/* ISP */
++/*--------------------------------------------------------------------------------------------------
++  DRP ERRINT register
++--------------------------------------------------------------------------------------------------*/
++#define STPC_ERRINT_STS                 (0x81D808)
++#define DRP_ERRINTSTATUS                (0x3B0048)
++#define IDIF_EINT                       (0x819008)
++#define IDIF_EINT_DSC                   (0x819010)
++#define ODIF_EINT                       (0x81A008)
++#define IDMAC_INTSE                     (0x81B020)
++#define ODMAC_INTSE                     (0x81C020)
++#define RAC_EINTS                       (0x81D004)
++/*--------------------------------------------------------------------------------------------------
++  AI-MAC Initialization register
++--------------------------------------------------------------------------------------------------*/
++/* Clock */
++#define EXD0_STPC_CLKGEN_CTRL           (0x01D930)
++#define EXD0_STPC_CLKGEN_RST            (0x01D840)
++#define EXD0_STPC_CLKGEN_STBYWAIT       (0x01D860)
++#define EXD0_STPC_CLKGEN_DIV            (0x01D848)
++#define EXD0_STPC_CLKE                  (0x01D810)
++#define EXD1_STPC_CLKE                  (0x05D810)
++#define CLKRSTCON_CLKE                  (0x141808)
++/* Soft reset */
++#define EXD0_STPC_SFTRST                (0x01D800)
++#define EXD1_STPC_SFTRST                (0x05D800)
++#define CLKRSTCON_SFTRST                (0x141800)
++/* DMAC */
++#define EXD0_IDIF_DMACTLI0              (0x019100)
++#define EXD0_IDIF_DMACTLI1              (0x019200)
++#define EXD0_IDIF_DMACTLI2              (0x019300)
++#define EXD0_IDIF_DMACTLI3              (0x019400)
++#define EXD0_ODIF_DMACTLO0              (0x01A100)
++#define EXD0_ODIF_DMACTLO1              (0x01A200)
++#define EXD0_ODIF_DMACTLO2              (0x01A300)
++#define EXD0_ODIF_DMACTLO3              (0x01A400)
++#define EXD1_IDIF_DMACTLI0              (0x059100)
++#define EXD1_IDIF_DMACTLI1              (0x059200)
++#define EXD1_IDIF_DMACTLI2              (0x059300)
++#define EXD1_IDIF_DMACTLI3              (0x059400)
++#define EXD1_ODIF_DMACTLO0              (0x05A100)
++#define EXD1_ODIF_DMACTLO1              (0x05A200)
++#define EXD1_ODIF_DMACTLO2              (0x05A300)
++#define EXD1_ODIF_DMACTLO3              (0x05A400)
++/* Nml Interrupt mask */
++#define EXD1_ODIF_INTMSK                (0x05A004)
++/* Err Interrupt mask */
++#define AID_IDIF_EINTMSK                (0x11900C)
++#define AID_IDMAC_INTME                 (0x11B024)
++#define AIMRAC_EINTM                    (0x142008)
++#define CMDSEL_ERRMSK                   (0x140104)
++#define PRAM_INTMASK                    (0x200008)
++#define OSEL_DO_MSK0                    (0x180020)
++#define OSEL_DO_MSK1                    (0x180120)
++#define OSEL_DO_MSK2                    (0x180220)
++#define OSEL_DO_MSK3                    (0x180320)
++#define OSEL_DO_MSK4                    (0x180420)
++#define OSEL_DO_MSK5                    (0x180520)
++#define OSEL_DO_MSK6                    (0x180620)
++#define OSEL_DO_MSK7                    (0x180720)
++#define OSEL_DO_MSK8                    (0x180820)
++#define OSEL_DO_EN0                     (0x180010)
++#define OSEL_DO_EN1                     (0x180110)
++#define OSEL_DO_EN2                     (0x180210)
++#define OSEL_DO_EN3                     (0x180310)
++#define OSEL_DO_EN4                     (0x180410)
++#define OSEL_DO_EN5                     (0x180510)
++#define OSEL_DO_EN6                     (0x180610)
++#define OSEL_DO_EN7                     (0x180710)
++#define OSEL_DO_EN8                     (0x180810)
++#define MACTOP_ERR_MSK                  (0x1C000C)
++#define EXD0_IDIF_EINTMSK               (0x01900C)
++#define EXD1_IDIF_EINTMSK               (0x05900C)
++#define EXD0_ODIF_EINTMSK               (0x01A00C)
++#define EXD1_ODIF_EINTMSK               (0x05A00C)
++#define EXD0_IDMAC_INTME                (0x01B024)
++#define EXD1_IDMAC_INTME                (0x05B024)
++#define EXD0_ODMAC_INTME                (0x01C024)
++#define EXD1_ODMAC_INTME                (0x05C024)
++#define EXD0_RAC_EINTM                  (0x01D008)
++#define EXD1_RAC_EINTM                  (0x05D008)
++/*--------------------------------------------------------------------------------------------------
++  AI-MAC boot sequence register
++--------------------------------------------------------------------------------------------------*/
++#define AID_DSCC_DPA                    (0x118108)
++#define AID_DSCC_DCTL                   (0x118100)
++#define AID_IDIF_DMACTLI0               (0x119100)
++/*--------------------------------------------------------------------------------------------------
++  AI-MAC NMLINT register
++--------------------------------------------------------------------------------------------------*/
++#define EXD1_ODIF_INT                   (0x05A000)
++/*--------------------------------------------------------------------------------------------------
++  AI-MAC ERRINT register
++--------------------------------------------------------------------------------------------------*/
++#define INTMON_ERRINT                   (0x141008)
++#define AID_IDIF_EINT                   (0x119008)
++#define AID_IDMAC_INTSE                 (0x11B020)
++#define AIMRAC_EINTS                    (0x142004)
++#define CMDSEL_ERRSTS                   (0x140100)
++#define PRAM_INT                        (0x200000)
++#define OSEL_DO_ESTS0                   (0x180000)
++#define OSEL_DO_ESTS1                   (0x180100)
++#define OSEL_DO_ESTS2                   (0x180200)
++#define OSEL_DO_ESTS3                   (0x180300)
++#define OSEL_DO_ESTS4                   (0x180400)
++#define OSEL_DO_ESTS5                   (0x180500)
++#define OSEL_DO_ESTS6                   (0x180600)
++#define OSEL_DO_ESTS7                   (0x180700)
++#define OSEL_DO_ESTS8                   (0x180800)
++#define OSEL_AF_ESTS0                   (0x180004)
++#define OSEL_AF_ESTS1                   (0x180104)
++#define OSEL_AF_ESTS2                   (0x180204)
++#define OSEL_AF_ESTS3                   (0x180304)
++#define OSEL_AF_ESTS4                   (0x180404)
++#define OSEL_AF_ESTS5                   (0x180504)
++#define OSEL_AF_ESTS6                   (0x180604)
++#define OSEL_AF_ESTS7                   (0x180704)
++#define OSEL_AF_ESTS8                   (0x180804)
++#define OSEL_DO_FESTS0                  (0x181000)
++#define OSEL_DO_FESTS1                  (0x181100)
++#define OSEL_DO_FESTS2                  (0x181200)
++#define OSEL_DO_FESTS3                  (0x181300)
++#define OSEL_DO_FESTS4                  (0x181400)
++#define OSEL_DO_FESTS5                  (0x181500)
++#define OSEL_DO_FESTS6                  (0x181600)
++#define OSEL_DO_FESTS7                  (0x181700)
++#define OSEL_DO_FESTS8                  (0x181800)
++#define OSEL_AF_FESTS0                  (0x181004)
++#define OSEL_AF_FESTS1                  (0x181104)
++#define OSEL_AF_FESTS2                  (0x181204)
++#define OSEL_AF_FESTS3                  (0x181304)
++#define OSEL_AF_FESTS4                  (0x181404)
++#define OSEL_AF_FESTS5                  (0x181504)
++#define OSEL_AF_FESTS6                  (0x181604)
++#define OSEL_AF_FESTS7                  (0x181704)
++#define OSEL_AF_FESTS8                  (0x181804)
++#define MACTOP_ERR_STS                  (0x1C0008)
++#define MACCTL_FERR_STS                 (0x1C0800)
++#define EXD0_IDIF_EINT                  (0x019008)
++#define EXD1_IDIF_EINT                  (0x059008)
++#define EXD0_ODIF_EINT                  (0x01A008)
++#define EXD1_ODIF_EINT                  (0x05A008)
++#define EXD0_IDMAC_INTSE                (0x01B020)
++#define EXD1_IDMAC_INTSE                (0x05B020)
++#define EXD0_ODMAC_INTSE                (0x01C020)
++#define EXD1_ODMAC_INTSE                (0x05C020)
++#define EXD0_RAC_EINTS                  (0x01D004)
++#define EXD1_RAC_EINTS                  (0x05D004)
++/*--------------------------------------------------------------------------------------------------
++  AI-MAC Reset register
++--------------------------------------------------------------------------------------------------*/
++#define SYNCTBL_TBL0                    (0x140800)
++#define SYNCTBL_TBL1                    (0x140804)
++#define SYNCTBL_TBL2                    (0x140808)
++#define SYNCTBL_TBL3                    (0x14080C)
++#define SYNCTBL_TBL4                    (0x140810)
++#define SYNCTBL_TBL5                    (0x140814)
++#define SYNCTBL_TBL6                    (0x140818)
++#define SYNCTBL_TBL7                    (0x14081C)
++#define SYNCTBL_TBL8                    (0x140820)
++#define SYNCTBL_TBL9                    (0x140824)
++#define SYNCTBL_TBL10                   (0x140828)
++#define SYNCTBL_TBL11                   (0x14082C)
++#define SYNCTBL_TBL12                   (0x140830)
++#define SYNCTBL_TBL13                   (0x140834)
++#define SYNCTBL_TBL14                   (0x140838)
++#define SYNCTBL_TBL15                   (0x14083C)
++/*--------------------------------------------------------------------------------------------------
++  DRP-AI Internal state register
++--------------------------------------------------------------------------------------------------*/
++#define DSCC_PAMON                      (0x818118)
++#define AID_DSCC_PAMON                  (0x118118)
++/*--------------------------------------------------------------------------------------------------
++  Bit manipulation
++--------------------------------------------------------------------------------------------------*/
++#define DRPAI_BIT0                      (0x00000001u)
++#define DRPAI_BIT1                      (0x00000002u)
++#define DRPAI_BIT2                      (0x00000004u)
++#define DRPAI_BIT3                      (0x00000008u)
++#define DRPAI_BIT4                      (0x00000010u)
++#define DRPAI_BIT5                      (0x00000020u)
++#define DRPAI_BIT6                      (0x00000040u)
++#define DRPAI_BIT7                      (0x00000080u)
++#define DRPAI_BIT8                      (0x00000100u)
++#define DRPAI_BIT9                      (0x00000200u)
++#define DRPAI_BIT10                     (0x00000400u)
++#define DRPAI_BIT11                     (0x00000800u)
++#define DRPAI_BIT12                     (0x00001000u)
++#define DRPAI_BIT13                     (0x00002000u)
++#define DRPAI_BIT14                     (0x00004000u)
++#define DRPAI_BIT15                     (0x00008000u)
++#define DRPAI_BIT16                     (0x00010000u)
++#define DRPAI_BIT17                     (0x00020000u)
++#define DRPAI_BIT18                     (0x00040000u)
++#define DRPAI_BIT19                     (0x00080000u)
++#define DRPAI_BIT20                     (0x00100000u)
++#define DRPAI_BIT21                     (0x00200000u)
++#define DRPAI_BIT22                     (0x00400000u)
++#define DRPAI_BIT23                     (0x00800000u)
++#define DRPAI_BIT24                     (0x01000000u)
++#define DRPAI_BIT25                     (0x02000000u)
++#define DRPAI_BIT26                     (0x04000000u)
++#define DRPAI_BIT27                     (0x08000000u)
++#define DRPAI_BIT28                     (0x10000000u)
++#define DRPAI_BIT29                     (0x20000000u)
++#define DRPAI_BIT30                     (0x40000000u)
++#define DRPAI_BIT31                     (0x80000000u)
++
++#endif /* R_DRPAI_REG_H */
+diff --git a/drivers/media/i2c/ov5645.c b/drivers/media/i2c/ov5645.c
+index a6c17d15d754..75c18b577d73 100644
+--- a/drivers/media/i2c/ov5645.c
++++ b/drivers/media/i2c/ov5645.c
+@@ -61,6 +61,31 @@
+ #define OV5645_SDE_SAT_U		0x5583
+ #define OV5645_SDE_SAT_V		0x5584
+ 
++enum ov5645_frame_rate {
++	OV5645_15_FPS = 0,
++	OV5645_30_FPS,
++	OV5645_45_FPS,
++	OV5645_60_FPS,
++	OV5645_NUM_FRAMERATES,
++};
++
++static const int ov5645_framerates[] = {
++	[OV5645_15_FPS] = 15,
++	[OV5645_30_FPS] = 30,
++	[OV5645_45_FPS] = 45,
++	[OV5645_60_FPS] = 60,
++};
++
++struct ov5645_pixfmt {
++	u32 code;
++	u32 colorspace;
++};
++
++static const struct ov5645_pixfmt ov5645_formats[] = {
++	{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_SRGB, },
++};
++
++
+ /* regulator supplies */
+ static const char * const ov5645_supply_name[] = {
+ 	"vdddo", /* Digital I/O (1.8V) supply */
+@@ -82,6 +107,7 @@ struct ov5645_mode_info {
+ 	u32 data_size;
+ 	u32 pixel_clock;
+ 	u32 link_freq;
++	u32 max_fps;
+ };
+ 
+ struct ov5645 {
+@@ -97,6 +123,8 @@ struct ov5645 {
+ 	struct regulator_bulk_data supplies[OV5645_NUM_SUPPLIES];
+ 
+ 	const struct ov5645_mode_info *current_mode;
++	enum ov5645_frame_rate current_fr;
++	struct v4l2_fract frame_interval;
+ 
+ 	struct v4l2_ctrl_handler ctrls;
+ 	struct v4l2_ctrl *pixel_clock;
+@@ -112,6 +140,8 @@ struct ov5645 {
+ 
+ 	struct gpio_desc *enable_gpio;
+ 	struct gpio_desc *rst_gpio;
++
++	bool streaming;
+ };
+ 
+ static inline struct ov5645 *to_ov5645(struct v4l2_subdev *sd)
+@@ -361,6 +391,198 @@ static const struct reg_value ov5645_global_init_setting[] = {
+ 	{ OV5645_PAD_OUTPUT00, 0x70 }
+ };
+ 
++static const struct reg_value ov5645_setting_VGA_640_480[] = {
++	{ 0x3612, 0xa9 },
++	{ 0x3614, 0x50 },
++	{ 0x3618, 0x00 },
++	{ 0x3034, 0x18 },
++	{ 0x3035, 0x21 },
++	{ 0x3036, 0x70 },
++	{ 0x3600, 0x09 },
++	{ 0x3601, 0x43 },
++	{ 0x3708, 0x66 },
++	{ 0x370c, 0xc3 },
++	{ 0x3800, 0x02 },
++	{ 0x3801, 0x80 },
++	{ 0x3802, 0x01 },
++	{ 0x3803, 0xd4 },
++	{ 0x3804, 0x0a },
++	{ 0x3805, 0x3f },
++	{ 0x3806, 0x07 },
++	{ 0x3807, 0xeb },
++	{ 0x3808, 0x02 },
++	{ 0x3809, 0x80 },
++	{ 0x380a, 0x01 },
++	{ 0x380b, 0xe0 },
++	{ 0x380c, 0x07 },
++	{ 0x380d, 0x68 },
++	{ 0x380e, 0x03 },
++	{ 0x380f, 0xd8 },
++	{ 0x3813, 0x06 },
++	{ 0x3814, 0x31 },
++	{ 0x3815, 0x31 },
++	{ 0x3820, 0x41 },
++	{ 0x3a02, 0x03 },
++	{ 0x3a03, 0xd8 },
++	{ 0x3a08, 0x01 },
++	{ 0x3a09, 0xf8 },
++	{ 0x3a0a, 0x01 },
++	{ 0x3a0b, 0xa4 },
++	{ 0x3a0e, 0x02 },
++	{ 0x3a0d, 0x02 },
++	{ 0x3a14, 0x03 },
++	{ 0x3a15, 0xd8 },
++	{ 0x3a18, 0x00 },
++	{ 0x4004, 0x02 },
++	{ 0x4005, 0x18 },
++	{ 0x4300, 0x32 },
++	{ 0x4202, 0x00 }
++};
++
++static const struct reg_value ov5645_setting_30fps_NTSC_720_480[] = {
++	{ 0x3612, 0xa9 },
++	{ 0x3614, 0x50 },
++	{ 0x3618, 0x00 },
++	{ 0x3034, 0x18 },
++	{ 0x3035, 0x11 },
++	{ 0x3036, 0x54 },
++	{ 0x3600, 0x09 },
++	{ 0x3601, 0x43 },
++	{ 0x3708, 0x66 },
++	{ 0x370c, 0xc3 },
++	{ 0x3800, 0x00 },
++	{ 0x3801, 0x00 },
++	{ 0x3802, 0x00 },
++	{ 0x3803, 0x6c },
++	{ 0x3804, 0x0a },
++	{ 0x3805, 0x3f },
++	{ 0x3806, 0x07 },
++	{ 0x3807, 0x33 },
++	{ 0x3808, 0x02 },
++	{ 0x3809, 0xd0 },
++	{ 0x380a, 0x01 },
++	{ 0x380b, 0xe0 },
++	{ 0x380c, 0x07 },
++	{ 0x380d, 0x68 },
++	{ 0x380e, 0x03 },
++	{ 0x380f, 0xd8 },
++	{ 0x3813, 0x06 },
++	{ 0x3814, 0x31 },
++	{ 0x3815, 0x31 },
++	{ 0x3820, 0x41 },
++	{ 0x3a02, 0x03 },
++	{ 0x3a03, 0xd8 },
++	{ 0x3a08, 0x01 },
++	{ 0x3a09, 0xf8 },
++	{ 0x3a0a, 0x01 },
++	{ 0x3a0b, 0xa4 },
++	{ 0x3a0e, 0x02 },
++	{ 0x3a0d, 0x02 },
++	{ 0x3a14, 0x03 },
++	{ 0x3a15, 0xd8 },
++	{ 0x3a18, 0x00 },
++	{ 0x4004, 0x02 },
++	{ 0x4005, 0x18 },
++	{ 0x4300, 0x32 },
++	{ 0x4202, 0x00 }
++};
++
++static const struct reg_value ov5645_setting_720P_1280_720[] = {
++	{ 0x3612, 0xa9 },
++	{ 0x3614, 0x50 },
++	{ 0x3618, 0x00 },
++	{ 0x3034, 0x18 },
++	{ 0x3035, 0x11 },
++	{ 0x3036, 0x54 },
++	{ 0x3500, 0x00},
++	{ 0x3501, 0x01},
++	{ 0x3502, 0x00},
++	{ 0x350a, 0x00},
++	{ 0x350b, 0x3f},
++	{ 0x3600, 0x0a},
++	{ 0x3601, 0x75},
++	{ 0x3620, 0x33},
++	{ 0x3621, 0xe0},
++	{ 0x3622, 0x01},
++	{ 0x3630, 0x2d},
++	{ 0x3631, 0x00},
++	{ 0x3632, 0x32},
++	{ 0x3633, 0x52},
++	{ 0x3634, 0x70},
++	{ 0x3635, 0x13},
++	{ 0x3636, 0x03},
++	{ 0x3702, 0x6e},
++	{ 0x3703, 0x52},
++	{ 0x3704, 0xa0},
++	{ 0x3705, 0x33},
++	{ 0x3708, 0x66},
++	{ 0x3709, 0x12},
++	{ 0x370b, 0x61},
++	{ 0x370c, 0xc3},
++	{ 0x370f, 0x10},
++	{ 0x3715, 0x08},
++	{ 0x3717, 0x01},
++	{ 0x371b, 0x20},
++	{ 0x3731, 0x22},
++	{ 0x3739, 0x70},
++	{ 0x3901, 0x0a},
++	{ 0x3905, 0x02},
++	{ 0x3906, 0x10},
++	{ 0x3719, 0x86},
++	{ 0x3800, 0x00},
++	{ 0x3801, 0x00},
++	{ 0x3802, 0x00},
++	{ 0x3803, 0xfa},
++	{ 0x3804, 0x0a},
++	{ 0x3805, 0x3f},
++	{ 0x3806, 0x06},
++	{ 0x3807, 0xa9},
++	{ 0x3808, 0x05},
++	{ 0x3809, 0x00},
++	{ 0x380a, 0x02},
++	{ 0x380b, 0xd0},
++	{ 0x380c, 0x07},
++	{ 0x380d, 0x64},
++	{ 0x380e, 0x02},
++	{ 0x380f, 0xe4},
++	{ 0x3810, 0x00},
++	{ 0x3811, 0x10},
++	{ 0x3812, 0x00},
++	{ 0x3813, 0x04},
++	{ 0x3814, 0x31},
++	{ 0x3815, 0x31},
++	{ 0x3820, 0x41},
++	{ 0x3821, 0x07},
++	{ 0x3824, 0x01},
++	{ 0x3826, 0x03},
++	{ 0x3828, 0x08},
++	{ 0x3a02, 0x02},
++	{ 0x3a03, 0xe4},
++	{ 0x3a08, 0x01},
++	{ 0x3a09, 0xbc},
++	{ 0x3a0a, 0x01},
++	{ 0x3a0b, 0x72},
++	{ 0x3a0e, 0x01},
++	{ 0x3a0d, 0x02},
++	{ 0x3a14, 0x02},
++	{ 0x3a15, 0xe4},
++	{ 0x3a18, 0x00},
++	{ 0x3a19, 0xf8},
++	{ 0x3c01, 0x34},
++	{ 0x3c04, 0x28},
++	{ 0x3c05, 0x98},
++	{ 0x3c07, 0x07},
++	{ 0x3c09, 0xc2},
++	{ 0x3c0a, 0x9c},
++	{ 0x3c0b, 0x40},
++	{ 0x3c01, 0x34},
++	{ 0x4004, 0x02 },
++	{ 0x4005, 0x18 },
++	{ 0x4300, 0x32 },
++	{ 0x4202, 0x00 }
++
++};
++
+ static const struct reg_value ov5645_setting_sxga[] = {
+ 	{ 0x3612, 0xa9 },
+ 	{ 0x3614, 0x50 },
+@@ -515,13 +737,41 @@ static const s64 link_freq[] = {
+ };
+ 
+ static const struct ov5645_mode_info ov5645_mode_info_data[] = {
++	{
++		.width = 640,
++		.height = 480,
++		.data = ov5645_setting_VGA_640_480,
++		.data_size = ARRAY_SIZE(ov5645_setting_VGA_640_480),
++		.pixel_clock = 112000000,
++		.link_freq = 0, /* an index in link_freq[] */
++		.max_fps = OV5645_30_FPS
++	},
++	{
++		.width = 720,
++		.height = 480,
++		.data = ov5645_setting_30fps_NTSC_720_480,
++		.data_size = ARRAY_SIZE(ov5645_setting_30fps_NTSC_720_480),
++		.pixel_clock = 112000000,
++		.link_freq = 0, /* an index in link_freq[] */
++		.max_fps = OV5645_45_FPS
++	},
++	{
++		.width = 1280,
++		.height = 720,
++		.data = ov5645_setting_720P_1280_720,
++		.data_size = ARRAY_SIZE(ov5645_setting_720P_1280_720),
++		.pixel_clock = 112000000,
++		.link_freq = 0, /* an index in link_freq[] */
++		.max_fps = OV5645_60_FPS
++	},
+ 	{
+ 		.width = 1280,
+ 		.height = 960,
+ 		.data = ov5645_setting_sxga,
+ 		.data_size = ARRAY_SIZE(ov5645_setting_sxga),
+ 		.pixel_clock = 112000000,
+-		.link_freq = 0 /* an index in link_freq[] */
++		.link_freq = 0, /* an index in link_freq[] */
++		.max_fps = OV5645_30_FPS
+ 	},
+ 	{
+ 		.width = 1920,
+@@ -529,7 +779,8 @@ static const struct ov5645_mode_info ov5645_mode_info_data[] = {
+ 		.data = ov5645_setting_1080p,
+ 		.data_size = ARRAY_SIZE(ov5645_setting_1080p),
+ 		.pixel_clock = 168000000,
+-		.link_freq = 1 /* an index in link_freq[] */
++		.link_freq = 1, /* an index in link_freq[] */
++		.max_fps = OV5645_30_FPS
+ 	},
+ 	{
+ 		.width = 2592,
+@@ -537,7 +788,8 @@ static const struct ov5645_mode_info ov5645_mode_info_data[] = {
+ 		.data = ov5645_setting_full,
+ 		.data_size = ARRAY_SIZE(ov5645_setting_full),
+ 		.pixel_clock = 168000000,
+-		.link_freq = 1 /* an index in link_freq[] */
++		.link_freq = 1, /* an index in link_freq[] */
++		.max_fps = OV5645_15_FPS
+ 	},
+ };
+ 
+@@ -585,6 +837,27 @@ static int ov5645_read_reg(struct ov5645 *ov5645, u16 reg, u8 *val)
+ 	return 0;
+ }
+ 
++static const struct ov5645_mode_info *
++ov5645_find_mode(struct ov5645 *sensor, enum ov5645_frame_rate fr,
++		 int width, int height, bool nearest)
++{
++	const struct ov5645_mode_info *mode;
++
++	mode = v4l2_find_nearest_size(ov5645_mode_info_data,
++			       ARRAY_SIZE(ov5645_mode_info_data),
++			       width, height,
++			       width, height);
++	if (!mode ||
++	    (!nearest && (mode->width != width || mode->height != height)))
++		return NULL;
++
++	/* Check to see if the current mode exceeds the max frame rate */
++	if (ov5645_framerates[fr] > ov5645_framerates[mode->max_fps])
++		return NULL;
++
++	return mode;
++}
++
+ static int ov5645_set_aec_mode(struct ov5645 *ov5645, u32 mode)
+ {
+ 	u8 val = ov5645->aec_pk_manual;
+@@ -712,6 +985,49 @@ static int ov5645_s_power(struct v4l2_subdev *sd, int on)
+ 	return ret;
+ }
+ 
++static int ov5645_try_frame_interval(struct ov5645 *sensor,
++				     struct v4l2_fract *fi,
++				     u32 width, u32 height)
++{
++	const struct ov5645_mode_info *mode;
++	enum ov5645_frame_rate rate = OV5645_15_FPS;
++	int minfps, maxfps, best_fps, fps;
++	int i;
++
++	minfps = ov5645_framerates[OV5645_15_FPS];
++	maxfps = ov5645_framerates[OV5645_60_FPS];
++
++	if (fi->numerator == 0) {
++		fi->denominator = maxfps;
++		fi->numerator = 1;
++		rate = OV5645_60_FPS;
++		goto find_mode;
++	}
++
++	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
++			minfps, maxfps);
++
++	best_fps = minfps;
++	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
++			minfps, maxfps);
++
++	for (i = 0; i < ARRAY_SIZE(ov5645_framerates); i++) {
++		int curr_fps = ov5645_framerates[i];
++
++		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
++			best_fps = curr_fps;
++			rate = i;
++		}
++	}
++
++	fi->numerator = 1;
++	fi->denominator = best_fps;
++
++find_mode:
++	mode = ov5645_find_mode(sensor, rate, width, height, false);
++	return mode ? rate : -EINVAL;
++}
++
+ static int ov5645_set_saturation(struct ov5645 *ov5645, s32 value)
+ {
+ 	u32 reg_value = (value * 0x10) + 0x40;
+@@ -866,6 +1182,86 @@ static int ov5645_enum_frame_size(struct v4l2_subdev *subdev,
+ 	return 0;
+ }
+ 
++static int ov5645_enum_frame_interval(
++	struct v4l2_subdev *sd,
++	struct v4l2_subdev_pad_config *cfg,
++	struct v4l2_subdev_frame_interval_enum *fie)
++{
++	struct ov5645 *sensor = to_ov5645(sd);
++	struct v4l2_fract tpf;
++	int ret;
++
++	if (fie->pad != 0)
++		return -EINVAL;
++	if (fie->index >= OV5645_NUM_FRAMERATES)
++		return -EINVAL;
++
++	tpf.numerator = 1;
++	tpf.denominator = ov5645_framerates[fie->index];
++
++	ret = ov5645_try_frame_interval(sensor, &tpf,
++					fie->width, fie->height);
++	if (ret < 0)
++		return -EINVAL;
++
++	fie->interval = tpf;
++	return 0;
++}
++
++static int ov5645_g_frame_interval(struct v4l2_subdev *sd,
++				   struct v4l2_subdev_frame_interval *fi)
++{
++	struct ov5645 *sensor = to_ov5645(sd);
++
++	mutex_lock(&sensor->power_lock);
++	fi->interval = sensor->frame_interval;
++	mutex_unlock(&sensor->power_lock);
++
++	return 0;
++}
++
++static int ov5645_s_frame_interval(struct v4l2_subdev *sd,
++				   struct v4l2_subdev_frame_interval *fi)
++{
++	struct ov5645 *sensor = to_ov5645(sd);
++	const struct ov5645_mode_info *mode;
++	int frame_rate, ret = 0;
++
++	if (fi->pad != 0)
++		return -EINVAL;
++
++	mutex_lock(&sensor->power_lock);
++
++	if (sensor->streaming) {
++		ret = -EBUSY;
++		goto out;
++	}
++
++	mode = sensor->current_mode;
++
++	frame_rate = ov5645_try_frame_interval(sensor, &fi->interval,
++					       mode->width, mode->height);
++	if (frame_rate < 0)
++		frame_rate = OV5645_15_FPS;
++
++	mode = ov5645_find_mode(sensor, frame_rate, mode->width,
++				mode->height, true);
++	if (!mode) {
++		ret = -EINVAL;
++		goto out;
++	}
++
++	if (mode != sensor->current_mode ||
++	    frame_rate != sensor->current_fr) {
++		sensor->current_fr = frame_rate;
++		sensor->frame_interval = fi->interval;
++		sensor->current_mode = mode;
++	}
++out:
++	mutex_unlock(&sensor->power_lock);
++	return ret;
++}
++
+ static struct v4l2_mbus_framefmt *
+ __ov5645_get_pad_format(struct ov5645 *ov5645,
+ 			struct v4l2_subdev_pad_config *cfg,
+@@ -1012,7 +1408,10 @@ static int ov5645_s_stream(struct v4l2_subdev *subdev, int enable)
+ 				       OV5645_SYSTEM_CTRL0_START);
+ 		if (ret < 0)
+ 			return ret;
++
++		ov5645->streaming = enable;
+ 	} else {
++		ov5645->streaming = false;
+ 		ret = ov5645_write_reg(ov5645, OV5645_IO_MIPI_CTRL00, 0x40);
+ 		if (ret < 0)
+ 			return ret;
+@@ -1031,6 +1430,8 @@ static const struct v4l2_subdev_core_ops ov5645_core_ops = {
+ };
+ 
+ static const struct v4l2_subdev_video_ops ov5645_video_ops = {
++	.g_frame_interval = ov5645_g_frame_interval,
++	.s_frame_interval = ov5645_s_frame_interval,
+ 	.s_stream = ov5645_s_stream,
+ };
+ 
+@@ -1041,6 +1442,7 @@ static const struct v4l2_subdev_pad_ops ov5645_subdev_pad_ops = {
+ 	.get_fmt = ov5645_get_format,
+ 	.set_fmt = ov5645_set_format,
+ 	.get_selection = ov5645_get_selection,
++	.enum_frame_interval = ov5645_enum_frame_interval,
+ };
+ 
+ static const struct v4l2_subdev_ops ov5645_subdev_ops = {
+diff --git a/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c b/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c
+index 2dcac00d973f..d0a239ebafcf 100644
+--- a/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c
++++ b/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c
+@@ -98,9 +98,11 @@ struct rzg2l_csi2_format {
+ static const struct rzg2l_csi2_format rzg2l_csi2_formats[] = {
+ 	{ .code = MEDIA_BUS_FMT_RGB565_2X8_LE,	.bpp = 16 },
+ 	{ .code = MEDIA_BUS_FMT_RGB888_1X24,	.bpp = 24 },
++	{ .code = MEDIA_BUS_FMT_BGR888_1X24,	.bpp = 24 },
+ 	{ .code = MEDIA_BUS_FMT_UYVY8_1X16,	.bpp = 16 },
+ 	{ .code = MEDIA_BUS_FMT_YUYV8_1X16,	.bpp = 16 },
+ 	{ .code = MEDIA_BUS_FMT_UYVY8_2X8,	.bpp = 16 },
++	{ .code = MEDIA_BUS_FMT_YUYV8_2X8,	.bpp = 16 },
+ 	{ .code = MEDIA_BUS_FMT_YUYV10_2X10,	.bpp = 20 },
+ 	{ .code = MEDIA_BUS_FMT_SRGGB8_1X8,	.bpp = 8 },
+ 	{ .code = MEDIA_BUS_FMT_SGRBG8_1X8,	.bpp = 8 },
+diff --git a/drivers/media/platform/rzg2l-cru/rzg2l-dma.c b/drivers/media/platform/rzg2l-cru/rzg2l-dma.c
+index 777086bd01e1..5735b2c8c230 100644
+--- a/drivers/media/platform/rzg2l-cru/rzg2l-dma.c
++++ b/drivers/media/platform/rzg2l-cru/rzg2l-dma.c
+@@ -342,11 +342,13 @@ static int rzg2l_cru_mc_validate_format(struct rzg2l_cru_dev *cru,
+ 	} else {
+ 		switch (fmt.format.code) {
+ 		case MEDIA_BUS_FMT_UYVY8_2X8:
++		case MEDIA_BUS_FMT_YUYV8_2X8:
+ 		case MEDIA_BUS_FMT_UYVY10_2X10:
+ 		case MEDIA_BUS_FMT_RGB444_1X12:
+ 		case MEDIA_BUS_FMT_RGB565_2X8_LE:
+ 		case MEDIA_BUS_FMT_RGB666_1X18:
+ 		case MEDIA_BUS_FMT_RGB888_1X24:
++		case MEDIA_BUS_FMT_BGR888_1X24:
+ 		case MEDIA_BUS_FMT_SRGGB8_1X8:
+ 		case MEDIA_BUS_FMT_SGRBG8_1X8:
+ 		case MEDIA_BUS_FMT_SGBRG8_1X8:
+@@ -472,6 +474,10 @@ static void rzg2l_cru_csi2_setup(struct rzg2l_cru_dev *cru)
+ 		icnmc = ICnMC_INF_YUV8_422;
+ 		cru->input_fmt = YUV;
+ 		break;
++	case MEDIA_BUS_FMT_YUYV8_2X8:
++		icnmc = ICnMC_INF_YUV8_422;
++		cru->input_fmt = YUV;
++		break;
+ 	case MEDIA_BUS_FMT_UYVY10_2X10:
+ 		icnmc = ICnMC_INF_YUV10_422;
+ 		cru->input_fmt = YUV;
+@@ -488,7 +494,7 @@ static void rzg2l_cru_csi2_setup(struct rzg2l_cru_dev *cru)
+ 		icnmc = ICnMC_INF_RGB666;
+ 		cru->input_fmt = RGB;
+ 		break;
+-	case MEDIA_BUS_FMT_RGB888_1X24:
++	case MEDIA_BUS_FMT_BGR888_1X24:
+ 		icnmc = ICnMC_INF_RGB888;
+ 		cru->input_fmt = RGB;
+ 		break;
+diff --git a/include/linux/drpai.h b/include/linux/drpai.h
+new file mode 100644
+index 000000000000..bc47ac24984f
+--- /dev/null
++++ b/include/linux/drpai.h
+@@ -0,0 +1,22 @@
++/*
++ * Driver for the Renesas RZ/V2L DRP-AI unit
++ *
++ * Copyright (C) 2021 Renesas Electronics Corporation
++ *
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifndef _DRPAI_H
++#define _DRPAI_H
++
++#include <uapi/linux/drpai.h>
++
++#endif /* _DRPAI_H */
+diff --git a/include/uapi/linux/drpai.h b/include/uapi/linux/drpai.h
+new file mode 100644
+index 000000000000..ea13e0ba9501
+--- /dev/null
++++ b/include/uapi/linux/drpai.h
+@@ -0,0 +1,99 @@
++/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
++/*
++ * Driver for the Renesas RZ/V2L DRP-AI unit
++ *
++ * Copyright (C) 2021 Renesas Electronics Corporation
++ *
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; version 2 of the License.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#ifndef _UAPI__DRPAI_H
++#define _UAPI__DRPAI_H
++
++#ifdef __KERNEL__
++#include <linux/types.h>
++#else
++#include <stdint.h>
++#endif
++#include <linux/ioctl.h>
++
++#define DRPAI_IO_TYPE               (46)
++#define DRPAI_ASSIGN                _IOW (DRPAI_IO_TYPE, 0, drpai_data_t)
++#define DRPAI_START                 _IOW (DRPAI_IO_TYPE, 1, drpai_data_t)
++#define DRPAI_RESET                 _IO  (DRPAI_IO_TYPE, 2)
++#define DRPAI_GET_STATUS            _IOR (DRPAI_IO_TYPE, 3, drpai_status_t)
++#define DRPAI_REG_DUMP              _IO  (DRPAI_IO_TYPE, 5)
++#define DRPAI_ASSIGN_PARAM          _IOW (DRPAI_IO_TYPE, 6, drpai_assign_param_t)
++#define DRPAI_PREPOST_CROP          _IOW (DRPAI_IO_TYPE, 7, drpai_crop_t)
++#define DRPAI_PREPOST_INADDR        _IOW (DRPAI_IO_TYPE, 8, drpai_inout_t)
++
++#define DRPAI_INDEX_NUM             (7)
++#define DRPAI_INDEX_INPUT           (0)
++#define DRPAI_INDEX_DRP_DESC        (1)
++#define DRPAI_INDEX_DRP_CFG         (2)
++#define DRPAI_INDEX_DRP_PARAM       (3)
++#define DRPAI_INDEX_AIMAC_DESC      (4)
++#define DRPAI_INDEX_WEIGHT          (5)
++#define DRPAI_INDEX_OUTPUT          (6)
++#define DRPAI_STATUS_INIT           (0)
++#define DRPAI_STATUS_IDLE           (1)
++#define DRPAI_STATUS_RUN            (2)
++#define DRPAI_ERRINFO_SUCCESS       (0)
++#define DRPAI_ERRINFO_DRP_ERR       (-1)
++#define DRPAI_ERRINFO_AIMAC_ERR     (-2)
++#define DRPAI_ERRINFO_RESET         (-3)
++#define DRPAI_RESERVED_NUM          (10)
++#define DRPAI_MAX_NODE_NAME         (256)
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++typedef struct drpai_data
++{
++    uint32_t        address;
++    uint32_t        size;
++} drpai_data_t;
++
++typedef struct drpai_status
++{
++    uint32_t        status;
++    int32_t         err;
++    uint32_t        reserved[DRPAI_RESERVED_NUM];
++} drpai_status_t;
++
++typedef struct drpai_assign_param
++{
++    uint32_t     info_size;
++    drpai_data_t obj;
++} drpai_assign_param_t;
++
++typedef struct drpai_crop
++{
++    uint16_t     img_owidth;
++    uint16_t     img_oheight;
++    uint16_t     pos_x;
++    uint16_t     pos_y;
++    drpai_data_t obj;
++} drpai_crop_t;
++
++typedef struct drpai_inout
++{
++    char         name[DRPAI_MAX_NODE_NAME];
++    drpai_data_t data;
++    drpai_data_t obj;
++} drpai_inout_t;
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* _UAPI__DRPAI_H */
+-- 
+2.17.1
+
diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0006-Workaround-GPU-driver-remove-power-domains-v2l.patch b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0006-Workaround-GPU-driver-remove-power-domains-v2l.patch
new file mode 100644
index 0000000..60fa042
--- /dev/null
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas/0006-Workaround-GPU-driver-remove-power-domains-v2l.patch
@@ -0,0 +1,25 @@
+From cbe6c2e12dfe403ac06e19970524787b71587306 Mon Sep 17 00:00:00 2001
+From: nhatthieu <nhat.thieu.xr@renesas.com>
+Date: Tue, 19 Apr 2022 09:20:39 +0700
+Subject: [PATCH 6/6] Workaround GPU driver remove power domains v2l
+
+Signed-off-by: nhatthieu <nhat.thieu.xr@renesas.com>
+---
+ arch/arm64/boot/dts/renesas/r9a07g054.dtsi | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
+index 632757c4eba5..e74f78894be7 100644
+--- a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
++++ b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
+@@ -904,7 +904,6 @@
+ 				 <&cpg CPG_MOD R9A07G054_GPU_AXI_CLK>,
+ 				 <&cpg CPG_MOD R9A07G054_GPU_ACE_CLK>;
+ 			clock-names = "gpu", "bus", "bus_ace";
+-			power-domains = <&cpg>;
+ 			resets = <&cpg R9A07G054_GPU_RESETN>,
+ 				 <&cpg R9A07G054_GPU_AXI_RESETN>,
+ 				 <&cpg R9A07G054_GPU_ACE_RESETN>;
+-- 
+2.17.1
+
diff --git a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas_5.10.bbappend b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas_5.10.bbappend
index 5278249..71bc1f3 100644
--- a/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas_5.10.bbappend
+++ b/meta-renesas/recipes-rzg2l/recipes-kernel/linux/linux-renesas_5.10.bbappend
@@ -2,4 +2,13 @@ FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
 
 SRC_URI_append = " \
 	file://0001-Fixed-an-issue-that-caused-flicker-when-outputting-t.patch \
+        file://0002-arm64-dts-renesas-disable-OSTM2-I2C0-and-CRU.patch \
+        file://0003-arm64-dts-renesas-change-default-bootargs.patch \
+        file://0004-clk-renesas-r9a07g044-Set-SCIF2-OSTM2-CRU-I2C0-as-cr.patch \
+        file://0005-driver-DRP-AI-add-DPR-AI-support-for-RZ-V2L-board.patch \
+        file://0006-Workaround-GPU-driver-remove-power-domains-v2l.patch \
+"
+
+SRC_URI_append = " \
+        file://0001-arm64-defconfig-renesas-Update-defconfig-for-v2l-opt.patch \
 "
diff --git a/meta-rz-features/recipes-drpai/recipes-kernel/linux/linux-renesas_5.10.bbappend b/meta-rz-features/recipes-drpai/recipes-kernel/linux/linux-renesas_5.10.bbappend
index a1c0707..921acd2 100644
--- a/meta-rz-features/recipes-drpai/recipes-kernel/linux/linux-renesas_5.10.bbappend
+++ b/meta-rz-features/recipes-drpai/recipes-kernel/linux/linux-renesas_5.10.bbappend
@@ -5,13 +5,13 @@ DESCRIPTION = "DRP-AI Support Package with kernel for RZ/V2L Evaluation Board Ki
 
 FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}/:"
 
-SRC_URI_append += "\
-	file://0001-ov5645-Add-VGA-720x480-and-720p-resloutions.patch \
-	file://0002-ov5645-Add-pixel-rate-support-for-each-mode.patch \
-	file://0003-rzg2l-csi-Add-BGR24-and-YUYV-support.patch \
-	file://0004-rzg2l-dma-Add-BGR24-and-YUYV-support.patch \
-	file://0005-update-ov5645-VGA-setting.patch \
-	file://0006-update-cpg-function-for-drp.patch \
-	file://0007-enable-u-dma-buf-function.patch \
-	file://0008-enable-drpai-drv.patch \
-"
+#SRC_URI_append += "\
+#	file://0001-ov5645-Add-VGA-720x480-and-720p-resloutions.patch \
+#	file://0002-ov5645-Add-pixel-rate-support-for-each-mode.patch \
+#	file://0003-rzg2l-csi-Add-BGR24-and-YUYV-support.patch \
+#	file://0004-rzg2l-dma-Add-BGR24-and-YUYV-support.patch \
+#	file://0005-update-ov5645-VGA-setting.patch \
+#	file://0006-update-cpg-function-for-drp.patch \
+#	file://0007-enable-u-dma-buf-function.patch \
+#	file://0008-enable-drpai-drv.patch \
+#"
diff --git a/meta-rz-features/recipes-graphics/mali/linux-renesas_5.10.bbappend b/meta-rz-features/recipes-graphics/mali/linux-renesas_5.10.bbappend
index d5afa37..6a6b5f4 100644
--- a/meta-rz-features/recipes-graphics/mali/linux-renesas_5.10.bbappend
+++ b/meta-rz-features/recipes-graphics/mali/linux-renesas_5.10.bbappend
@@ -1,8 +1,8 @@
 FILESEXTRAPATHS_prepend := "${THISDIR}/files:"
 
-SRC_URI_append_rzg2l = " \
-        file://0002-Workaround-GPU-driver-remove-power-domains-of-GPU-no.patch \
-"
-SRC_URI_append_rzv2l = " \
-        file://0002-Workaround-GPU-driver-remove-power-domains-v2l.patch \
-"
+#SRC_URI_append_rzg2l = " \
+#        file://0002-Workaround-GPU-driver-remove-power-domains-of-GPU-no.patch \
+#"
+#SRC_URI_append_rzv2l = " \
+#        file://0002-Workaround-GPU-driver-remove-power-domains-v2l.patch \
+#"
diff --git a/meta-rz-features/recipes-kernel/linux/linux-renesas_5.10.bbappend b/meta-rz-features/recipes-kernel/linux/linux-renesas_5.10.bbappend
index bab729a..91f141b 100755
--- a/meta-rz-features/recipes-kernel/linux/linux-renesas_5.10.bbappend
+++ b/meta-rz-features/recipes-kernel/linux/linux-renesas_5.10.bbappend
@@ -3,11 +3,11 @@ KERVER = "5.10"
 FILESEXTRAPATHS_prepend := "${THISDIR}/${KERVER}:"
 
 # List of kernel patches
-SRC_URI += " \
-	file://0001-arm64-dts-renesas-rzg2l-smarc-Add-uio-support.patch \
-    file://0002-arm64-dts-renesas-rzg2l-smarc-Disable-OSTM2.patch \
-    file://0003-clk-renesas-r9a07g044-Set-SCIF2-OSTM2-as-critical.patch \
-"
+#SRC_URI += " \
+#	file://0001-arm64-dts-renesas-rzg2l-smarc-Add-uio-support.patch \
+#    file://0002-arm64-dts-renesas-rzg2l-smarc-Disable-OSTM2.patch \
+#    file://0003-clk-renesas-r9a07g044-Set-SCIF2-OSTM2-as-critical.patch \
+#"
 
 # Kernel confguration update
-SRC_URI += "file://uio.cfg"
+#SRC_URI += "file://uio.cfg"
-- 
2.25.1

