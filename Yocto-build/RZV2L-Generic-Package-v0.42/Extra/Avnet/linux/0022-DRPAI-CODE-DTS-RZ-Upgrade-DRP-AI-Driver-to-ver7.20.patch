From a9426eacf4c0dd537e63b8bd8fa0ab2a01e6f610 Mon Sep 17 00:00:00 2001
From: Nick <nick.cheng@avnet.com>
Date: Tue, 15 Nov 2022 17:50:04 +0800
Subject: [PATCH 22/27] DRPAI:CODE&DTS:RZ: Upgrade DRP-AI Driver to ver7.20

Signed-off-by: Nick <nick.cheng@avnet.com>
---
 arch/arm64/boot/dts/renesas/r9a07g054.dtsi |    1 +
 drivers/drpai/Kconfig                      |    2 +-
 drivers/drpai/Makefile                     |    3 +-
 drivers/drpai/drpai-core.c                 |  976 +++++++-----
 drivers/drpai/drpai-core.h                 |   77 +-
 drivers/drpai/drpai-if.c                   | 1592 ++++++++++++--------
 drivers/drpai/drpai-reg.h                  |   25 +-
 include/uapi/linux/drpai.h                 |   13 +-
 8 files changed, 1679 insertions(+), 1010 deletions(-)

diff --git a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
index e74f78894be7..25fd3ea1e7a3 100644
--- a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
@@ -1552,6 +1552,7 @@
 					 <&cpg CPG_MOD R9A07G054_STPAI_ACLK_DRP>;
 			resets = <&cpg R9A07G054_STPAI_ARESETN>;
 			power-domains = <&cpg>;
+			sysctrl = <&sysc>;
 			clock-names = "intclk","aclk_drp","mclk","dclkin","aclk";
 			interrupts = <GIC_SPI 440 IRQ_TYPE_LEVEL_HIGH>,
 						 <GIC_SPI 441 IRQ_TYPE_LEVEL_HIGH>,
diff --git a/drivers/drpai/Kconfig b/drivers/drpai/Kconfig
index e626673edf4a..834a35593401 100644
--- a/drivers/drpai/Kconfig
+++ b/drivers/drpai/Kconfig
@@ -2,7 +2,7 @@
 # DRP-AI subsystem configuration
 #
 
-menu "DRP-AI support"
+menu "DRP-AI/DRP support"
 
 config DRPAI
 	tristate "DRP-AI support"
diff --git a/drivers/drpai/Makefile b/drivers/drpai/Makefile
index 86915ad9f1b2..3d44ea4e2fc8 100644
--- a/drivers/drpai/Makefile
+++ b/drivers/drpai/Makefile
@@ -1,7 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 #
-# Makefile for DRP-AI.
+# Makefile for DRP-AI/DRP.
 #
 
 obj-$(CONFIG_DRPAI)	+= drpai-core.o drpai-if.o
 
+
diff --git a/drivers/drpai/drpai-core.c b/drivers/drpai/drpai-core.c
index 346078789ba8..9db9933b7da1 100644
--- a/drivers/drpai/drpai-core.c
+++ b/drivers/drpai/drpai-core.c
@@ -1,5 +1,5 @@
 /*
- * Driver for the Renesas RZ/V2L DRP-AI unit
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
  *
  * Copyright (C) 2021 Renesas Electronics Corporation
  *
@@ -23,9 +23,17 @@
 #include "r_typedefs.h"
 #endif
 #include <linux/drpai.h>
+#include <linux/reset.h>
 #include "drpai-core.h"
 #include "drpai-reg.h"
-#include <linux/reset.h>
+
+#if defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2M(A) conditional compilation */
+#define SET_STPC_CLKGEN_DIV                 (0x00030001)
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+#define SET_STPC_CLKGEN_DIV                 (0x00020001)
+#endif 
 
 #define DRP_ERRINT_MSK_REG_NUM              (6)
 #define DRP_ERRINT_STATUS_REG_NUM           (6)
@@ -35,11 +43,12 @@
 #define SET_STPC_CLKGEN_RST                 (0x00000000)
 #define SET_STPC_CLKGEN_STBYWAIT_EN         (0x00000001)
 #define SET_STPC_CLKGEN_STBYWAIT_DI         (0x00000000)
-#define SET_STPC_CLKGEN_DIV                 (0x00020001)
 #define SET_STPC_CLKE_EN                    (0x100F030F)
+#define SET_DRPB_STPC_CLKE_EN               (0x300F030F)
 #define SET_STPC_CLKE_DI                    (0x00000000)
 #define SET_STPC_SFTRST_EN                  (0xFFFFFFFF)
 #define SET_STPC_SFTRST_DI                  (0x21F000F0)
+#define SET_DRPB_STPC_SFTRST_DI             (0x01F000F0)
 #define SET_DSCC_DCTL_CR                    (0x00000000)
 #define SET_DSCC_DCTL                       (0x00310001)
 #define SET_EXD0_STPC_CLKGEN_CTRL           (0x00000001)
@@ -74,21 +83,21 @@
 #define DRPAI_RESERVED_SYNCTBL_TBL14        (8)
 #define DRPAI_RESERVED_SYNCTBL_TBL15        (9)
 
-/* Base address */
-extern void __iomem *g_drp_base_addr[DRP_CH_NUM];
-extern void __iomem *g_aimac_base_address[AIMAC_CH_NUM];
-extern struct drpai_priv *drpai_priv;
-
-static int32_t drp_init(int32_t ch);
-static int32_t drp_start(int32_t ch, uint32_t desc);
-static int32_t aimac_init(int32_t ch);
-static int32_t aimac_start(int32_t ch, uint32_t desc);
+static int32_t drp_init_tophalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+static int32_t drp_init_bottomhalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+static int32_t drp_start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc);
+static int32_t aimac_init(void __iomem *aimac_base_addr, int32_t ch);
+static int32_t aimac_start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock);
 static void reg_bit_clear(volatile void __iomem *reg_address, uint32_t bit);
-static void aimac_clear_synctbl_tbl(int32_t ch);
+static void aimac_clear_synctbl_tbl(void __iomem *aimac_base_addr);
+static void drp_clear_synctbl_tbl(void __iomem *drp_base_addr);
+static void drp_nmlint(void __iomem *drp_base_addr, drpai_odif_intcnto_t *odif_intcnto);
+static void drp_errint(void __iomem *drp_base_addr);
 static int8_t check_dma_reg_stop(void __iomem *base, uint32_t offset);
 static int8_t check_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset);
 static int8_t wait_for_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset);
 static int8_t wait_for_desc_prefetch_stop(void __iomem *base, uint32_t offset);
+static int32_t drp_cpg_reset(struct reset_control *rst_ctrl);
 
 static uint32_t exd0_odif_int_val;
 static uint32_t stpc_errint_sts_val;
@@ -153,121 +162,117 @@ const static char* aimac_errint_status_reg_name_tbl[AIMAC_ERRINT_STATUS_REG_NUM]
     "EXD1_IDMAC_INTSE","EXD0_ODMAC_INTSE","EXD1_ODMAC_INTSE","EXD0_RAC_EINTS","EXD1_RAC_EINTS"
 };
 
-static int32_t drp_init(int32_t ch)
+static int32_t drp_init_tophalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
-    uint32_t loop;
-    unsigned long flags;
-    struct drpai_priv *priv = drpai_priv;
 
     if (DRP_CH_NUM <= ch)
     {
         goto err_invalid_arg;
     }
 
-    /* Enable DRP clock */
-    iowrite32(SET_STPC_CLKGEN_CTRL, g_drp_base_addr[ch] + STPC_CLKGEN_CTRL);
+    /* DRP Init operation: No.1 Enable DRP clock */
+    iowrite32(SET_STPC_CLKGEN_CTRL, drp_base_addr + STPC_CLKGEN_CTRL);
 
-    /* Unreset the DRPCLKGEN module */
-    iowrite32(SET_STPC_CLKGEN_RST, g_drp_base_addr[ch] + STPC_CLKGEN_RST);
+    /* DRP Init operation: No.2 Release the DRPCLKGEN module reset */
+    iowrite32(SET_STPC_CLKGEN_RST, drp_base_addr + STPC_CLKGEN_RST);
 
-    /* Shift to standby mode */
-    iowrite32(SET_STPC_CLKGEN_STBYWAIT_EN, g_drp_base_addr[ch] + STPC_CLKGEN_STBYWAIT);
+    /* DRP Init operation: No.3 Shift to standby mode */
+    iowrite32(SET_STPC_CLKGEN_STBYWAIT_EN, drp_base_addr + STPC_CLKGEN_STBYWAIT);
 
-    /* DRP clock operating frequency setting */
+    /* DRP Init operation: No.4 DRP clock operating frequency setting */
     /* Div divided by 4 (DCLK=315MHz), set to dynamic frequency mode */
     /* Div divided by 4 (DCLK=315MHz) -> When Config is loaded       */
     /* Dynamic frequency mode -> When DRP application is running     */
-    iowrite32(SET_STPC_CLKGEN_DIV, g_drp_base_addr[ch] + STPC_CLKGEN_DIV);
-    iowrite32(SET_STPC_CLKGEN_STBYWAIT_DI, g_drp_base_addr[ch] + STPC_CLKGEN_STBYWAIT);
+    iowrite32(SET_STPC_CLKGEN_DIV, drp_base_addr + STPC_CLKGEN_DIV);
+    iowrite32(SET_STPC_CLKGEN_STBYWAIT_DI, drp_base_addr + STPC_CLKGEN_STBYWAIT);
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
 
-    /* Enable DMA channel clock */
-    iowrite32(SET_STPC_CLKE_EN, g_drp_base_addr[ch] + STPC_CLKE);
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
 
-    /* Release Soft reset */
-    spin_lock_irqsave(&priv->lock, flags);
-    iowrite32(SET_STPC_SFTRST_DI, g_drp_base_addr[ch] + STPC_SFTRST);
-    spin_unlock_irqrestore(&priv->lock, flags);
 
-    /* Data input channel settings */
-    iowrite32(SET_IDMACIF_DSC_EN, g_drp_base_addr[ch] + IDIF_DMACTLI0);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + IDIF_DMACTLI1);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + IDIF_DMACTLI2);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + IDIF_DMACTLI3);
+static int32_t drp_init_bottomhalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    int32_t ret;
+    uint32_t loop;
+
+    /* DRP Init operation: No.7 Data input channel settings */
+    iowrite32(SET_IDMACIF_DSC_EN,  drp_base_addr + IDIF_DMACTLI0);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + IDIF_DMACTLI1);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + IDIF_DMACTLI2);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + IDIF_DMACTLI3);
 
-    /* Data output channel settings */
-    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO0);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO1);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO2);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_drp_base_addr[ch] + ODIF_DMACTLO3);
+    /* DRP Init operation: No.8 Data output channel settings */
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO0);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO1);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO2);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO3);
 
-    /* Configuration light */
-    iowrite32(SET_IDMACIF_DSC_EN, g_drp_base_addr[ch] + IDIF_DMACTLCW);
+    /* DRP Init operation: No.9 Write Configuration */
+    iowrite32(SET_IDMACIF_DSC_EN, drp_base_addr + IDIF_DMACTLCW);
 
-/* ISP */
     /* Unmasks ODMAC interrupts */
-    iowrite32(0xFFFFFFF0, g_drp_base_addr[ch] + ODIF_INTMSK);
-/* ISP */
+    iowrite32(0xFFFFFFF0, drp_base_addr + ODIF_INTMSK);
 
     /* DRP error interrupt mask release */
     for (loop = 0; loop < DRP_ERRINT_MSK_REG_NUM; loop++)
     {
         iowrite32(drp_errint_msk_reg_tbl[loop][1],
-               g_drp_base_addr[ch] + drp_errint_msk_reg_tbl[loop][0]);
+               drp_base_addr + drp_errint_msk_reg_tbl[loop][0]);
     }
 
     ret =  R_DRPAI_SUCCESS;
-    goto end;
-
-err_invalid_arg:
-    ret = R_DRPAI_ERR_INVALID_ARG;
-    goto end;
-
-end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
 
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-static int32_t drp_start(int32_t ch, uint32_t desc)
+static int32_t drp_start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
+    uint32_t reg_val;
 
     if (DRP_CH_NUM <= ch)
     {
         goto err_invalid_arg;
     }
 
-/* ISP */
-    uint32_t reg_val;
-
+#if 1 
     /* Clear interrupt factor */
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);
-    writel(reg_val, g_drp_base_addr[ch] + ODIF_INT);            /* Clear */
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);            /* Dummy read */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);
+    iowrite32(reg_val, drp_base_addr + ODIF_INT);            /* Clear */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);            /* Dummy read */
 
     /* Reading the number of interrupts */
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO0);
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO1);
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO2);
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INTCNTO3);
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO0);
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO1);
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO2);
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO3);
 
     /* Unmasks ODMAC interrupts */
-    iowrite32(0xFFFFFFF0, g_drp_base_addr[ch] + ODIF_INTMSK);
-/* ISP */
+    iowrite32(0xFFFFFFF0, drp_base_addr + ODIF_INTMSK);
+#endif
 
     /* Set descriptor start address */
-    iowrite32(desc, g_drp_base_addr[ch] + DSCC_DPA);
+    iowrite32(desc, drp_base_addr + DSCC_DPA);
 
     /* Clear prefetch of input descriptor */
-    iowrite32(SET_DSCC_DCTL_CR, g_drp_base_addr[ch] + DSCC_DCTL);
+    iowrite32(SET_DSCC_DCTL_CR, drp_base_addr + DSCC_DCTL);
 
     /* Start prefetch of input descriptor */
-    iowrite32(SET_DSCC_DCTL, g_drp_base_addr[ch] + DSCC_DCTL);
+    iowrite32(SET_DSCC_DCTL, drp_base_addr + DSCC_DCTL);
 
     ret =  R_DRPAI_SUCCESS;
     goto end;
@@ -277,15 +282,13 @@ static int32_t drp_start(int32_t ch, uint32_t desc)
     goto end;
 
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-static int32_t aimac_init(int32_t ch)
+static int32_t aimac_init(void __iomem *aimac_base_addr, int32_t ch)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
     uint32_t loop;
 
@@ -295,55 +298,55 @@ static int32_t aimac_init(int32_t ch)
     }
 
     /* Unreset MCLKGEN module */
-    iowrite32(SET_EXD0_STPC_CLKGEN_RST, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_RST);
+    iowrite32(SET_EXD0_STPC_CLKGEN_RST, aimac_base_addr + EXD0_STPC_CLKGEN_RST);
 
     /* Shift to standby mode */
-    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_EN, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_STBYWAIT);
+    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_EN, aimac_base_addr + EXD0_STPC_CLKGEN_STBYWAIT);
 
     /* AIMAC clock operating frequency setting */
     /* Div divided by 2 (MCLK=630MHz), set to fixed frequency mode */
-    iowrite32(SET_EXD0_STPC_CLKGEN_DIV, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_DIV);
+    iowrite32(SET_EXD0_STPC_CLKGEN_DIV, aimac_base_addr + EXD0_STPC_CLKGEN_DIV);
 
     /* Clock activation */
-    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_DI, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_STBYWAIT);
+    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_DI, aimac_base_addr + EXD0_STPC_CLKGEN_STBYWAIT);
 
     /* Enable Clock */
-    iowrite32(SET_EXDX_STPC_CLKE_EN, g_aimac_base_address[ch] + EXD0_STPC_CLKE);
-    iowrite32(SET_EXDX_STPC_CLKE_EN, g_aimac_base_address[ch] + EXD1_STPC_CLKE);
-    iowrite32(SET_CLKRSTCON_CLKE_EN, g_aimac_base_address[ch] + CLKRSTCON_CLKE);
+    iowrite32(SET_EXDX_STPC_CLKE_EN, aimac_base_addr + EXD0_STPC_CLKE);
+    iowrite32(SET_EXDX_STPC_CLKE_EN, aimac_base_addr + EXD1_STPC_CLKE);
+    iowrite32(SET_CLKRSTCON_CLKE_EN, aimac_base_addr + CLKRSTCON_CLKE);
 
     /* Release soft reset */
-    iowrite32(SET_EXDX_STPC_SFTRST_DI, g_aimac_base_address[ch] + EXD0_STPC_SFTRST);
-    iowrite32(SET_EXDX_STPC_SFTRST_DI, g_aimac_base_address[ch] + EXD1_STPC_SFTRST);
-    iowrite32(SET_CLKRSTCON_SFTRST_DI, g_aimac_base_address[ch] + CLKRSTCON_SFTRST);
+    iowrite32(SET_EXDX_STPC_SFTRST_DI, aimac_base_addr + EXD0_STPC_SFTRST);
+    iowrite32(SET_EXDX_STPC_SFTRST_DI, aimac_base_addr + EXD1_STPC_SFTRST);
+    iowrite32(SET_CLKRSTCON_SFTRST_DI, aimac_base_addr + CLKRSTCON_SFTRST);
 
     /* DMA channel settings */
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI0);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI1);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI2);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI3);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO0);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO1);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO2);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO3);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI0);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI1);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI2);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI3);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO0);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO1);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO2);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO3);
-    iowrite32(SET_IDMACIF_MEMR_EN, g_aimac_base_address[ch] + AID_IDIF_DMACTLI0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + AID_IDIF_DMACTLI0);
 
     /* DRP-AI processing completion interrupt mask release */
-    iowrite32(SET_EXD1_ODIF_INTMSK, g_aimac_base_address[ch] + EXD1_ODIF_INTMSK);
+    iowrite32(SET_EXD1_ODIF_INTMSK, aimac_base_addr + EXD1_ODIF_INTMSK);
 
     /* AI-MAC error interrupt mask release */
     for (loop = 0; loop < AIMAC_ERRINT_MSK_REG_NUM; loop++)
     {
         iowrite32(aimac_errint_msk_reg_tbl[loop][1],
-               g_aimac_base_address[ch] + aimac_errint_msk_reg_tbl[loop][0]);
+               aimac_base_addr + aimac_errint_msk_reg_tbl[loop][0]);
     }
 
 
@@ -355,18 +358,15 @@ static int32_t aimac_init(int32_t ch)
     goto end;
 
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-static int32_t aimac_start(int32_t ch, uint32_t desc)
+static int32_t aimac_start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
     unsigned long flags;
-    struct drpai_priv *priv = drpai_priv;
 
     if (AIMAC_CH_NUM <= ch)
     {
@@ -374,16 +374,16 @@ static int32_t aimac_start(int32_t ch, uint32_t desc)
     }
 
     /* Initialization of register value storage variable */
-    spin_lock_irqsave(&priv->lock, flags);
+    spin_lock_irqsave(lock, flags);
     exd0_odif_int_val = 0;
-    spin_unlock_irqrestore(&priv->lock, flags);
+    spin_unlock_irqrestore(lock, flags);
 
     /* Set the start address of AIMAC descriptor */
-    iowrite32(desc, g_aimac_base_address[ch] + AID_DSCC_DPA);
+    iowrite32(desc, aimac_base_addr + AID_DSCC_DPA);
 
     /* Start descriptor read */
-    iowrite32(SET_AID_DSCC_DCTL_CR, g_aimac_base_address[ch] + AID_DSCC_DCTL);
-    iowrite32(SET_AID_DSCC_DCTL, g_aimac_base_address[ch] + AID_DSCC_DCTL);
+    iowrite32(SET_AID_DSCC_DCTL_CR, aimac_base_addr + AID_DSCC_DCTL);
+    iowrite32(SET_AID_DSCC_DCTL, aimac_base_addr + AID_DSCC_DCTL);
 
     ret =  R_DRPAI_SUCCESS;
     goto end;
@@ -393,23 +393,35 @@ static int32_t aimac_start(int32_t ch, uint32_t desc)
     goto end;
 
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-int32_t R_DRPAI_DRP_Open(int32_t ch)
+int32_t R_DRPAI_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
+    unsigned long flags;
 
     if (DRP_CH_NUM <= ch)
     {
         goto err_invalid_arg;
     }
 
-    ret = drp_init(ch);
+    ret = drp_init_tophalf(drp_base_addr, ch, lock);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    /* DRP Init operation: No.5 Enable DRPA DMA channel clock */
+    iowrite32(SET_STPC_CLKE_EN, drp_base_addr + STPC_CLKE);
+    /* DRP Init operation: No.6 Release DRPA Soft reset */
+    spin_lock_irqsave(lock, flags);
+    iowrite32(SET_STPC_SFTRST_DI, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
+
+    ret = drp_init_bottomhalf(drp_base_addr, ch, lock);
     if (R_DRPAI_SUCCESS != ret)
     {
         return ret;
@@ -421,23 +433,35 @@ int32_t R_DRPAI_DRP_Open(int32_t ch)
     ret = R_DRPAI_ERR_INVALID_ARG;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-int32_t R_DRPAI_DRP_Start(int32_t ch, uint32_t desc)
+int32_t R_DRPB_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
+    unsigned long flags;
 
     if (DRP_CH_NUM <= ch)
     {
         goto err_invalid_arg;
     }
 
-    ret = drp_start(ch, desc);
+    ret = drp_init_tophalf(drp_base_addr, ch, lock);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    /* DRP Init operation: No.5 Enable DRPB DMA channel clock */
+    iowrite32(SET_DRPB_STPC_CLKE_EN, drp_base_addr + STPC_CLKE);
+    /* DRP Init operation: No.6 Release DRPB Soft reset */
+    spin_lock_irqsave(lock, flags);
+    iowrite32(SET_DRPB_STPC_SFTRST_DI, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
+
+    ret = drp_init_bottomhalf(drp_base_addr, ch, lock);
     if (R_DRPAI_SUCCESS != ret)
     {
         return ret;
@@ -449,78 +473,95 @@ int32_t R_DRPAI_DRP_Start(int32_t ch, uint32_t desc)
     ret = R_DRPAI_ERR_INVALID_ARG;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPAI_DRP_Start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    int32_t ret;
 
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    ret = drp_start(drp_base_addr, ch, desc);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-/* ISP */
-int32_t R_DRPAI_DRP_Nmlint(int32_t ch, drpai_odif_intcnto_t *odif_intcnto)
+int32_t R_DRPB_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
+    
+    drp_nmlint(drp_base_addr, odif_intcnto);
 
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPAI_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    
+    drp_nmlint(drp_base_addr, odif_intcnto);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPB_DRP_Errint(void __iomem *drp_base_addr, int32_t ch)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
     uint32_t reg_val;
 
-    /* Clear interrupt factor */
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);
-    writel(reg_val, g_drp_base_addr[ch] + ODIF_INT);            /* Clear */
-    reg_val = readl(g_drp_base_addr[ch] + ODIF_INT);            /* Dummy read */
+    printk(KERN_ERR "DRP ERROR\n");
 
-    /* Reading the number of interrupts */
-    odif_intcnto->ch0 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO0);
-    odif_intcnto->ch1 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO1);
-    odif_intcnto->ch2 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO2);
-    odif_intcnto->ch3 = readl(g_drp_base_addr[ch] + ODIF_INTCNTO3);
+    /* Show descriptor pointer */
+    reg_val = ioread32(drp_base_addr + DSCC_PAMON);
+    printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    drp_errint(drp_base_addr);
 
+    DRPAI_DEBUG_PRINT("end.\n");
     return 0;
 }
-/* ISP */
 
-int32_t R_DRPAI_DRP_Errint(int32_t ch)
+int32_t R_DRPAI_DRP_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     uint32_t reg_val;
-    uint32_t loop;
 
     printk(KERN_ERR "DRP-AI DRP ERROR\n");
 
     /* Show descriptor pointer */
-    reg_val = ioread32(g_drp_base_addr[ch] + DSCC_PAMON);
+    reg_val = ioread32(drp_base_addr + DSCC_PAMON);
     printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
-    reg_val = ioread32(g_aimac_base_address[ch] + AID_DSCC_PAMON);
+    reg_val = ioread32(aimac_base_addr + AID_DSCC_PAMON);
     printk(KERN_ERR "AID_DSCC_PAMON  : 0x%08X\n", reg_val);
 
-    /* Error interrupt cause register */
-    stpc_errint_sts_val = ioread32(g_drp_base_addr[ch] + STPC_ERRINT_STS);
-    printk(KERN_ERR "STPC_ERRINT_STS : 0x%08X\n", stpc_errint_sts_val);
-
-    /* Error display of each module */
-    reg_val = ioread32(g_drp_base_addr[ch] + DRP_ERRINTSTATUS);
-    printk(KERN_ERR "DRP_ERRINTSTATUS : 0x%08X\n", reg_val);
-    if (0 != reg_val)
-    {
-        reg_val = ioread32(g_drp_base_addr[ch] + STPC_SFTRST);
-        reg_val |= DRPAI_BIT31;
-        iowrite32(reg_val, g_drp_base_addr[ch] + STPC_SFTRST);
-    }
-    for (loop = 0; loop < DRP_ERRINT_STATUS_REG_NUM; loop++)
-    {
-        reg_val = ioread32(g_drp_base_addr[ch] + drp_errint_status_reg_tbl[loop]);
-        iowrite32(reg_val, g_drp_base_addr[ch] + drp_errint_status_reg_tbl[loop]);
-        printk(KERN_ERR "%s : 0x%08X\n", drp_errint_status_reg_name_tbl[loop], reg_val);
-    }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    drp_errint(drp_base_addr);
 
+    DRPAI_DEBUG_PRINT("end.\n");
     return 0;
 }
 
-int32_t R_DRPAI_AIMAC_Open(int32_t ch)
+int32_t R_DRPAI_AIMAC_Open(void __iomem *aimac_base_addr, int32_t ch)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
 
     if (AIMAC_CH_NUM <= ch)
@@ -528,7 +569,7 @@ int32_t R_DRPAI_AIMAC_Open(int32_t ch)
         goto err_invalid_arg;
     }
 
-    ret = aimac_init(ch);
+    ret = aimac_init(aimac_base_addr, ch);
     if (R_DRPAI_SUCCESS != ret)
     {
         return ret;
@@ -540,15 +581,13 @@ int32_t R_DRPAI_AIMAC_Open(int32_t ch)
     ret = R_DRPAI_ERR_INVALID_ARG;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-int32_t R_DRPAI_AIMAC_Start(int32_t ch, uint32_t desc)
+int32_t R_DRPAI_AIMAC_Start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
 
     if (AIMAC_CH_NUM <= ch)
@@ -556,7 +595,7 @@ int32_t R_DRPAI_AIMAC_Start(int32_t ch, uint32_t desc)
         goto err_invalid_arg;
     }
 
-    ret = aimac_start(ch, desc);
+    ret = aimac_start(aimac_base_addr, ch, desc, lock);
     if (R_DRPAI_SUCCESS != ret)
     {
         return ret;
@@ -568,62 +607,58 @@ int32_t R_DRPAI_AIMAC_Start(int32_t ch, uint32_t desc)
     ret = R_DRPAI_ERR_INVALID_ARG;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
-int32_t R_DRPAI_AIMAC_Nmlint(int32_t ch)
+int32_t R_DRPAI_AIMAC_Nmlint(void __iomem *aimac_base_addr, int32_t ch)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
     volatile uint32_t dummy;
 
     /* Debug information */
-    exd0_odif_int_val = ioread32(g_aimac_base_address[ch] + EXD1_ODIF_INT);
+    exd0_odif_int_val = ioread32(aimac_base_addr + EXD1_ODIF_INT);
 
     /* Clear interrupt factor */
-    iowrite32(0x00000008, g_aimac_base_address[ch] + EXD1_ODIF_INT);   /* Clear */
-    dummy = ioread32(g_aimac_base_address[ch] + EXD1_ODIF_INT);        /* Dummy read */
-
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    iowrite32(0x00000008, aimac_base_addr + EXD1_ODIF_INT);   /* Clear */
+    dummy = ioread32(aimac_base_addr + EXD1_ODIF_INT);        /* Dummy read */
 
+    DRPAI_DEBUG_PRINT("end.\n");
     return 0;
 }
 
-int32_t R_DRPAI_AIMAC_Errint(int32_t ch)
+int32_t R_DRPAI_AIMAC_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     uint32_t reg_val;
     uint8_t i;
 
     printk(KERN_ERR "DRP-AI AI-MAC ERROR\n");
 
     /* Show descriptor pointer */
-    reg_val = ioread32(g_drp_base_addr[ch] + DSCC_PAMON);
+    reg_val = ioread32(drp_base_addr + DSCC_PAMON);
     printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
-    reg_val = ioread32(g_aimac_base_address[ch] + AID_DSCC_PAMON);
+    reg_val = ioread32(aimac_base_addr + AID_DSCC_PAMON);
     printk(KERN_ERR "AID_DSCC_PAMON  : 0x%08X\n", reg_val);
 
     /* Error interrupt cause register */
-    intmon_errint_val = ioread32(g_aimac_base_address[ch] + INTMON_ERRINT);
+    intmon_errint_val = ioread32(aimac_base_addr + INTMON_ERRINT);
     printk(KERN_ERR "INTMON_ERRINT : 0x%08X\n", intmon_errint_val);
 
     for (i = 0; i < AIMAC_ERRINT_STATUS_REG_NUM; i++)
     {
-        reg_val = ioread32(g_aimac_base_address[ch] + aimac_errint_status_reg_tbl[i]);
-        iowrite32(reg_val, g_aimac_base_address[ch] + aimac_errint_status_reg_tbl[i]);
+        reg_val = ioread32(aimac_base_addr + aimac_errint_status_reg_tbl[i]);
+        iowrite32(reg_val, aimac_base_addr + aimac_errint_status_reg_tbl[i]);
         printk(KERN_ERR "%s : 0x%08X\n",aimac_errint_status_reg_name_tbl[i], reg_val);
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
     return 0;
 }
 
-int32_t R_DRPAI_Status(int32_t ch, drpai_status_t *drpai_status)
+int32_t R_DRPAI_Status(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, drpai_status_t *drpai_status)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
+    DRPAI_DEBUG_PRINT("start.\n");
     int32_t ret;
 
     if (DRP_CH_NUM <= ch)
@@ -636,20 +671,20 @@ int32_t R_DRPAI_Status(int32_t ch, drpai_status_t *drpai_status)
     }
 
     /* DRP Address of descriptor */
-    drpai_status->reserved[DRPAI_RESERVED_DSCC_PAMON] = ioread32(g_drp_base_addr[ch] + DSCC_PAMON);
+    drpai_status->reserved[DRPAI_RESERVED_DSCC_PAMON] = ioread32(drp_base_addr + DSCC_PAMON);
 
     /* AI-MAC Address of descriptor */
-    drpai_status->reserved[DRPAI_RESERVED_AID_DSCC_PAMON] = ioread32(g_aimac_base_address[ch] + AID_DSCC_PAMON);
+    drpai_status->reserved[DRPAI_RESERVED_AID_DSCC_PAMON] = ioread32(aimac_base_addr + AID_DSCC_PAMON);
 
     /* DRP-AI processing complete interrupt status */
     drpai_status->reserved[DRPAI_RESERVED_EXD1_ODIF_INT_IRQ] = exd0_odif_int_val;
-    drpai_status->reserved[DRPAI_RESERVED_EXD1_ODIF_INT_NOW] = ioread32(g_aimac_base_address[ch] + EXD1_ODIF_INT);
+    drpai_status->reserved[DRPAI_RESERVED_EXD1_ODIF_INT_NOW] = ioread32(aimac_base_addr + EXD1_ODIF_INT);
 
     /* AI-MAC synchronization information */
-    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL12] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL12);
-    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL13] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL13);
-    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL14] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL14);
-    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL15] = ioread32(g_aimac_base_address[ch] + SYNCTBL_TBL15);
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL12] = ioread32(aimac_base_addr + SYNCTBL_TBL12);
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL13] = ioread32(aimac_base_addr + SYNCTBL_TBL13);
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL14] = ioread32(aimac_base_addr + SYNCTBL_TBL14);
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL15] = ioread32(aimac_base_addr + SYNCTBL_TBL15);
 
     /* DRP error information */
     drpai_status->reserved[DRPAI_RESERVED_STPC_ERRINT_STS] = stpc_errint_sts_val;
@@ -664,14 +699,40 @@ int32_t R_DRPAI_Status(int32_t ch, drpai_status_t *drpai_status)
     ret = R_DRPAI_ERR_INVALID_ARG;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPB_Status(void __iomem *drp_base_addr, int32_t ch, drpai_status_t *drpai_status)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    int32_t ret;
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* DRP Address of descriptor */
+    drpai_status->reserved[DRPAI_RESERVED_DSCC_PAMON] = ioread32(drp_base_addr + DSCC_PAMON);
+
+    /* DRP error information */
+    drpai_status->reserved[DRPAI_RESERVED_STPC_ERRINT_STS] = stpc_errint_sts_val;
 
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
 static void reg_bit_clear(volatile void __iomem *reg_address, uint32_t bit)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
     uint32_t tmp_reg;
 
     /* Read register value */
@@ -681,36 +742,108 @@ static void reg_bit_clear(volatile void __iomem *reg_address, uint32_t bit)
 
     iowrite32(tmp_reg, reg_address);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 }
 
-static void aimac_clear_synctbl_tbl(int32_t ch)
+static void aimac_clear_synctbl_tbl(void __iomem *aimac_base_addr)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL0);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL1);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL2);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL3);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL4);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL5);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL6);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL7);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL8);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL9);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL10);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL11);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL12);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL13);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL14);
-    iowrite32(0x0000FFFF, g_aimac_base_address[ch] + SYNCTBL_TBL15);
-
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL0);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL1);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL2);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL3);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL4);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL5);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL6);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL7);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL8);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL9);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL10);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL11);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL12);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL13);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL14);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL15);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drp_clear_synctbl_tbl(void __iomem *drp_base_addr)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL0);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL1);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL2);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL3);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL4);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL5);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL6);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL7);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL8);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL9);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL10);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL11);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL12);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL13);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL14);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL15);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drp_nmlint(void __iomem *drp_base_addr, drpai_odif_intcnto_t *odif_intcnto)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    uint32_t reg_val;
+
+    /* Clear interrupt factor */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);
+    iowrite32(reg_val, drp_base_addr + ODIF_INT);         /* Clear */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);         /* Dummy read */
+
+    /* Reading the number of interrupts */
+    odif_intcnto->ch0 = ioread32(drp_base_addr + ODIF_INTCNTO0);
+    odif_intcnto->ch1 = ioread32(drp_base_addr + ODIF_INTCNTO1);
+    odif_intcnto->ch2 = ioread32(drp_base_addr + ODIF_INTCNTO2);
+    odif_intcnto->ch3 = ioread32(drp_base_addr + ODIF_INTCNTO3);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drp_errint(void __iomem *drp_base_addr)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    uint32_t reg_val;
+    uint32_t loop;
+
+    /* Error interrupt cause register */
+    stpc_errint_sts_val = ioread32(drp_base_addr + STPC_ERRINT_STS);
+    printk(KERN_ERR "STPC_ERRINT_STS : 0x%08X\n", stpc_errint_sts_val);
+
+    /* Error display of each module */
+    reg_val = ioread32(drp_base_addr + DRP_ERRINTSTATUS);
+    printk(KERN_ERR "DRP_ERRINTSTATUS : 0x%08X\n", reg_val);
+    if (0 != reg_val)
+    {
+        reg_val = ioread32(drp_base_addr + STPC_SFTRST);
+        reg_val |= DRPAI_BIT31;
+        iowrite32(reg_val, drp_base_addr + STPC_SFTRST);
+    }
+    for (loop = 0; loop < DRP_ERRINT_STATUS_REG_NUM; loop++)
+    {
+        reg_val = ioread32(drp_base_addr + drp_errint_status_reg_tbl[loop]);
+        iowrite32(reg_val, drp_base_addr + drp_errint_status_reg_tbl[loop]);
+        printk(KERN_ERR "%s : 0x%08X\n", drp_errint_status_reg_name_tbl[loop], reg_val);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
 }
 
 static int8_t check_dma_reg_stop(void __iomem *base, uint32_t offset)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     uint32_t reg_val;
     int8_t ret;
@@ -725,13 +858,13 @@ static int8_t check_dma_reg_stop(void __iomem *base, uint32_t offset)
         ret = 0;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
     return ret;
 }
 
 static int8_t check_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int32_t i;
     int32_t ret;
@@ -754,14 +887,14 @@ static int8_t check_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_
     ret = -1;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return ret;
 }
 
 static int8_t wait_for_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     bool is_stop = false;
     int8_t ret;
@@ -810,20 +943,20 @@ static int8_t wait_for_dma_stop(void __iomem *base, uint32_t *offset, uint32_t n
         uint32_t reg_val;
         for(i = 0; i < num_offset; i++) {
             reg_val = ioread32(base + offset[i]);
-            DRPAI_DEBUG_PRINT(KERN_INFO "%s: offset: %08X = 0x%08X\n", __func__, offset[i], reg_val);
+            DRPAI_DEBUG_PRINT("offset: %08X = 0x%08X\n", offset[i], reg_val);
         }
 #endif
     }
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return ret;
 }
 
 static int8_t wait_for_desc_prefetch_stop(void __iomem *base, uint32_t offset)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     bool is_stop = false;
     int8_t ret;
@@ -871,98 +1004,95 @@ static int8_t wait_for_desc_prefetch_stop(void __iomem *base, uint32_t offset)
     else
     {
         ret = -1;
-        DRPAI_DEBUG_PRINT(KERN_INFO "%s: offset: %08X = 0x%08X\n", __func__, offset, reg_val);
+        DRPAI_DEBUG_PRINT("offset: %08X = 0x%08X\n", offset, reg_val);
     }
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return ret;
 }
 
-int32_t R_DRPAI_DRP_Reset(int32_t ch)
+int32_t R_DRPAI_DRP_Reset(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, spinlock_t *lock)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int32_t ret;
     uint32_t offset_buf[4];
     unsigned long flags;
-    struct drpai_priv *priv = drpai_priv;
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "%s: (pid %d)\n", __func__, current->pid);
-    
     if (DRP_CH_NUM <= ch)
     {
         goto err_invalid_arg;
     }
 
     /* Descriptor prefetch stop */
-    reg_bit_clear(g_drp_base_addr[ch] + DSCC_DCTL, DRPAI_BIT0);
-    if(0 != wait_for_desc_prefetch_stop(g_drp_base_addr[ch], DSCC_DCTL))
+    reg_bit_clear(drp_base_addr + DSCC_DCTL, DRPAI_BIT0);
+    if(0 != wait_for_desc_prefetch_stop(drp_base_addr, DSCC_DCTL))
     {
         goto err_reset;
     }
     
     /* Forced stop of writing configuration data */
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLCW, DRPAI_BIT18);
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLCW, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT0);
     offset_buf[0] = IDIF_DMACTLCW;
-    if(0 != wait_for_dma_stop(g_drp_base_addr[ch], offset_buf, 1))
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 1))
     {
         goto err_reset;
     }
 
     /* Forced stop of data input / output */
     /* IDIF_DMACTLI0,I1,I2,I3 */
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI0, DRPAI_BIT18);
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI1, DRPAI_BIT18);
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI2, DRPAI_BIT18);
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI3, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT18);
 
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI0, DRPAI_BIT0);
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI1, DRPAI_BIT0);
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI2, DRPAI_BIT0);
-    reg_bit_clear(g_drp_base_addr[ch] + IDIF_DMACTLI3, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT0);
 
-    aimac_clear_synctbl_tbl(ch);
+    aimac_clear_synctbl_tbl(aimac_base_addr);
 
     offset_buf[0] = IDIF_DMACTLI0;
     offset_buf[1] = IDIF_DMACTLI1;
     offset_buf[2] = IDIF_DMACTLI2;
     offset_buf[3] = IDIF_DMACTLI3;
-    if(0 != wait_for_dma_stop(g_drp_base_addr[ch], offset_buf, 4)){
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4)){
         goto err_reset;
     }
 
     /* ODIF_DMACTLO0,O1,O2,O3 */
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO0, DRPAI_BIT18);
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO1, DRPAI_BIT18);
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO2, DRPAI_BIT18);
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO3, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT18);
 
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO0, DRPAI_BIT0);
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO1, DRPAI_BIT0);
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO2, DRPAI_BIT0);
-    reg_bit_clear(g_drp_base_addr[ch] + ODIF_DMACTLO3, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT0);
 
-    aimac_clear_synctbl_tbl(ch);
+    aimac_clear_synctbl_tbl(aimac_base_addr);
 
     offset_buf[0] = ODIF_DMACTLO0;
     offset_buf[1] = ODIF_DMACTLO1;
     offset_buf[2] = ODIF_DMACTLO2;
     offset_buf[3] = ODIF_DMACTLO3;
-    if(0 != wait_for_dma_stop(g_drp_base_addr[ch], offset_buf, 4))
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4))
     {
         goto err_reset;
     }
 
     /* Set DRP core as fixed frequency mode  */
-    iowrite32((SET_STPC_CLKGEN_DIV & 0xFFFFFFFE), g_drp_base_addr[ch] + STPC_CLKGEN_DIV);
+    iowrite32((SET_STPC_CLKGEN_DIV & 0xFFFFFFFE), drp_base_addr + STPC_CLKGEN_DIV);
 
     /* Soft reset */
-    spin_lock_irqsave(&priv->lock, flags);
-    iowrite32(0xFFFFFFFF, g_drp_base_addr[ch] + STPC_SFTRST);
-    spin_unlock_irqrestore(&priv->lock, flags);
+    spin_lock_irqsave(lock, flags);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
 
     ret =  R_DRPAI_SUCCESS;
     goto end;
@@ -973,19 +1103,112 @@ int32_t R_DRPAI_DRP_Reset(int32_t ch)
     ret = R_DRPAI_ERR_RESET;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return ret;
 }
 
-int32_t R_DRPAI_AIMAC_Reset(int32_t ch)
+int32_t R_DRPB_DRP_Reset(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int32_t ret;
     uint32_t offset_buf[4];
+    unsigned long flags;
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* Descriptor prefetch stop */
+    reg_bit_clear(drp_base_addr + DSCC_DCTL, DRPAI_BIT0);
+    if(0 != wait_for_desc_prefetch_stop(drp_base_addr, DSCC_DCTL))
+    {
+        goto err_reset;
+    }
+    
+    /* Forced stop of writing configuration data */
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT0);
+    offset_buf[0] = IDIF_DMACTLCW;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 1))
+    {
+        goto err_reset;
+    }
+
+    /* Forced stop of data input / output */
+    /* IDIF_DMACTLI0,I1,I2,I3 */
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT18);
+
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT0);
+
+    drp_clear_synctbl_tbl(drp_base_addr);
+
+    offset_buf[0] = IDIF_DMACTLI0;
+    offset_buf[1] = IDIF_DMACTLI1;
+    offset_buf[2] = IDIF_DMACTLI2;
+    offset_buf[3] = IDIF_DMACTLI3;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4)){
+        goto err_reset;
+    }
+
+    /* ODIF_DMACTLO0,O1,O2,O3 */
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT18);
+
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT0);
+
+    drp_clear_synctbl_tbl(drp_base_addr);
+
+    offset_buf[0] = ODIF_DMACTLO0;
+    offset_buf[1] = ODIF_DMACTLO1;
+    offset_buf[2] = ODIF_DMACTLO2;
+    offset_buf[3] = ODIF_DMACTLO3;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4))
+    {
+        goto err_reset;
+    }
+
+    /* Set DRP core as fixed frequency mode  */
+    iowrite32((SET_STPC_CLKGEN_DIV & 0xFFFFFFFE), drp_base_addr + STPC_CLKGEN_DIV);
+
+    /* Soft reset */
+    spin_lock_irqsave(lock, flags);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "%s: (pid %d)\n", __func__, current->pid);
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+err_reset:
+    ret = R_DRPAI_ERR_RESET;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+int32_t R_DRPAI_AIMAC_Reset(void __iomem *aimac_base_addr, int32_t ch)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    int32_t ret;
+    uint32_t offset_buf[4];
 
     if (DRP_CH_NUM <= ch)
     {
@@ -993,125 +1216,125 @@ int32_t R_DRPAI_AIMAC_Reset(int32_t ch)
     }
 
     /* Descriptor prefetch stop */
-    reg_bit_clear(g_aimac_base_address[ch] + AID_DSCC_DCTL, DRPAI_BIT0);
-    if(0 != wait_for_desc_prefetch_stop(g_aimac_base_address[ch], AID_DSCC_DCTL))
+    reg_bit_clear(aimac_base_addr + AID_DSCC_DCTL, DRPAI_BIT0);
+    if(0 != wait_for_desc_prefetch_stop(aimac_base_addr, AID_DSCC_DCTL))
     {
         goto err_reset;
     }
 
     /* Forced stop of inputting parameters (weights and bias values) */
-    reg_bit_clear(g_aimac_base_address[ch] + AID_IDIF_DMACTLI0, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + AID_IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + AID_IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + AID_IDIF_DMACTLI0, DRPAI_BIT0);
 
-    aimac_clear_synctbl_tbl(ch);
+    aimac_clear_synctbl_tbl(aimac_base_addr);
 
     offset_buf[0] = AID_IDIF_DMACTLI0;
-    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 1))
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 1))
     {
         goto err_reset;
     }
 
     /* Forced stop of data input / output */
     /* EXD0_IDIF_DMACTLI0,I1,I2,I3 */
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI0, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI1, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI2, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI3, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI3, DRPAI_BIT18);
 
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI0, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI1, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI2, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_IDIF_DMACTLI3, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI3, DRPAI_BIT0);
 
-    aimac_clear_synctbl_tbl(ch);
+    aimac_clear_synctbl_tbl(aimac_base_addr);
 
     offset_buf[0] = EXD0_IDIF_DMACTLI0;
     offset_buf[1] = EXD0_IDIF_DMACTLI1;
     offset_buf[2] = EXD0_IDIF_DMACTLI2;
     offset_buf[3] = EXD0_IDIF_DMACTLI3;
-    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
     {
         goto err_reset;
     }
 
     /* EXD1_IDIF_DMACTLI0,I1,I2,I3 */
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI0, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI1, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI2, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI3, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI3, DRPAI_BIT18);
 
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI0, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI1, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI2, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_IDIF_DMACTLI3, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI3, DRPAI_BIT0);
 
-    aimac_clear_synctbl_tbl(ch);
+    aimac_clear_synctbl_tbl(aimac_base_addr);
 
     offset_buf[0] = EXD1_IDIF_DMACTLI0;
     offset_buf[1] = EXD1_IDIF_DMACTLI1;
     offset_buf[2] = EXD1_IDIF_DMACTLI2;
     offset_buf[3] = EXD1_IDIF_DMACTLI3;
-    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
     {
         goto err_reset;
     }
 
     /* EXD0_ODIF_DMACTLO0,O1,O2,O3 */
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO0, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO1, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO2, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO3, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO3, DRPAI_BIT18);
 
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO0, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO1, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO2, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD0_ODIF_DMACTLO3, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO3, DRPAI_BIT0);
 
-    aimac_clear_synctbl_tbl(ch);
+    aimac_clear_synctbl_tbl(aimac_base_addr);
 
     offset_buf[0] = EXD0_ODIF_DMACTLO0;
     offset_buf[1] = EXD0_ODIF_DMACTLO1;
     offset_buf[2] = EXD0_ODIF_DMACTLO2;
     offset_buf[3] = EXD0_ODIF_DMACTLO3;
-    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
     {
         goto err_reset;
     }
 
     /* EXD1_ODIF_DMACTLO0,O1,O2,O3 */
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO0, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO1, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO2, DRPAI_BIT18);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO3, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO3, DRPAI_BIT18);
 
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO0, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO1, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO2, DRPAI_BIT0);
-    reg_bit_clear(g_aimac_base_address[ch] + EXD1_ODIF_DMACTLO3, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO3, DRPAI_BIT0);
 
-    aimac_clear_synctbl_tbl(ch);
+    aimac_clear_synctbl_tbl(aimac_base_addr);
 
     offset_buf[0] = EXD1_ODIF_DMACTLO0;
     offset_buf[1] = EXD1_ODIF_DMACTLO1;
     offset_buf[2] = EXD1_ODIF_DMACTLO2;
     offset_buf[3] = EXD1_ODIF_DMACTLO3;
-    if(0 != wait_for_dma_stop(g_aimac_base_address[ch], offset_buf, 4))
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
     {
         goto err_reset;
     }
 
     /* Soft reset */
-    iowrite32(0xB1FF03FF, g_aimac_base_address[ch] + EXD0_STPC_SFTRST);
-    iowrite32(0xB1FF03FF, g_aimac_base_address[ch] + EXD1_STPC_SFTRST);
-    iowrite32(0x0000001F, g_aimac_base_address[ch] + CLKRSTCON_SFTRST);
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD0_STPC_SFTRST);
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD1_STPC_SFTRST);
+    iowrite32(0x0000001F, aimac_base_addr + CLKRSTCON_SFTRST);
 
     /* Stop clock */
-    iowrite32(0x00000000, g_aimac_base_address[ch] + EXD0_STPC_CLKE);
-    iowrite32(0x00000000, g_aimac_base_address[ch] + EXD1_STPC_CLKE);
-    iowrite32(0x00000000, g_aimac_base_address[ch] + CLKRSTCON_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + EXD0_STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + EXD1_STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + CLKRSTCON_CLKE);
 
     /* Stop MCLKGEN */
-    iowrite32(0x00000001, g_aimac_base_address[ch] + EXD0_STPC_CLKGEN_STBYWAIT);
+    iowrite32(0x00000001, aimac_base_addr + EXD0_STPC_CLKGEN_STBYWAIT);
 
     ret =  R_DRPAI_SUCCESS;
     goto end;
@@ -1123,33 +1346,68 @@ int32_t R_DRPAI_AIMAC_Reset(int32_t ch)
     ret = R_DRPAI_ERR_RESET;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return ret;
 }
 
-int32_t R_DRPAI_CPG_Reset(void)
+int32_t R_DRPAI_CPG_Reset(struct reset_control *rst_ctrl)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
+    int32_t ret;
+
+    ret = drp_cpg_reset(rst_ctrl);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPB_CPG_Reset(struct reset_control *rst_ctrl)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    int32_t ret;
+
+    ret = drp_cpg_reset(rst_ctrl);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int32_t drp_cpg_reset(struct reset_control *rst_ctrl)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int32_t ret;
     int32_t i = 0;
     int r_data;
-    struct drpai_priv *priv = drpai_priv;
     bool is_stop = false;
-	
-	/* Access reset controller interface */
-	reset_control_assert(priv->rstc);
-    reset_control_deassert(priv->rstc);
 
-	/* Check reset status */
+    /* Access reset controller interface */
+    reset_control_reset(rst_ctrl);
+
+    /* Check reset status */
     i = 0;
     while((RST_MAX_TIMEOUT > i) && (false == is_stop))
     {
         udelay(1);
         i++;
-		r_data = reset_control_status(priv->rstc);
-        if(1 == r_data)
+        r_data = reset_control_status(rst_ctrl);
+        DRPAI_DEBUG_PRINT("drp reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
         {
             is_stop = true;
             break;
@@ -1161,8 +1419,9 @@ int32_t R_DRPAI_CPG_Reset(void)
     {
         usleep_range(100, 200);
         i++;
-		r_data = reset_control_status(priv->rstc);
-        if(1 == r_data)
+        r_data = reset_control_status(rst_ctrl);
+        DRPAI_DEBUG_PRINT("drp reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
         {
             is_stop = true;
             break;
@@ -1176,14 +1435,23 @@ int32_t R_DRPAI_CPG_Reset(void)
     else
     {
         ret = R_DRPAI_ERR_RESET;
-        DRPAI_DEBUG_PRINT(KERN_INFO "%s: CPG Reset failed. Reset Control Status: %d\n", __func__,  r_data);
+        DRPAI_DEBUG_PRINT("CPG Reset failed. Reset Control Status: %d\n", r_data);
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return ret;
 }
 
-
-MODULE_DESCRIPTION("RZ/V2L DRP-AI driver");
+#if defined(CONFIG_ARCH_R9A09G011GBG) 
+/* V2M conditional compilation */
+MODULE_DESCRIPTION("RZ/V2M DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2MA conditional compilation */
+MODULE_DESCRIPTION("RZ/V2MA DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+MODULE_DESCRIPTION("RZ/V2L DRPAI driver");
+#endif
 MODULE_AUTHOR("Renesas Electronics Corporation");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/drpai/drpai-core.h b/drivers/drpai/drpai-core.h
index 309025905539..986d632b5677 100644
--- a/drivers/drpai/drpai-core.h
+++ b/drivers/drpai/drpai-core.h
@@ -1,5 +1,5 @@
 /*
- * Driver for the Renesas RZ/V2L DRP-AI unit
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
  *
  * Copyright (C) 2021 Renesas Electronics Corporation
  *
@@ -19,7 +19,7 @@
 
 #ifdef __KERNEL__
 #include <linux/types.h>
-#include <linux/semaphore.h>
+#include <asm/current.h>
 #else /* __KERNEL__ */
 #include "r_typedefs.h"
 #endif /* __KERNEL__ */
@@ -37,39 +37,31 @@
 #define R_DRPAI_ERR_INVALID_ARG         (-1)
 #define R_DRPAI_ERR_RESET               (-2)
 
+#define DEVICE_RZV2M                    (0)
+#define DEVICE_RZV2MA                   (1)
+#define DEVICE_RZV2L                    (2)
+
+#if defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2M(A) conditional compilation */
+#define CPG_RESET_SUCCESS               (0)
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+#define CPG_RESET_SUCCESS               (1)
+#endif 
+
 #define RST_CPG_WAIT (10)
 #define RST_MAX_TIMEOUT (100)
 
+/* Debug macro */
 // #define   DRPAI_DRV_DEBUG
 #ifdef  DRPAI_DRV_DEBUG
-#define DRPAI_DEBUG_PRINT(...)      printk(__VA_ARGS__)
+#define DRPAI_DEBUG_PRINT(fmt, ...) \
+            pr_info("[%s: %d](pid: %d) "fmt, \
+                            __func__, __LINE__, current->pid, ##__VA_ARGS__)
 #else
 #define DRPAI_DEBUG_PRINT(...)
 #endif
 
-/* Type definitions */
-struct drpai_priv {
-    struct platform_device *pdev;
-    const char *dev_name;
-    drpai_status_t drpai_status;
-    spinlock_t lock;
-    struct semaphore sem;
-    refcount_t count;
-    void __iomem *drp_base;
-    void __iomem *aimac_base;
-    struct clk *clk_int;
-    struct clk *clk_aclk_drp;
-    struct clk *clk_mclk;
-    struct clk *clk_dclkin;
-    struct clk *clk_aclk;
-    struct reset_control *rstc;
-    uint32_t aimac_irq_flag;
-/* ISP */
-    void (*isp_finish_loc)(int);
-/* ISP */
-};
-
-/* ISP */
 typedef struct drpai_odif_intcnto
 {
     uint32_t    ch0;
@@ -77,21 +69,24 @@ typedef struct drpai_odif_intcnto
     uint32_t    ch2;
     uint32_t    ch3;
 } drpai_odif_intcnto_t;
-/* ISP */
 
-int32_t R_DRPAI_DRP_Open(int32_t ch);
-int32_t R_DRPAI_DRP_Start(int32_t ch, uint32_t desc);
-/* ISP */
-int32_t R_DRPAI_DRP_Nmlint(int32_t ch, drpai_odif_intcnto_t *odif_intcnto);
-/* ISP */
-int32_t R_DRPAI_DRP_Errint(int32_t ch);
-int32_t R_DRPAI_AIMAC_Open(int32_t ch);
-int32_t R_DRPAI_AIMAC_Start(int32_t ch, uint32_t desc);
-int32_t R_DRPAI_AIMAC_Nmlint(int32_t ch);
-int32_t R_DRPAI_AIMAC_Errint(int32_t ch);
-int32_t R_DRPAI_Status(int32_t ch, drpai_status_t *drpai_status);
-int32_t R_DRPAI_DRP_Reset(int32_t ch);
-int32_t R_DRPAI_AIMAC_Reset(int32_t ch);
-int32_t R_DRPAI_CPG_Reset(void);
+int32_t R_DRPAI_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPAI_DRP_Start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc);
+int32_t R_DRPAI_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto);
+int32_t R_DRPAI_DRP_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_Open(void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_Start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock);
+int32_t R_DRPAI_AIMAC_Nmlint(void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_Status(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, drpai_status_t *drpai_status);
+int32_t R_DRPAI_DRP_Reset(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPAI_AIMAC_Reset(void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_CPG_Reset(struct reset_control *rst_ctrl);
+int32_t R_DRPB_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPB_Status(void __iomem *drp_base_addr, int32_t ch, drpai_status_t *drpai_status);
+int32_t R_DRPB_DRP_Reset(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPB_CPG_Reset(struct reset_control *rst_ctrl);
+int32_t R_DRPB_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto);
+int32_t R_DRPB_DRP_Errint(void __iomem *drp_base_addr, int32_t ch);
 
 #endif /* R_DRPAI_CORE_H */
diff --git a/drivers/drpai/drpai-if.c b/drivers/drpai/drpai-if.c
index dafa00282600..fcc374594759 100644
--- a/drivers/drpai/drpai-if.c
+++ b/drivers/drpai/drpai-if.c
@@ -1,5 +1,5 @@
 /*
- * Driver for the Renesas RZ/V2L DRP-AI unit
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
  *
  * Copyright (C) 2021 Renesas Electronics Corporation
  *
@@ -42,17 +42,18 @@
 #include <linux/fs.h>
 #include <asm/uaccess.h>
 #include <linux/buffer_head.h>
-#include <linux/dma-mapping.h> /* ISP */
-#include <linux/drpai.h>    /* Header file for DRP-AI Driver */
-#include "drpai-core.h"     /* Header file for DRP-AI Core */
 #include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/reset.h>
+#include <linux/drpai.h>    /* Header file for DRP-AI Driver */
+#include "drpai-core.h"     /* Header file for DRP-AI Core */
 
-#define DRPAI_DRIVER_VERSION         "1.10"
+/*Macro definitions*/
+#define DRPAI_DRIVER_VERSION        "1.20"
 #define DRPAI_DEV_NUM               (1)
 #define DRPAI_DRIVER_NAME           "drpai"     /* Device name */
 #define DRPAI_64BYTE_ALIGN          (0x3F)      /* Check 64-byte alignment */
+
 #define DRPAI_STATUS_IDLE_RW        (10)
 #define DRPAI_STATUS_ASSIGN         (11)
 #define DRPAI_STATUS_DUMP_REG       (12)
@@ -62,28 +63,39 @@
 #define DRPAI_STATUS_ASSIGN_PARAM   (16)
 #define DRPAI_STATUS_WRITE_PARAM    (17)
 
-#define MAX_SEM_TIMEOUT (msecs_to_jiffies(1000))
-#define HEAD_SENTINEL (UINT_MAX)
-
-/* ISP */
+#define MAX_SEM_TIMEOUT             (msecs_to_jiffies(1000))
+#define HEAD_SENTINEL               (UINT_MAX)
+
+#define DRP_PARAM_MAX_LINE_LENGTH   (512)
+#define DRP_PARAM_raddr             (0)
+#define DRP_PARAM_waddr             (4)
+#define DRP_PARAM_IMG_IWIDTH        (8)
+#define DRP_PARAM_IMG_IHEIGHT       (10)
+#define DRP_PARAM_IMG_OWIDTH        (16)
+#define DRP_PARAM_IMG_OHEIGHT       (18)
+#define DRP_PARAM_CROP_POS_X        (48)
+#define DRP_PARAM_CROP_POS_Y        (50)
+#define DRP_LIB_NAME_CROP           (",drp_lib:crop,")
+#define DRP_PARAM_ATTR_OFFSET_ADD   ("OFFSET_ADD:")
+#define DRP_PARAM_ATTR_PROP_INPUT   (",prop:input,")
+#define DRP_PARAM_ATTR_PROP_OUTPUT  (",prop:output,")
+
+#define SYS_SIZE                    (1024)
+#define SYS_DRP_BANK                (0x38)
+#define SYS_MASK_DRP                (0x000000C0)
+#define SYS_SHIFT                   (26)
+
+#define IRQ_CHECK_ENABLE            (1)
+#define IRQ_CHECK_DISABLE           (0)
+
+#define ISP_FINISH_SUCCESS          (0)
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
 #define DRPAI_SGL_DRP_DESC_SIZE     (80)
 #define DRPAI_DESC_CMD_SIZE         (16)
-#define DRPAI_CMA_SIZE              ((DRPAI_SGL_DRP_DESC_SIZE * 1) + DRPAI_DESC_CMD_SIZE + 64)
-/* ISP */
-
-#define DRP_PARAM_MAX_LINE_LENGTH (512)
-#define DRP_PARAM_raddr           (0)
-#define DRP_PARAM_waddr           (4)
-#define DRP_PARAM_IMG_IWIDTH      (8)
-#define DRP_PARAM_IMG_IHEIGHT     (10)
-#define DRP_PARAM_IMG_OWIDTH      (16)
-#define DRP_PARAM_IMG_OHEIGHT     (18)
-#define DRP_PARAM_CROP_POS_X      (48)
-#define DRP_PARAM_CROP_POS_Y      (50)
-#define DRP_LIB_NAME_CROP         (",drp_lib:crop,")
-#define DRP_PARAM_ATTR_OFFSET_ADD ("OFFSET_ADD:")
-#define DRP_PARAM_ATTR_PROP_INPUT (",prop:input,")
-#define DRP_PARAM_ATTR_PROP_OUTPUT (",prop:output,")
+#define DRPAI_CMA_SIZE              ((DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM) + DRPAI_DESC_CMD_SIZE + 64)
+#endif /* CONFIG_ARCH_R9A07G054  */
 
 /* A function called from the kernel */
 static int drpai_probe(struct platform_device *pdev);
@@ -98,16 +110,10 @@ static unsigned int drpai_poll( struct file* filp, poll_table* wait );
 static irqreturn_t irq_drp_errint(int irq, void *dev);
 static irqreturn_t irq_mac_nmlint(int irq, void *dev);
 static irqreturn_t irq_mac_errint(int irq, void *dev);
-
-/* ISP */
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
 static irqreturn_t irq_drp_nmlint(int irq, void *dev);
-
-/* Function called from the kernel */
-int drpai_open_k(void);
-int drpai_close_k(void);
-int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result));
-/* ISP */
-
+#endif /* CONFIG_ARCH_R9A07G054 */
 
 /* Internal function */
 static int drpai_regist_driver(void);
@@ -124,15 +130,30 @@ static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned l
 static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg);
 static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg);
 static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg);
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+static long drpai_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif /* CONFIG_ARCH_R9A07G054 */
 static int8_t get_param_attr(char *line, char *attr, unsigned long *rvalue);
-static int8_t drp_param_change16(uint32_t base, uint32_t offset, uint16_t value);
-static int8_t drp_param_change32(uint32_t base, uint32_t offset, uint32_t value);
-static int8_t drpai_flush_dcache_input_area(drpai_data_t *input);
-/* ISP */
+static int8_t drp_param_change16(uint64_t base, uint64_t offset, uint16_t value);
+static int8_t drp_param_change32(uint64_t base, uint64_t offset, uint32_t value);
+static int8_t drpai_flush_dcache_input_area(uint64_t addr, uint64_t size);
+static int drpai_drp_cpg_init(void);
+static int8_t drpai_get_sys_bank(uint64_t *bank);
+static int drpai_open_process(void);
+static int drpai_close_process(void);
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* DRP init function for V2L simple ISP */
 static int drpai_drp_config_init(void);
 static void drpai_drp_config_uninit(void);
-static int drpai_drp_cpg_init(void);
-/* ISP */
+
+/* Function called from the kernel for V2L simple ISP */
+int drpai_open_k(void);
+int drpai_close_k(void);
+int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result));
+#endif /* CONFIG_ARCH_R9A07G054 */
 
 /* Linux device driver initialization */
 static const unsigned int MINOR_BASE = 0;
@@ -142,11 +163,40 @@ static struct cdev drpai_cdev;                      /* Character device object *
 static struct class *drpai_class = NULL;            /* class object */
 struct device *drpai_device_array[DRPAI_DEV_NUM];
 
+/* Type definitions */
+struct drpai_priv 
+{
+    struct platform_device *pdev;
+    const char *dev_name;
+    uint8_t dev_tag;
+    drpai_status_t drpai_status;
+    spinlock_t lock;
+    struct semaphore sem;
+    refcount_t count;
+    void __iomem *drp_base;
+    void __iomem *aimac_base;
+    uint64_t bank;
+    struct reset_control *rstc;
+    uint32_t irq_flag;
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* V2L ISP */
+    struct clk *clk_int;
+    struct clk *clk_aclk_drp;
+    struct clk *clk_mclk;
+    struct clk *clk_dclkin;
+    struct clk *clk_aclk;
+    void (*isp_finish_loc)(int);
+#endif /* CONFIG_ARCH_R9A07G054 */
+};
+
 static DECLARE_WAIT_QUEUE_HEAD(drpai_waitq);
 
-struct drpai_priv *drpai_priv;
+static struct drpai_priv *drpai_priv;
 
-struct drpai_rw_status {
+struct drpai_rw_status 
+{
     uint32_t rw_status;
     uint32_t read_count;
     uint32_t write_count;
@@ -163,15 +213,18 @@ static DEFINE_SEMAPHORE(rw_sem);
 static struct drpai_rw_status *drpai_rw_sentinel;
 
 /* Virtual base address of register */
-void __iomem *g_drp_base_addr[DRP_CH_NUM];
-void __iomem *g_aimac_base_address[AIMAC_CH_NUM];
+static void __iomem *drp_base_addr[DRP_CH_NUM];
+static void __iomem *aimac_base_address[AIMAC_CH_NUM];
 static resource_size_t drp_size;
 static resource_size_t aimac_size;
 static resource_size_t drpai_region_base_addr;
 static resource_size_t drpai_region_size;
 static resource_size_t drpai_linux_mem_start;
 static resource_size_t drpai_linux_mem_size;
+static resource_size_t sysctrl_region_base_addr;
 
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
 /* ISP */
 static char* p_dmabuf_vaddr;
 static dma_addr_t p_dmabuf_phyaddr;
@@ -184,12 +237,15 @@ static unsigned char drp_single_desc_bin[] =
   0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
-
+static drpai_seq_t seq;
 drpai_odif_intcnto_t odif_intcnto;
+static uint32_t exe_mode;
 /* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */.
 
 /* handler table */
-static struct file_operations s_mydevice_fops = {
+static struct file_operations s_mydevice_fops = 
+{
     .open           = drpai_open,
     .release        = drpai_close,
     .write          = drpai_write,
@@ -199,12 +255,17 @@ static struct file_operations s_mydevice_fops = {
     .poll           = drpai_poll,
     .flush          = drpai_flush,
 };
-static const struct of_device_id drpai_match[] = {
 
-    { .compatible = "renesas,rzv2l-drpai",},
+static const struct of_device_id drpai_match[] = 
+{
+    { .compatible = "renesas,rzv2ma-drpai",},
+    { .compatible = "renesas,rzv2m-drpai", },
+    { .compatible = "renesas,rzv2l-drpai", },
     { /* sentinel */ }
 };
-static struct platform_driver drpai_platform_driver = {
+
+static struct platform_driver drpai_platform_driver = 
+{
     .driver = {
         .name   = "drpai-rz",
         .of_match_table = drpai_match,
@@ -215,38 +276,38 @@ static struct platform_driver drpai_platform_driver = {
 
 static int drpai_probe(struct platform_device *pdev)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     drpai_regist_driver();
     drpai_regist_device(pdev);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return 0;
 }
 
 static int drpai_remove(struct platform_device *pdev)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     drpai_unregist_driver();
     drpai_unregist_device();
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return 0;
 }
 
 static int drpai_open(struct inode *inode, struct file *file)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int result = 0;
     struct drpai_priv *priv = drpai_priv;
     unsigned long flags;
     struct drpai_rw_status *drpai_rw_status = 0;
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) major %d minor %d\n", __func__, current->pid, imajor(inode), iminor(inode));
+    DRPAI_DEBUG_PRINT("major %d minor %d\n", imajor(inode), iminor(inode));
 
     /* Allocate drpai_rw_status to each file descriptor */
     drpai_rw_status = kzalloc(sizeof(struct drpai_rw_status), GFP_KERNEL);
@@ -260,10 +321,10 @@ static int drpai_open(struct inode *inode, struct file *file)
     drpai_rw_status->param_info = NULL;
     INIT_LIST_HEAD(&drpai_rw_status->list);
     atomic_set(&drpai_rw_status->inout_flag, 0);
-    DRPAI_DEBUG_PRINT("[%s](pid %d) Generated list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    DRPAI_DEBUG_PRINT("Generated list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
     file->private_data = drpai_rw_status;
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
     {
@@ -273,38 +334,17 @@ static int drpai_open(struct inode *inode, struct file *file)
 
     if(likely((1 == refcount_read(&priv->count)) && (1 == atomic_long_read(&file->f_count))))
     {
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) Initialize DRP-AI\n", __func__, current->pid);
-
-        /* CPG Reset */
-        if(drpai_drp_cpg_init())
+        result = drpai_open_process();
+        if(R_DRPAI_SUCCESS != result)
         {
-            result = -EIO;
             goto end;
         }
-
-        /* Initialize DRP-AI */
-        drpai_init_device(0);
-
-        /* Reset DRP-AI */
-        if(R_DRPAI_SUCCESS != drpai_reset_device(0))
-        {
-            result = -EIO;
-            goto end;
-        }
-
-        /* Initialize DRP-AI */
-        drpai_init_device(0);
-
-        /* INIT -> IDLE */
-        spin_lock_irqsave(&priv->lock, flags);
-        priv->drpai_status.status = DRPAI_STATUS_IDLE;
-        spin_unlock_irqrestore(&priv->lock, flags);
     }
     /* Increment reference count */
     refcount_inc(&priv->count);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
 
     result = 0;
     goto end;
@@ -319,25 +359,16 @@ static int drpai_open(struct inode *inode, struct file *file)
         file->private_data = NULL;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return result;
 }
 
 static int drpai_close(struct inode *inode, struct file *file)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) major %d minor %d\n", __func__, current->pid, imajor(inode), iminor(inode));
-
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
-    return 0;
-}
-
-static int drpai_flush(struct file *file, fl_owner_t id)
-{
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("major %d minor %d\n", imajor(inode), iminor(inode));
 
     int result = 0;
     unsigned long flags;
@@ -348,18 +379,20 @@ static int drpai_flush(struct file *file, fl_owner_t id)
 
     if(unlikely(down_interruptible(&rw_sem))) 
     {
+        /* Note: this errno won't be returned to user*/
         result = -ERESTART;
+        DRPAI_DEBUG_PRINT("R/W semaphore obtained failed\n");
         goto end;
     }
 
-    DRPAI_DEBUG_PRINT("[%s](pid %d) HEAD  list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
+    DRPAI_DEBUG_PRINT("HEAD  list %px rw_status %d prev %px next %px\n", &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
     if(!list_empty(&drpai_rw_sentinel->list))
     {
         if((DRPAI_STATUS_ASSIGN   == drpai_rw_status->rw_status) || 
            (DRPAI_STATUS_READ_MEM == drpai_rw_status->rw_status) ||
            (DRPAI_STATUS_WRITE    == drpai_rw_status->rw_status))
            {
-                DRPAI_DEBUG_PRINT("[%s](pid %d) Deleted list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
                 list_del(&drpai_rw_status->list);
            }
     }
@@ -367,46 +400,32 @@ static int drpai_flush(struct file *file, fl_owner_t id)
 
     if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
     {
+        /* Note: this errno won't be returned to user*/
         result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("API semaphore obtained failed\n");
         goto end;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
-    if(1 == atomic_long_read(&file->f_count))
+    if(0 == atomic_long_read(&file->f_count))
     {
         if(2 == refcount_read(&priv->count))
         {
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start DRP-AI reset\n", __func__, current->pid);
-            if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+            result = drpai_close_process();
+            if(R_DRPAI_SUCCESS != result)
             {
-                result = -EIO;
+                /* Even reset failed, make sure reference count decrease*/
+                refcount_dec(&priv->count);
+                DRPAI_DEBUG_PRINT("Reset failed\n");
                 goto end;
             }
-
-            //CPG clock disable
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) CPG clock disable\n", __func__, current->pid);
-            clk_disable_unprepare(priv->clk_int);
-            clk_disable_unprepare(priv->clk_aclk_drp);
-            clk_disable_unprepare(priv->clk_mclk);
-            clk_disable_unprepare(priv->clk_dclkin);
-            clk_disable_unprepare(priv->clk_aclk);  
-
-            /* IDLE -> INIT */
-            /* RUN  -> INIT */
-            spin_lock_irqsave(&priv->lock, flags);
-            priv->drpai_status.status = DRPAI_STATUS_INIT;
-            priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
-            spin_unlock_irqrestore(&priv->lock, flags);
-
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) done DRP-AI reset\n", __func__, current->pid);
         }
         /* Decrement referenece count*/
         refcount_dec(&priv->count);
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
 
     goto end;
 end:
@@ -414,35 +433,44 @@ static int drpai_flush(struct file *file, fl_owner_t id)
     {
         up(&priv->sem);
     }
-    if(1 == atomic_long_read(&file->f_count))
+    if(0 == atomic_long_read(&file->f_count))
     {
         /* Free memory */
         if(NULL != drpai_rw_status->param_info)
         {
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) vfree is called\n", __func__, current->pid);
+            DRPAI_DEBUG_PRINT("vfree is called\n");
             vfree(drpai_rw_status->param_info);
             drpai_rw_status->param_info = NULL;
         }
         if(file->private_data) 
         {
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) kfree is called\n", __func__, current->pid);
+            DRPAI_DEBUG_PRINT("kfree is called\n");
             kfree(file->private_data);
             file->private_data = NULL;
         }
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return result;
 }
 
+static int drpai_flush(struct file *file, fl_owner_t id)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
 static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     ssize_t result = 0;
-    uint8_t *kbuf = NULL;
     volatile void *p_drpai_cma = 0;
+    struct drpai_priv *priv = drpai_priv;
     struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint64_t addr;
 
     if(unlikely(down_trylock(&rw_sem)))
     {
@@ -450,8 +478,7 @@ static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t co
         goto end;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     /* Check status */
     if (!((DRPAI_STATUS_ASSIGN == drpai_rw_status->rw_status) || 
@@ -489,27 +516,14 @@ static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t co
             ; /* Do nothing */
             break;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
 
     switch(drpai_rw_status->rw_status)
     {
         case DRPAI_STATUS_WRITE:
-            /* Secure Kbuf area */
-            kbuf = vmalloc(count);
-            if (NULL == kbuf)
-            {
-                result = -ENOMEM;
-                goto end;
-            }
-            /* Copy arguments from user space to kernel space */
-            if (copy_from_user(kbuf, buf, count))
-            {
-                result = -EFAULT;
-                goto end;
-            }
-
             /* Expand to DRP for CMA */
-            p_drpai_cma = phys_to_virt(drpai_rw_status->drpai_data.address + drpai_rw_status->write_count);
+            addr = priv->bank | (uint64_t)drpai_rw_status->drpai_data.address;
+            p_drpai_cma = phys_to_virt(addr + (uint64_t)drpai_rw_status->write_count);
             if (p_drpai_cma == 0)
             {
                 result = -EFAULT;
@@ -519,13 +533,17 @@ static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t co
             {
                 count = drpai_rw_status->drpai_data.size - drpai_rw_status->write_count;
             }
-            memcpy(p_drpai_cma, kbuf, count);
+            if (copy_from_user(p_drpai_cma, buf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
             drpai_rw_status->write_count = drpai_rw_status->write_count + count;
 
             /* DRPAI_STATUS_WRITE -> DRPAI_STATUS_IDLE_RW */
             if (drpai_rw_status->drpai_data.size <= drpai_rw_status->write_count)
             {
-                p_drpai_cma = phys_to_virt(drpai_rw_status->drpai_data.address);
+                p_drpai_cma = phys_to_virt(addr);
                 if (p_drpai_cma == 0)
                 {
                     result = -EFAULT;
@@ -533,7 +551,7 @@ static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t co
                 }
                 __flush_dcache_area(p_drpai_cma, drpai_rw_status->drpai_data.size);
                 drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
-                DRPAI_DEBUG_PRINT("[%s](pid %d) Deleted list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
                 list_del(&drpai_rw_status->list);
                 drpai_rw_status->drpai_data.address = 0x0;
                 drpai_rw_status->drpai_data.size    = 0x0;
@@ -555,7 +573,7 @@ static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t co
             /* DRPAI_STATUS_WRITE_PARAM -> DRPAI_STATUS_IDLE_RW */
             if (drpai_rw_status->assign_param.info_size <= drpai_rw_status->write_count)
             {
-                DRPAI_DEBUG_PRINT("[%s](pid %d) Status is changed \n", __func__, current->pid);
+                DRPAI_DEBUG_PRINT("Status is changed \n");
                 drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
             }
             result = count;
@@ -570,21 +588,16 @@ static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t co
     {
         up(&rw_sem);
     }
-    if (NULL != kbuf)
-    {
-        /* Free kbuf */
-        vfree(kbuf);
-    }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw3:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("status_rw3:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return result;
 }
 
 static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     ssize_t result = 0;
     uint8_t *kbuf = NULL;
     volatile void *p_drpai_cma = 0;
@@ -592,6 +605,7 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
     uint32_t i;
     struct drpai_rw_status *drpai_rw_status = filp->private_data;
     struct drpai_priv *priv = drpai_priv;
+    uint64_t addr;
 
     if(unlikely(down_trylock(&rw_sem)))
     {
@@ -599,8 +613,7 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
         goto end;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     /* Check status */
     if (!((DRPAI_STATUS_ASSIGN  == drpai_rw_status->rw_status) ||
@@ -624,14 +637,6 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
         goto end;
     }
 
-    /* Secure Kbuf area */
-    kbuf = vmalloc(count);
-    if (NULL == kbuf)
-    {
-        result = -ENOMEM;
-        goto end;
-    }
-
     switch(drpai_rw_status->rw_status)
     {
         case DRPAI_STATUS_ASSIGN:
@@ -646,13 +651,14 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
             ; /* Do nothing */
             break;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
 
     switch(drpai_rw_status->rw_status)
     {
         case DRPAI_STATUS_READ_MEM:
             /* Read DRP-AI memory */
-            p_drpai_cma = phys_to_virt(drpai_rw_status->drpai_data.address + drpai_rw_status->read_count);
+            addr = priv->bank | (uint64_t)drpai_rw_status->drpai_data.address;
+            p_drpai_cma = phys_to_virt(addr + drpai_rw_status->read_count);
             if (p_drpai_cma == 0)
             {
                 result = -EFAULT;
@@ -662,14 +668,19 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
             {
                 count = drpai_rw_status->drpai_data.size - drpai_rw_status->read_count;
             }
-            memcpy(kbuf, p_drpai_cma, count);
+            /* Copy arguments from kernel space to user space */
+            if (copy_to_user(buf, p_drpai_cma, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
             drpai_rw_status->read_count = drpai_rw_status->read_count + count;
 
             /* DRPAI_STATUS_READ -> DRPAI_STATUS_IDLE_RW */
             if (drpai_rw_status->drpai_data.size <= drpai_rw_status->read_count)
             {
                 drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
-                DRPAI_DEBUG_PRINT("[%s](pid %d) Deleted list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
                 list_del(&drpai_rw_status->list);
                 drpai_rw_status->drpai_data.address = 0x0;
                 drpai_rw_status->drpai_data.size    = 0x0;
@@ -683,11 +694,18 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
                 result = -ETIMEDOUT;
                 goto end;
             }
+            /* Secure Kbuf area */
+            kbuf = vmalloc(count);
+            if (NULL == kbuf)
+            {
+                result = -ENOMEM;
+                goto end;
+            }
             for (i = 0; i < count; i+=4)
             {
                 if (drp_size > drpai_rw_status->read_count)
                 {
-                    reg_val = ioread32(g_drp_base_addr[0] + drpai_rw_status->drp_reg_offset_count);
+                    reg_val = ioread32(drp_base_addr[0] + drpai_rw_status->drp_reg_offset_count);
                     *(kbuf + i)     = (uint8_t)reg_val;
                     *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
                     *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
@@ -696,7 +714,7 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
                 }
                 else
                 {
-                    reg_val = ioread32(g_aimac_base_address[0] + drpai_rw_status->aimac_reg_offset_count);
+                    reg_val = ioread32(aimac_base_address[0] + drpai_rw_status->aimac_reg_offset_count);
                     *(kbuf + i)     = (uint8_t)reg_val;
                     *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
                     *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
@@ -714,19 +732,18 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
                 }
             }
             up(&priv->sem);
+            /* Copy arguments from kernel space to user space */
+            if (copy_to_user(buf, kbuf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
             break;
         default:
             ; /* Do nothing */
             break;
     }
 
-    /* Copy arguments from kernel space to user space */
-    if (copy_to_user(buf, kbuf, count))
-    {
-        result = -EFAULT;
-        goto end;
-    }
-
     result = i;
     goto end;
 end:
@@ -739,9 +756,9 @@ static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, lof
         /* Free kbuf */
         vfree(kbuf);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw3:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("status_rw3:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return result;
 }
 
@@ -751,37 +768,44 @@ static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
     switch (cmd) {
     case DRPAI_ASSIGN:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_ASSIGN)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_ASSIGN)]\n");
         result = drpai_ioctl_assign(filp, cmd, arg);
         break;
     case DRPAI_START:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_START)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_START)]\n");
         result = drpai_ioctl_start(filp, cmd, arg);
         break;
     case DRPAI_RESET:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_RESET)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_RESET)]\n");
         result = drpai_ioctl_reset(filp, cmd, arg);
         break;
     case DRPAI_GET_STATUS:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_GET_STATUS)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_GET_STATUS)]\n");
         result = drpai_ioctl_get_status(filp, cmd, arg);
         break;
     case DRPAI_REG_DUMP:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_REG_DUMP)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_REG_DUMP)]\n");
         result = drpai_ioctl_reg_dump(filp, cmd, arg);
         break;
     case DRPAI_ASSIGN_PARAM:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_ASSIGN_PARAM)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_ASSIGN_PARAM)]\n");
         result = drpai_ioctl_assign_param(filp, cmd, arg);
         break;
     case DRPAI_PREPOST_CROP:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_PREPOST_CROP)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_PREPOST_CROP)]\n");
         result = drpai_ioctl_prepost_crop(filp, cmd, arg);
         break;
     case DRPAI_PREPOST_INADDR:
-        DRPAI_DEBUG_PRINT(KERN_INFO "[ioctl(DRPAI_PREPOST_INADDR)](pid %d)\n", current->pid);
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_PREPOST_INADDR)]\n");
         result = drpai_ioctl_prepost_inaddr(filp, cmd, arg);
         break;
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    case DRPAI_SET_SEQ:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_SET_SEQ)]\n");
+        result = drpai_ioctl_set_seq(filp, cmd, arg);
+        break;
+#endif /* CONFIG_ARCH_R9A07G054 */
     default:
         DRPAI_DEBUG_PRINT(KERN_WARNING "unsupported command %d\n", cmd);
         result = -EFAULT;
@@ -795,33 +819,33 @@ static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 static unsigned int drpai_poll( struct file* filp, poll_table* wait )
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     unsigned int retmask = 0;
     struct drpai_priv *priv = drpai_priv;
     unsigned long flags;
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-
     spin_lock_irqsave(&priv->lock, flags);
 
     poll_wait( filp, &drpai_waitq,  wait );
 
-    if (1 == priv->aimac_irq_flag)
+    if (IRQ_CHECK_DISABLE == priv->irq_flag)
     {
         retmask |= ( POLLIN  | POLLRDNORM );
     }
 
     spin_unlock_irqrestore(&priv->lock, flags);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return retmask;
 }
 
-/* ISP */
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
 static irqreturn_t irq_drp_nmlint(int irq, void *dev)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+
+    DRPAI_DEBUG_PRINT("start.\n");
     
     unsigned long flags;
     struct drpai_priv *priv = drpai_priv;
@@ -831,167 +855,197 @@ static irqreturn_t irq_drp_nmlint(int irq, void *dev)
     /* For success ISP call back*/
     void (*finish_callback)(int);
     finish_callback = priv->isp_finish_loc;
-    /* For success ISP call back*/
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("\n");
+    DRPAI_DEBUG_PRINT("status1:%d\n", priv->drpai_status.status);
 
     /* DRP normal interrupt processing */
-    R_DRPAI_DRP_Nmlint(0, &local_odif_intcnto);
+    R_DRPAI_DRP_Nmlint(drp_base_addr[0], 0, &local_odif_intcnto);
 
     odif_intcnto.ch0 += local_odif_intcnto.ch0;
     odif_intcnto.ch1 += local_odif_intcnto.ch1;
     odif_intcnto.ch2 += local_odif_intcnto.ch2;
     odif_intcnto.ch3 += local_odif_intcnto.ch3;
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
-
-    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO0 : 0x%08X\n", local_odif_intcnto.ch0);
-    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO1 : 0x%08X\n", local_odif_intcnto.ch1);
-    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO2 : 0x%08X\n", local_odif_intcnto.ch2);
-    DRPAI_DEBUG_PRINT(KERN_INFO "local_ODIF_INTCNTO3 : 0x%08X\n", local_odif_intcnto.ch3);
-
-    if  ((1 == odif_intcnto.ch0) &&
-        (1 == odif_intcnto.ch1) &&
-        (1 == odif_intcnto.ch2) &&
-        (1 == odif_intcnto.ch3))
-     {
-        /* Internal state update */
-        priv->drpai_status.status = DRPAI_STATUS_IDLE;
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
-        /* For success ISP call back*/
-        if(NULL != finish_callback)
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
+
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO0 : 0x%08X\n", local_odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO1 : 0x%08X\n", local_odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO2 : 0x%08X\n", local_odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO3 : 0x%08X\n", local_odif_intcnto.ch3);
+
+/* DRP single operation */
+    if(DRPAI_EXE_AI == exe_mode)
+    {
+        if  ((1 == odif_intcnto.ch0) &&
+            (1 == odif_intcnto.ch1) &&
+            (1 == odif_intcnto.ch2) &&
+            (1 == odif_intcnto.ch3))
         {
-            (*finish_callback)(0);
+            /* Internal state update */
+            priv->drpai_status.status = DRPAI_STATUS_IDLE;
+            DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+            /* For success ISP call back*/
+            if(NULL != finish_callback)
+            {
+                (*finish_callback)(ISP_FINISH_SUCCESS);
+            }
         }
-     }
+    }
+    else if (DRPAI_EXE_DRP == exe_mode)
+    {
+        if ((seq.num == odif_intcnto.ch0) &&
+            (seq.num == odif_intcnto.ch1) &&
+            (seq.num == odif_intcnto.ch2) &&
+            (seq.num == odif_intcnto.ch3))
+        {
+            /* Internal state update */
+            priv->drpai_status.status = DRPAI_STATUS_IDLE;
+            DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+            priv->irq_flag = IRQ_CHECK_DISABLE;
+            /* Wake up the process */
+            wake_up_interruptible( &drpai_waitq );
+        }
+    }
+    else
+    {
+        // do nothing
+    }
+/* DRP single operation */
+
     priv->isp_finish_loc = NULL;
     spin_unlock_irqrestore(&priv->lock, flags);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return IRQ_HANDLED;
 }
-/* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
 
 static irqreturn_t irq_drp_errint(int irq, void *dev)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     unsigned long flags;
     struct drpai_priv *priv = drpai_priv;
 
     spin_lock_irqsave(&priv->lock, flags);
-/* ISP */
-/* For error ISP call back*/
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    /* For error simpel ISP call back*/
     void (*finish_callback)(int);
     finish_callback = priv->isp_finish_loc;
 
     if(NULL != finish_callback)
     {
-        (*finish_callback)(-5);
+        (*finish_callback)(-EIO);
     }
-/* For error ISP call back*/
-/* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
     /* DRP error interrupt processing */
-    R_DRPAI_DRP_Errint(0);
+    R_DRPAI_DRP_Errint(drp_base_addr[0], aimac_base_address[0], 0);
 
-/* ISP */
     /* Internal state update */
     priv->drpai_status.err = DRPAI_ERRINFO_DRP_ERR;
     priv->drpai_status.status = DRPAI_STATUS_IDLE;
-    priv->aimac_irq_flag = 1;
-    
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
+#if defined(CONFIG_ARCH_R9A07G054)
+    /* V2L conditional compilation */
     /* Wake up the process when it's not ISP mode*/
     if(NULL == finish_callback)
     {
         wake_up_interruptible( &drpai_waitq );
     }
     priv->isp_finish_loc = NULL;
-/* ISP */
+#elif defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG)
+    /* V2M(A) conditional compilation */
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+#endif 
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
     spin_unlock_irqrestore(&priv->lock, flags);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return IRQ_HANDLED;
 }
 
 static irqreturn_t irq_mac_nmlint(int irq, void *dev)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     unsigned long flags;
     struct drpai_priv *priv = drpai_priv;
 
     spin_lock_irqsave(&priv->lock, flags);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
     /* AI-MAC normal interrupt processing */
-    R_DRPAI_AIMAC_Nmlint(0);
+    R_DRPAI_AIMAC_Nmlint(aimac_base_address[0], 0);
 
     /* Internal state update */
     priv->drpai_status.status = DRPAI_STATUS_IDLE;
-    priv->aimac_irq_flag = 1;
-    
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
     /* Wake up the process */
     wake_up_interruptible( &drpai_waitq );
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
     spin_unlock_irqrestore(&priv->lock, flags);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return IRQ_HANDLED;
 }
+
 static irqreturn_t irq_mac_errint(int irq, void *dev)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
+
     unsigned long flags;
     struct drpai_priv *priv = drpai_priv;
 
     spin_lock_irqsave(&priv->lock, flags);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
     /* AI-MAC error interrupt processing */
-    R_DRPAI_AIMAC_Errint(0);
+    R_DRPAI_AIMAC_Errint(drp_base_addr[0], aimac_base_address[0], 0);
 
     /* Internal state update */
     priv->drpai_status.err = DRPAI_ERRINFO_AIMAC_ERR;
     priv->drpai_status.status = DRPAI_STATUS_IDLE;
-    priv->aimac_irq_flag = 1;
-    
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
     /* Wake up the process */
     wake_up_interruptible( &drpai_waitq );
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
     spin_unlock_irqrestore(&priv->lock, flags);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return IRQ_HANDLED;
 }
 
 static int drpai_regist_driver(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int alloc_ret = 0;
     int cdev_err = 0;
     dev_t dev;
 
-    printk(KERN_INFO "DRP-AI Driver version : %s\n", DRPAI_DRIVER_VERSION);
-
     /* Get free major number. */
     alloc_ret = alloc_chrdev_region(&dev, MINOR_BASE, MINOR_NUM, DRPAI_DRIVER_NAME);
     if (alloc_ret != 0) {
-        printk(KERN_ERR "alloc_chrdev_region = %d\n", alloc_ret);
+        pr_err("DRP-AI Driver: alloc_chrdev_region = %d\n", alloc_ret);
         return -1;
     }
 
@@ -1006,7 +1060,7 @@ static int drpai_regist_driver(void)
     /* Registration cdev */
     cdev_err = cdev_add(&drpai_cdev, dev, MINOR_NUM);
     if (cdev_err != 0) {
-        printk(KERN_ERR  "cdev_add = %d\n", cdev_err);
+        pr_err("DRP-AI Driver: cdev_add = %d\n", cdev_err);
         unregister_chrdev_region(dev, MINOR_NUM);
         return -1;
     }
@@ -1014,7 +1068,7 @@ static int drpai_regist_driver(void)
     /* Cleate class "/sys/class/drpai/" */
     drpai_class = class_create(THIS_MODULE, DRPAI_DRIVER_NAME);
     if (IS_ERR(drpai_class)) {
-        printk(KERN_ERR  "class_create = %d\n", drpai_class);
+        pr_err("DRP-AI Driver: class_create = %d\n", drpai_class);
         cdev_del(&drpai_cdev);
         unregister_chrdev_region(dev, MINOR_NUM);
         return -1;
@@ -1027,14 +1081,14 @@ static int drpai_regist_driver(void)
         device_create(drpai_class, NULL, MKDEV(drpai_major, minor), NULL, DRPAI_DRIVER_NAME "%d", minor);
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return 0;
 }
 
 static int drpai_regist_device(struct platform_device *pdev)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     struct resource *res;
     struct resource reserved_res;
@@ -1060,10 +1114,6 @@ static int drpai_regist_device(struct platform_device *pdev)
     priv->drpai_status.status = DRPAI_STATUS_INIT; 
     priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
     drpai_priv = priv;
-/* ISP */
-    /* Call back function pointer initialization */
-    drpai_priv->isp_finish_loc = NULL;
-/* ISP */
 
     /* Initialize list head */
     drpai_rw_status = devm_kzalloc(&pdev->dev, sizeof(struct drpai_rw_status), GFP_KERNEL);
@@ -1076,7 +1126,43 @@ static int drpai_regist_device(struct platform_device *pdev)
     INIT_LIST_HEAD(&drpai_rw_status->list);
     atomic_set(&drpai_rw_status->inout_flag, 0);
     drpai_rw_sentinel = drpai_rw_status;
-    DRPAI_DEBUG_PRINT("[%s](pid %d) HEAD  list %px rw_status %d prev %px next %px\n", __func__, current->pid, &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
+    DRPAI_DEBUG_PRINT("HEAD  list %px rw_status %d prev %px next %px\n", &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
+
+    if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2m-drpai"))
+    {
+        drpai_priv->dev_tag = DEVICE_RZV2M;
+        dev_info(&pdev->dev, "DRP-AI Driver version : %s V2M\n", DRPAI_DRIVER_VERSION);
+    }
+    else if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2ma-drpai"))
+    {
+        drpai_priv->dev_tag = DEVICE_RZV2MA;
+        dev_info(&pdev->dev, "DRP-AI Driver version : %s V2MA\n", DRPAI_DRIVER_VERSION);
+    }
+    else if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2l-drpai"))
+    {
+        drpai_priv->dev_tag = DEVICE_RZV2L;
+        dev_info(&pdev->dev, "DRP-AI Driver version : %s V2L\n", DRPAI_DRIVER_VERSION);
+    }
+    else
+    {
+        /* Do Nothing */
+    }
+
+    /* Get reserved register region from Device tree.*/
+    np = of_parse_phandle(pdev->dev.of_node, "sysctrl", 0);
+    if (!np) {
+        dev_err(&pdev->dev, "No %s specified\n", "sysctrl");
+        return -ENOMEM;
+    }
+
+    /* Convert register region to a struct resource */
+    ret = of_address_to_resource(np, 0, &reserved_res);
+    if (ret) {
+        dev_err(&pdev->dev, "No memory address assigned to the region\n");
+        return -ENOMEM;
+    }
+    sysctrl_region_base_addr = reserved_res.start;
+    dev_info(&pdev->dev, "sysctrl register region start 0x%016llX\n", sysctrl_region_base_addr);
 
     /* Get reserved memory region from Device tree.*/
     np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
@@ -1093,7 +1179,7 @@ static int drpai_regist_device(struct platform_device *pdev)
     }
     drpai_region_base_addr = reserved_res.start;
     drpai_region_size = resource_size(&reserved_res);
-    printk(KERN_INFO "DRP-AI memory region start 0x%08X, size 0x%08X\n", drpai_region_base_addr, drpai_region_size);
+    dev_info(&pdev->dev, "DRP-AI memory region start 0x%016llX, size 0x%08X\n", drpai_region_base_addr, drpai_region_size);
 
     /* Get linux memory region from Device tree.*/
     np = of_parse_phandle(pdev->dev.of_node, "linux-memory-region", 0);
@@ -1110,7 +1196,7 @@ static int drpai_regist_device(struct platform_device *pdev)
     }
     drpai_linux_mem_start = reserved_res.start;
     drpai_linux_mem_size = resource_size(&reserved_res);
-    printk(KERN_INFO "linux-memory-region start 0x%08X, size 0x%08X\n", drpai_linux_mem_start, drpai_linux_mem_size);
+    dev_info(&pdev->dev, "linux-memory-region start 0x%016llX, size 0x%08X\n", drpai_linux_mem_start, drpai_linux_mem_size);
 
     /* Convert DRP base address from physical to virtual */
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1123,9 +1209,9 @@ static int drpai_regist_device(struct platform_device *pdev)
         dev_err(&pdev->dev, "cannot ioremap\n");
         return -EINVAL;
     }
-    g_drp_base_addr[0] = priv->drp_base;
+    drp_base_addr[0] = priv->drp_base;
     drp_size = resource_size(res);
-    printk(KERN_INFO "DRP base address 0x%08X, size 0x%08X\n", res->start, drp_size);
+    dev_info(&pdev->dev, "DRP base address 0x%08X, size 0x%08X\n", res->start, drp_size);
 
     /* Convert AI-MAC base address from physical to virtual */
     res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
@@ -1138,19 +1224,11 @@ static int drpai_regist_device(struct platform_device *pdev)
         dev_err(&pdev->dev, "cannot ioremap\n");
         return -EINVAL;
     }
-    g_aimac_base_address[0] = priv->aimac_base;
+    aimac_base_address[0] = priv->aimac_base;
     aimac_size = resource_size(res);
-    printk(KERN_INFO "AI-MAC base address 0x%08X, size 0x%08X\n", res->start, aimac_size);
+    dev_info(&pdev->dev, "AI-MAC base address 0x%08X, size 0x%08X\n", res->start, aimac_size);
 
     /* Registering an interrupt handler */
-/* ISP */
-    irq = platform_get_irq(pdev, 0);
-    ret = devm_request_irq(&pdev->dev, irq, irq_drp_nmlint, 0, "drpa nmlint", priv);
-    if (ret) {
-        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
-        return ret;
-    }
-/* ISP */
     irq = platform_get_irq(pdev, 1);
     ret = devm_request_irq(&pdev->dev, irq, irq_drp_errint, 0, "drpa errint", priv);
     if (ret) {
@@ -1170,58 +1248,68 @@ static int drpai_regist_device(struct platform_device *pdev)
         return ret;
     }
 
-	/* Get clock controller info */
-	priv->clk_int = devm_clk_get(&pdev->dev, "intclk");
-	if (IS_ERR(priv->clk_int)) {
-		dev_err(&pdev->dev, "missing controller clock");
-		return PTR_ERR(priv->clk_int);
-	}
-	
-	priv->clk_aclk_drp = devm_clk_get(&pdev->dev, "aclk_drp");
-	if (IS_ERR(priv->clk_aclk_drp)) {
-		dev_err(&pdev->dev, "missing controller clock");
-		return PTR_ERR(priv->clk_aclk_drp);
-	}
-	
-	priv->clk_mclk = devm_clk_get(&pdev->dev, "mclk");
-	if (IS_ERR(priv->clk_mclk)) {
-		dev_err(&pdev->dev, "missing controller clock");
-		return PTR_ERR(priv->clk_mclk);
-	}
-	
-	priv->clk_dclkin = devm_clk_get(&pdev->dev, "dclkin");
-	if (IS_ERR(priv->clk_dclkin)) {
-		dev_err(&pdev->dev, "missing controller clock");
-		return PTR_ERR(priv->clk_dclkin);
-	}
-	
-	priv->clk_aclk = devm_clk_get(&pdev->dev, "aclk");
-	if (IS_ERR(priv->clk_aclk)) {
-		dev_err(&pdev->dev, "missing controller clock");
-		return PTR_ERR(priv->clk_aclk);
-	}
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+
+    irq = platform_get_irq(pdev, 0);
+    ret = devm_request_irq(&pdev->dev, irq, irq_drp_nmlint, 0, "drpa nmlint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    /* Get clock controller info */
+    priv->clk_int = devm_clk_get(&pdev->dev, "intclk");
+    if (IS_ERR(priv->clk_int)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_int);
+    }
+    
+    priv->clk_aclk_drp = devm_clk_get(&pdev->dev, "aclk_drp");
+    if (IS_ERR(priv->clk_aclk_drp)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_aclk_drp);
+    }
+    
+    priv->clk_mclk = devm_clk_get(&pdev->dev, "mclk");
+    if (IS_ERR(priv->clk_mclk)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_mclk);
+    }
+    
+    priv->clk_dclkin = devm_clk_get(&pdev->dev, "dclkin");
+    if (IS_ERR(priv->clk_dclkin)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_dclkin);
+    }
+    
+    priv->clk_aclk = devm_clk_get(&pdev->dev, "aclk");
+    if (IS_ERR(priv->clk_aclk)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_aclk);
+    }
+
+#endif /* CONFIG_ARCH_R9A07G054 */
 
     /* Get reset controller info */
     priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
     if (IS_ERR(priv->rstc))
     {
-        DRPAI_DEBUG_PRINT(KERN_INFO "failed to get DRP cpg reset\n");        
+        dev_err(&pdev->dev, "Failed to get DRP CPG reset controller\n");
+        return PTR_ERR(priv->rstc);
     }
     else
     {
-        DRPAI_DEBUG_PRINT(KERN_INFO "OK!!!! get DRP cpg reset\n");        
+        DRPAI_DEBUG_PRINT("Get DRP CPG reset controller\n");        
     } 
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return 0;
 }
 
 static void drpai_unregist_driver(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
-    DRPAI_DEBUG_PRINT(KERN_INFO "drpai_unregist_driver");
+    DRPAI_DEBUG_PRINT("start.\n");
 
     dev_t dev = MKDEV(drpai_major, MINOR_BASE);
 
@@ -1239,35 +1327,37 @@ static void drpai_unregist_driver(void)
 
     /* Unregistration */
     unregister_chrdev_region(dev, MINOR_NUM);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 }
 
 static void drpai_unregist_device(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
     /* Do nothing */
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 }
 
 static int8_t drpai_reset_device(uint32_t ch)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
     int8_t retval;
-
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
+    struct drpai_priv *priv = drpai_priv;
 
     /* Reset DRP */
-    if(R_DRPAI_SUCCESS != R_DRPAI_DRP_Reset(ch)) {
+    if(R_DRPAI_SUCCESS != R_DRPAI_DRP_Reset(drp_base_addr[0], aimac_base_address[0], ch, &priv->lock)) 
+    {
         goto err_reset;
     }
 
     /* Reset AI-MAC */
-    if(R_DRPAI_SUCCESS != R_DRPAI_AIMAC_Reset(ch)) {
+    if(R_DRPAI_SUCCESS != R_DRPAI_AIMAC_Reset(aimac_base_address[0], ch)) 
+    {
         goto err_reset;
     }
 
     /* Reset CPG register */
-    if(R_DRPAI_SUCCESS != R_DRPAI_CPG_Reset()) {
+    if(R_DRPAI_SUCCESS != R_DRPAI_CPG_Reset(priv->rstc)) 
+    {
         goto err_reset;
     }
 
@@ -1277,35 +1367,37 @@ static int8_t drpai_reset_device(uint32_t ch)
     retval = R_DRPAI_ERR_RESET;
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return retval;
 }
 
 static void drpai_init_device(uint32_t ch)
 {
-	unsigned long flags;
+    DRPAI_DEBUG_PRINT("start.\n");
+    unsigned long flags;
     struct drpai_priv *priv = drpai_priv;
-    
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
+
     spin_lock_irqsave(&priv->lock, flags);
-    priv->aimac_irq_flag = 1;
+    priv->irq_flag = IRQ_CHECK_DISABLE;
     spin_unlock_irqrestore(&priv->lock, flags);
-    (void)R_DRPAI_DRP_Open(0);
-    (void)R_DRPAI_AIMAC_Open(0);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    (void)R_DRPAI_DRP_Open(drp_base_addr[0], 0, &priv->lock);
+    (void)R_DRPAI_AIMAC_Open(aimac_base_address[0], 0);
+
+    DRPAI_DEBUG_PRINT("end.\n");
 }
 
 static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
     long result = 0;
     volatile void *p_virt_address = 0;
+    struct drpai_priv *priv = drpai_priv;
     struct drpai_rw_status *drpai_rw_status = filp->private_data;
     struct drpai_rw_status *entry;
     struct list_head *listitr;
     drpai_data_t drpai_data_buf;
+    uint64_t addr, size;
 
     if(unlikely(down_trylock(&rw_sem)))
     {
@@ -1313,8 +1405,8 @@ static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned lon
         goto end;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) (pid %d)\n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     /* Check NULL */
     if (NULL == arg)
@@ -1337,27 +1429,29 @@ static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned lon
         goto end;
     }
     /* Check Argument */
-    if (0 != (drpai_data_buf.address & DRPAI_64BYTE_ALIGN))
+    addr = priv->bank | (uint64_t)drpai_data_buf.address;
+    size = (uint64_t)drpai_data_buf.size;
+    if (0 != (addr & DRPAI_64BYTE_ALIGN))
     {
         result = -EINVAL;
         goto end;
     }
-    if ((drpai_region_base_addr > drpai_data_buf.address) || 
-       ((drpai_region_base_addr + drpai_region_size) <= (drpai_data_buf.address + drpai_data_buf.size)))
+    if ((drpai_region_base_addr > addr) || 
+       ((drpai_region_base_addr + drpai_region_size) <= (addr + size)))
     {
         result = -EINVAL;
         goto end;
     }
 
     /* Check the assigned address */
-    DRPAI_DEBUG_PRINT("[%s](pid %d) list %px prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    DRPAI_DEBUG_PRINT("list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
     if(!list_empty(&drpai_rw_sentinel->list))
     {   
-        DRPAI_DEBUG_PRINT("[%s](pid %d) List is not empty\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("List is not empty\n");
         list_for_each(listitr, &drpai_rw_sentinel->list)
         {
             entry = list_entry(listitr, struct drpai_rw_status, list);
-            DRPAI_DEBUG_PRINT("[%s](pid %d) rw_status %d list %px prev %px next %px\n", __func__, current->pid, entry->rw_status, &entry->list, entry->list.prev, entry->list.next);
+            DRPAI_DEBUG_PRINT("rw_status %d list %px prev %px next %px\n", entry->rw_status, &entry->list, entry->list.prev, entry->list.next);
             if(HEAD_SENTINEL != entry->rw_status)
             {
                 if( !( (entry->drpai_data.address > (drpai_data_buf.address + drpai_data_buf.size - 1)) ||
@@ -1371,7 +1465,8 @@ static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned lon
     }
 
     /* Data cache invalidate. DRP-AI W -> CPU R */
-    p_virt_address = phys_to_virt(drpai_data_buf.address);
+    addr = priv->bank | (uint64_t)drpai_data_buf.address;
+    p_virt_address = phys_to_virt(addr);
     if (p_virt_address == 0)
     {
         result = -EFAULT;
@@ -1386,7 +1481,7 @@ static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned lon
     drpai_rw_status->read_count  = 0;
     /* Register assigned status */
     list_add(&drpai_rw_status->list, &drpai_rw_sentinel->list);
-    DRPAI_DEBUG_PRINT("[%s](pid %d) Registered list %px prev %px next %px\n", __func__, current->pid, &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    DRPAI_DEBUG_PRINT("Registered list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
 
     goto end;
 end:
@@ -1394,18 +1489,24 @@ static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned lon
     {
         up(&rw_sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     int result = 0;
     drpai_data_t proc[DRPAI_INDEX_NUM];
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* DRP single operation */
+    drpai_data_t proc_drp[DRPAI_SEQ_NUM * 2];
+/* DRP single operation */
+#endif /* CONFIG_ARCH_R9A07G054 */
     volatile void *p_drp_param = 0;
     volatile void *p_drp_desc = 0;
     volatile void *p_aimac_desc = 0;
@@ -1413,6 +1514,7 @@ static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long
     unsigned long flags;
     int i;
     struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint64_t addr, size;
 
     if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
     {
@@ -1420,8 +1522,8 @@ static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long
         goto end;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
     /* Check NULL */
     if (NULL == arg)
@@ -1439,90 +1541,190 @@ static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long
         goto end;
     }
     spin_unlock_irqrestore(&priv->lock, flags);
-    /* Copy arguments from user space to kernel space */
-    if (copy_from_user(&proc[0], (void __user *)arg, sizeof(proc)))
-    {
-        result = -EFAULT;
-        goto end;
-    }
-    /* Check Argument */
-    for (i = DRPAI_INDEX_DRP_DESC; i < DRPAI_INDEX_NUM; i++)
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* DRP single operation */
+    if(DRPAI_EXE_AI == exe_mode)
     {
-        if (0 != (proc[i].address & DRPAI_64BYTE_ALIGN))
+#endif
+        /* Copy arguments from user space to kernel space */
+        if (copy_from_user(&proc[0], (void __user *)arg, sizeof(proc)))
         {
-            result = -EINVAL;
+            result = -EFAULT;
             goto end;
         }
-        if ((drpai_region_base_addr > proc[i].address) || 
-           ((drpai_region_base_addr + drpai_region_size) <= (proc[i].address + proc[i].size)))
+        /* Check Argument */
+        for (i = DRPAI_INDEX_DRP_DESC; i < DRPAI_INDEX_NUM; i++)
+        {
+            addr = priv->bank | (uint64_t)proc[i].address;
+            size = (uint64_t)proc[i].size;
+            if (0 != (addr & DRPAI_64BYTE_ALIGN))
             {
                 result = -EINVAL;
                 goto end;
             }
-    }
+            if ((drpai_region_base_addr > addr) || 
+            ((drpai_region_base_addr + drpai_region_size) <= (addr + size)))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+        }
 
-    /* Check if input is in linux memory region */
-    if(0 == atomic_read(&drpai_rw_status->inout_flag))
-    {
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) Use arg variable\n", __func__, current->pid);
-        if(0 != drpai_flush_dcache_input_area(&proc[DRPAI_INDEX_INPUT]))
+        /* Check if input is in linux memory region */
+        if(0 == atomic_read(&drpai_rw_status->inout_flag))
+        {
+            DRPAI_DEBUG_PRINT("Use arg variable\n");
+            addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_INPUT].address;
+            size = (uint64_t)proc[DRPAI_INDEX_INPUT].size;
+            if(0 != drpai_flush_dcache_input_area(addr, size))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            /* Change input address to value specified by user app. */
+            addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_DRP_PARAM].address;
+            if(0 != drp_param_change32(addr, 0, proc[DRPAI_INDEX_INPUT].address))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+        }
+        
+        /* drp_desc.bin */
+        addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_DRP_DESC].address;
+        p_drp_desc = phys_to_virt(addr);
+        if (p_drp_desc == 0)
         {
             result = -EFAULT;
             goto end;
         }
-        /* Change input address to value specified by user app. */
-        if(0 != drp_param_change32(proc[DRPAI_INDEX_DRP_PARAM].address, 0, proc[DRPAI_INDEX_INPUT].address))
+        /* Changed link descriptor of drp_desc.bin */
+        if (0 != (proc[DRPAI_INDEX_DRP_DESC].size & 0x0F))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+        iowrite8(0x08, p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13);
+        __flush_dcache_area(p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13, 1);
+
+        /* aimac_desc.bin */
+        addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_AIMAC_DESC].address;
+        p_aimac_desc = phys_to_virt(addr);
+        if (p_aimac_desc == 0)
         {
             result = -EFAULT;
             goto end;
         }
-    }
-    
-    /* drp_desc.bin */
-    p_drp_desc = phys_to_virt(proc[DRPAI_INDEX_DRP_DESC].address);
-    if (p_drp_desc == 0)
-    {
-        result = -EFAULT;
-        goto end;
-    }
-    /* Changed link descriptor of drp_desc.bin */
-    if (0 != (proc[DRPAI_INDEX_DRP_DESC].size & 0x0F))
-    {
-        result = -EINVAL;
-        goto end;
-    }
-    iowrite8(0x08, p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13);
-    __flush_dcache_area(p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13, 1);
+        /* Changed link descriptor of drp_desc.bin */
+        if (0 != (proc[DRPAI_INDEX_AIMAC_DESC].size & 0x0F))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+        iowrite8(0x08, p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13);
+        __flush_dcache_area(p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13, 1);
 
-    /* aimac_desc.bin */
-    p_aimac_desc = phys_to_virt(proc[DRPAI_INDEX_AIMAC_DESC].address);
-    if (p_aimac_desc == 0)
-    {
-        result = -EFAULT;
-        goto end;
+        spin_lock_irqsave(&priv->lock, flags);
+        /* Init drpai_status.err */
+        priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+        /* IDLE -> RUN */
+        priv->drpai_status.status = DRPAI_STATUS_RUN;
+        priv->irq_flag = IRQ_CHECK_ENABLE;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+        /* Kick */
+        (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, proc[DRPAI_INDEX_DRP_DESC].address);
+        (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, proc[DRPAI_INDEX_AIMAC_DESC].address, &priv->lock);
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
     }
-    /* Changed link descriptor of drp_desc.bin */
-    if (0 != (proc[DRPAI_INDEX_AIMAC_DESC].size & 0x0F))
+    else if (DRPAI_EXE_DRP == exe_mode)
     {
-        result = -EINVAL;
-        goto end;
-    }
-    iowrite8(0x08, p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13);
-    __flush_dcache_area(p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13, 1);
+        odif_intcnto.ch0 = 0;
+        odif_intcnto.ch1 = 0;
+        odif_intcnto.ch2 = 0;
+        odif_intcnto.ch3 = 0;
 
-    spin_lock_irqsave(&priv->lock, flags);
-    /* Init drpai_status.err */
-    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
-    /* IDLE -> RUN */
-    priv->drpai_status.status = DRPAI_STATUS_RUN;
-    priv->aimac_irq_flag = 0;
-    spin_unlock_irqrestore(&priv->lock, flags);
+        DRPAI_DEBUG_PRINT("DRP exe mode:%d\n", exe_mode);
+        if (copy_from_user(&proc_drp[0], (void __user *)arg, sizeof(proc_drp)))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        /* Check Argument */
+        for (i = 0; i < (seq.num * 2); i++)
+        {
+            if (0 != (proc_drp[i].address & DRPAI_64BYTE_ALIGN))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+        }
+        for (i = 0; i < seq.num; i++)
+        {
+            /* DRPcfg address and size settings */
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 4) = proc_drp[i * 2].address;
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 8) = proc_drp[i * 2].size;
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
+            /* DRP param address and size settings */
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 36) = proc_drp[i * 2 + 1].address;
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 40) = proc_drp[i * 2 + 1].size;
 
-    /* Kick */
-    (void)R_DRPAI_DRP_Start(0, proc[DRPAI_INDEX_DRP_DESC].address);
-    (void)R_DRPAI_AIMAC_Start(0, proc[DRPAI_INDEX_AIMAC_DESC].address);
+            /* Link descriptor settings */
+            if (i < (seq.num - 1))
+            {
+                /* LV enable */
+                *(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 67) = 0x09;
+
+                /* Link pointer settings */
+                if (DRPAI_DRP_NOLOAD == proc_drp[(i + 1) * 2].address)
+                {
+                    *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 68)
+                    = p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * (i + 1)) + DRPAI_DESC_CMD_SIZE;
+                }
+                else
+                {
+                    *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 68)
+                    = p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * (i + 1));
+                }
+            }
+            else
+            {
+                /* LV disable */
+                *(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 67) = 0x08;
+            }
+        }
+        __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
+
+        /* DRPcfg load skip */
+        if (DRPAI_DRP_NOLOAD == proc_drp[0].address)
+        {
+            p_dmabuf_phyaddr = p_dmabuf_phyaddr + DRPAI_DESC_CMD_SIZE;
+        }
+
+        spin_lock_irqsave(&priv->lock, flags);
+        /* Init drpai_status.err */
+        priv->drpai_status.err = DRPAI_ERRINFO_SUCCESS;
+        /* IDLE -> RUN */
+        priv->drpai_status.status = DRPAI_STATUS_RUN;
+        priv->irq_flag = IRQ_CHECK_ENABLE;
+        spin_unlock_irqrestore(&priv->lock, flags);
+        DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+        /* Kick */
+        (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, p_dmabuf_phyaddr);
+        (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM), &priv->lock);
+    }
+    else
+    {
+        // do nothing
+    }
+/* DRP single operation */
+#endif /* CONFIG_ARCH_R9A07G054 */
 
     goto end;
 end:
@@ -1530,34 +1732,38 @@ static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long
     {
         up(&priv->sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     long result = 0;
     struct drpai_priv *priv = drpai_priv;
     struct drpai_rw_status *drpai_rw_status = filp->private_data;
     unsigned long flags;
-/* ISP */
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    /* ISP */
     void (*finish_callback)(int);
     spin_lock_irqsave(&priv->lock, flags);
     finish_callback = drpai_priv->isp_finish_loc;
     spin_unlock_irqrestore(&priv->lock, flags);
-/* ISP */
+    /* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
 
     if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
     {
         result = -ETIMEDOUT;
         goto end;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     if(R_DRPAI_SUCCESS != drpai_reset_device(0))
     {
@@ -1570,26 +1776,30 @@ static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long
     spin_lock_irqsave(&priv->lock, flags);
     priv->drpai_status.err    = DRPAI_ERRINFO_RESET;
     priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag            = IRQ_CHECK_DISABLE;
 
     /* Wake up the process */
     wake_up_interruptible( &drpai_waitq );
     spin_unlock_irqrestore(&priv->lock, flags);
 
-/* ISP */
-/* For reset ISP call back*/    
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    /* ISP */
+    /* For reset ISP call back*/    
     if(NULL != finish_callback)
     {
         /* ERROR No.: ERESTART*/
-        (*finish_callback)(-85);
+        (*finish_callback)(-ERESTART);
     }
     spin_lock_irqsave(&priv->lock, flags);    
     drpai_priv->isp_finish_loc = NULL;
     spin_unlock_irqrestore(&priv->lock, flags);
-/* For reset ISP call back*/
-/* ISP */
+    /* For reset ISP call back*/
+    /* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
 
     result = 0;
     goto end;
@@ -1598,15 +1808,15 @@ static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long
     {
         up(&priv->sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     long result = 0;
     drpai_status_t local_drpai_status;
     struct drpai_priv *priv = drpai_priv;
@@ -1617,7 +1827,7 @@ static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned
         result = -ETIMEDOUT;
         goto end;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT(" \n");
     /* Check NULL */
     if (NULL == arg)
     {
@@ -1627,7 +1837,7 @@ static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned
 
     /* Get the internal state of DRP-AI */
     spin_lock_irqsave(&priv->lock, flags);
-    (void)R_DRPAI_Status(0, &priv->drpai_status);
+    (void)R_DRPAI_Status(drp_base_addr[0], aimac_base_address[0], 0, &priv->drpai_status);
 
     /* Copy arguments from kernel space to user space */
     local_drpai_status = priv->drpai_status;
@@ -1658,14 +1868,14 @@ static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned
     {
         up(&priv->sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("end.\n");
+
     return result;
 }
 
 static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     long result = 0;
     struct drpai_rw_status *drpai_rw_status = filp->private_data;
@@ -1675,8 +1885,8 @@ static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned l
         result = -ETIMEDOUT;
         goto end;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) \n", __func__, current->pid);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     /* Check of writing and reading completion of DRP-AI obj file */
     if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
@@ -1697,20 +1907,22 @@ static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned l
     {
         up(&rw_sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     long result = 0;
     struct drpai_rw_status *drpai_rw_status = filp->private_data;
     drpai_assign_param_t drpai_assign_param_buf;
+    struct drpai_priv *priv = drpai_priv;
     char *vbuf;
+    uint64_t addr, size;
 
     if(unlikely(down_trylock(&rw_sem)))
     {
@@ -1723,7 +1935,7 @@ static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsign
         result = -EINVAL;
         goto end;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
     /* Check status */
     if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
     {
@@ -1747,8 +1959,10 @@ static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsign
         result = -EINVAL;
         goto end;
     }
-    if ((drpai_region_base_addr > drpai_assign_param_buf.obj.address) || 
-        ((drpai_region_base_addr + drpai_region_size) <= (drpai_assign_param_buf.obj.address + drpai_assign_param_buf.obj.size)))
+    addr = priv->bank | (uint64_t)drpai_assign_param_buf.obj.address;
+    size = (uint64_t)drpai_assign_param_buf.obj.size;
+    if ((drpai_region_base_addr > addr) || 
+        ((drpai_region_base_addr + drpai_region_size) <= (addr + size)))
     {
         result = -EINVAL;
         goto end;
@@ -1772,8 +1986,8 @@ static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsign
     {
         up(&rw_sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
@@ -1781,7 +1995,7 @@ static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsign
 /* Note: This function change line variable. so if you use, check your variables address */
 static int8_t get_param_attr(char *line, char *attr, unsigned long *rvalue)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int8_t result = 0;
     char *ptr_stmp, *ptr_etmp;
@@ -1796,13 +2010,40 @@ static int8_t get_param_attr(char *line, char *attr, unsigned long *rvalue)
         goto end;
     }
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
 
+static int8_t drpai_get_sys_bank(uint64_t *bank)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    int8_t result = 0;
+    void __iomem *base = NULL;
+    uint32_t reg_val;
+
+    base = ioremap(sysctrl_region_base_addr, SYS_SIZE);
+    if (!base) {
+        result = -1;
+        goto end;
+    }
+    reg_val = ioread32(base + SYS_DRP_BANK);
+    *bank = ((uint64_t)reg_val & SYS_MASK_DRP) << SYS_SHIFT;
+    DRPAI_DEBUG_PRINT("SYS_DRP_BANK = 0x%08X\n", reg_val);
+    DRPAI_DEBUG_PRINT("bank = 0x%016llX\n", *bank);
+    goto end;
+end:
+    if(base)
+    {
+        iounmap(base);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
     return result;
 }
-static int8_t drp_param_change16(uint32_t base, uint32_t offset, uint16_t value)
+
+static int8_t drp_param_change16(uint64_t base, uint64_t offset, uint16_t value)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
     int8_t result = 0;
     volatile void *virt_addr = 0;
     virt_addr = phys_to_virt(base + offset);
@@ -1814,13 +2055,13 @@ static int8_t drp_param_change16(uint32_t base, uint32_t offset, uint16_t value)
     iowrite16(value, virt_addr);
     __flush_dcache_area(virt_addr, sizeof(value));
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
-static int8_t drp_param_change32(uint32_t base, uint32_t offset, uint32_t value)
+static int8_t drp_param_change32(uint64_t base, uint64_t offset, uint32_t value)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int8_t result = 0;
     volatile void *virt_addr = 0;
@@ -1833,50 +2074,49 @@ static int8_t drp_param_change32(uint32_t base, uint32_t offset, uint32_t value)
     iowrite32(value, virt_addr);
     __flush_dcache_area(virt_addr, sizeof(value));
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
-static int8_t drpai_flush_dcache_input_area(drpai_data_t *input)
+static int8_t drpai_flush_dcache_input_area(uint64_t addr, uint64_t size)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
-    
+    DRPAI_DEBUG_PRINT("start.\n");
+
     int8_t result = 0;
-    drpai_data_t proc = *input;
-    uint32_t flush_addr, flush_size;
-    uint32_t input_saddr, input_eaddr, linux_mem_saddr, linux_mem_eaddr;
+    uint64_t flush_addr, flush_size;
+    uint64_t input_saddr, input_eaddr, linux_mem_saddr, linux_mem_eaddr;
     volatile void *p_input = 0;
 
-    input_saddr      = proc.address;
-    input_eaddr      = proc.address + proc.size - 1;
+    input_saddr      = addr;
+    input_eaddr      = addr + size - 1;
     linux_mem_saddr  = drpai_linux_mem_start;
     linux_mem_eaddr  = drpai_linux_mem_start + drpai_linux_mem_size - 1;
     if ((input_saddr >= linux_mem_saddr) && 
         (input_eaddr <= linux_mem_eaddr))
     {
-        flush_addr = proc.address;
-        flush_size = proc.size;
+        flush_addr = addr;
+        flush_size = size;
     }
     else if ((input_saddr >= linux_mem_saddr) &&
              (input_saddr <= linux_mem_eaddr) &&
              (input_eaddr >  linux_mem_eaddr))
     {
-        flush_addr = proc.address;
-        flush_size = (drpai_linux_mem_start + drpai_linux_mem_size) - proc.address;
+        flush_addr = addr;
+        flush_size = (drpai_linux_mem_start + drpai_linux_mem_size) - addr;
     }
     else if((input_eaddr >= linux_mem_saddr) &&
             (input_eaddr <= linux_mem_eaddr) &&
             (input_saddr <  linux_mem_saddr))
     {
         flush_addr = drpai_linux_mem_start;
-        flush_size = (proc.address + proc.size) - drpai_linux_mem_start;
+        flush_size = (addr + size) - drpai_linux_mem_start;
     }
     else
     {
         flush_addr = 0;
         flush_size = 0;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) flush_addr = 0x%08X, flush_size = 0x%08X\n", __func__, current->pid, flush_addr, flush_size);
+    DRPAI_DEBUG_PRINT("flush_addr = 0x%016llX, flush_size = 0x%08X\n", flush_addr, flush_size);
     if (0 != flush_size)
     {
         /* Input data area cache flush */
@@ -1889,14 +2129,14 @@ static int8_t drpai_flush_dcache_input_area(drpai_data_t *input)
         __flush_dcache_area(p_input, flush_size);
     }
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     long result = 0;
     struct drpai_priv *priv = drpai_priv;
@@ -1907,6 +2147,7 @@ static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsign
     char *ptr, *prev_ptr;
     unsigned long offset_add0, offset_add1;
     int mode = 0;
+    uint64_t addr;
 
     /* Check the internal state of DRP-AI */
     spin_lock_irqsave(&priv->lock, flags);
@@ -1923,7 +2164,7 @@ static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsign
         result = -ERESTART;
         goto end;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     /* Check NULL */
     if (NULL == arg)
@@ -2004,35 +2245,36 @@ static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsign
         }
     } while (ptr);
 
-    DRPAI_DEBUG_PRINT("[%s](pid %d) offset_add0=%d, offset_add1=%d\n", __func__, current->pid, offset_add0, offset_add1);
+    DRPAI_DEBUG_PRINT("offset_add0=%d, offset_add1=%d\n", offset_add0, offset_add1);
 
     /* Change parameters of drp_param.bin to value specified by user app. */
-    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_IMG_OWIDTH, crop_param_buf.img_owidth))
+    addr = priv->bank | (uint64_t)crop_param_buf.obj.address;
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_IMG_OWIDTH, crop_param_buf.img_owidth))
     {
         result = -EFAULT;
         goto end;
     }
-    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_IMG_OHEIGHT, crop_param_buf.img_oheight))
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_IMG_OHEIGHT, crop_param_buf.img_oheight))
     {
         result = -EFAULT;
         goto end;
     }
-    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_CROP_POS_X, crop_param_buf.pos_x))
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_CROP_POS_X, crop_param_buf.pos_x))
     {
         result = -EFAULT;
         goto end;
     }
-    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add0 + DRP_PARAM_CROP_POS_Y, crop_param_buf.pos_y))
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_CROP_POS_Y, crop_param_buf.pos_y))
     {
         result = -EFAULT;
         goto end;
     }
-    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add1 + DRP_PARAM_IMG_IWIDTH, crop_param_buf.img_owidth))
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add1 + DRP_PARAM_IMG_IWIDTH, crop_param_buf.img_owidth))
     {
         result = -EFAULT;
         goto end;
     }
-    if(0 != drp_param_change16(crop_param_buf.obj.address, offset_add1 + DRP_PARAM_IMG_IHEIGHT, crop_param_buf.img_oheight))
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add1 + DRP_PARAM_IMG_IHEIGHT, crop_param_buf.img_oheight))
     {
         result = -EFAULT;
         goto end;
@@ -2044,14 +2286,14 @@ static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsign
     {
         up(&rw_sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     long result = 0;
     struct drpai_priv *priv = drpai_priv;
@@ -2061,6 +2303,7 @@ static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsi
     char *ptr, *prev_ptr;
     unsigned long flags;
     unsigned long offset_add;
+    uint64_t addr, size;
 
     /* Check the internal state of DRP-AI */
     spin_lock_irqsave(&priv->lock, flags);
@@ -2077,7 +2320,7 @@ static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsi
         result = -ERESTART;
         goto end;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw1:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
 
     /* Check NULL */
     if (NULL == arg)
@@ -2145,16 +2388,19 @@ static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsi
         }
     } while (ptr);
 
-    DRPAI_DEBUG_PRINT("[%s](pid %d) offset_add=%d\n", __func__, current->pid, offset_add);
+    DRPAI_DEBUG_PRINT("offset_add=%d\n", offset_add);
 
     /* Check if input is in linux memory region */
-    if(0 != drpai_flush_dcache_input_area(&inout_param_buf.data))
+    addr = priv->bank | (uint64_t)inout_param_buf.data.address;
+    size = (uint64_t)inout_param_buf.data.size;
+    if(0 != drpai_flush_dcache_input_area(addr, size))
     {
         result = -EFAULT;
         goto end;
     }
     /* Change parameters of drp_param.bin to value specified by user app. */
-    if(0 != drp_param_change32(inout_param_buf.obj.address, offset_add + DRP_PARAM_raddr, inout_param_buf.data.address))
+    addr = priv->bank | (uint64_t)inout_param_buf.obj.address;
+    if(0 != drp_param_change32(addr, (uint64_t)offset_add + DRP_PARAM_raddr, inout_param_buf.data.address))
     {
         result = -EFAULT;
         goto end;
@@ -2167,32 +2413,96 @@ static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsi
     {
         up(&rw_sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status_rw2:%d\n", __func__, current->pid, drpai_rw_status->rw_status);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+static long drpai_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    DRPAI_DEBUG_PRINT(" start.\n");
+
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    int i;
+
+    DRPAI_DEBUG_PRINT(" status1:%d\n", priv->drpai_status.status);
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&seq, (void __user *)arg, sizeof(drpai_seq_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check Argument DRP Simgle */
+    if (DRPAI_SEQ_NUM < seq.num)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (DRPAI_EXE_DRP == seq.order[0])
+    {
+        exe_mode = DRPAI_EXE_DRP;
+    }
+    else if (DRPAI_EXE_AI == seq.order[0])
+    {
+        exe_mode = DRPAI_EXE_AI;
+    }
+    else
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" DRP exe mode:%d\n", exe_mode);
+
+    DRPAI_DEBUG_PRINT(" status2:%d\n", priv->drpai_status.status);
+end:
+    DRPAI_DEBUG_PRINT(" end.\n");
 
     return result;
 }
+/* DRP single operation */
+#endif /* CONFIG_ARCH_R9A07G054 */
 
 static int drpai_drp_cpg_init(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int result;
     struct drpai_priv *priv = drpai_priv;
-    unsigned long flags;
     int r_data;
     int32_t i = 0;
     bool is_stop = false;
 
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
     /* Access clock interface */
     clk_prepare_enable(priv->clk_int);
     clk_prepare_enable(priv->clk_aclk_drp);
     clk_prepare_enable(priv->clk_mclk);
     clk_prepare_enable(priv->clk_dclkin);
     clk_prepare_enable(priv->clk_aclk);
+#endif /* CONFIG_ARCH_R9A07G054 */
 
     r_data = reset_control_status(priv->rstc);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) drp reset_control_status before %d \n", __func__, current->pid, r_data);
+    DRPAI_DEBUG_PRINT("CPG reset_control_status before %d \n", r_data);
     
     /* Access reset controller interface */
     reset_control_reset(priv->rstc);
@@ -2204,8 +2514,8 @@ static int drpai_drp_cpg_init(void)
         udelay(1);
         i++;
         r_data = reset_control_status(priv->rstc);
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) drp reset_control_status %d \n", __func__, current->pid, r_data);
-        if(1 == r_data)
+        DRPAI_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
         {
             is_stop = true;
             break;
@@ -2218,8 +2528,8 @@ static int drpai_drp_cpg_init(void)
         usleep_range(100, 200);
         i++;
         r_data = reset_control_status(priv->rstc);
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) drp reset_control_status %d \n", __func__, current->pid, r_data);
-        if(1 == r_data)
+        DRPAI_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
         {
             is_stop = true;
             break;
@@ -2233,20 +2543,125 @@ static int drpai_drp_cpg_init(void)
     else
     {
         result = R_DRPAI_ERR_RESET;
-        DRPAI_DEBUG_PRINT(KERN_INFO "%s: CPG Reset failed. Reset Control Status: %d\n", __func__,  r_data);
+        DRPAI_DEBUG_PRINT("CPG Reset failed. Reset Control Status: %d\n", r_data);
     }
 
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
+static int drpai_open_process(void)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    int ret;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    uint64_t bank;
+
+    /* Initialize CPG */
+    if(R_DRPAI_SUCCESS != drpai_drp_cpg_init())
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+    /* Initialize DRP-AI */
+    drpai_init_device(0);
+
+    /* Reset DRP-AI */
+    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+    /* Initialize DRP-AI */
+    drpai_init_device(0);
+
+    /* Get sys register value */
+    if(0 != drpai_get_sys_bank(&bank))
+    {
+        ret = -EFAULT;
+        goto end;
+    }
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    if(R_DRPAI_SUCCESS != drpai_drp_config_init())
+    {
+        ret = -ENOMEM;
+        goto end;
+    }
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    /* INIT -> IDLE */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->bank = bank;
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    exe_mode = DRPAI_EXE_AI;
+#endif /* CONFIG_ARCH_R9A07G054 */
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int drpai_close_process(void)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    int ret;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    //CPG clock disable
+    DRPAI_DEBUG_PRINT("CPG clock disable\n");
+    clk_disable_unprepare(priv->clk_int);
+    clk_disable_unprepare(priv->clk_aclk_drp);
+    clk_disable_unprepare(priv->clk_mclk);
+    clk_disable_unprepare(priv->clk_dclkin);
+    clk_disable_unprepare(priv->clk_aclk);  
+
+    drpai_drp_config_uninit();
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    /* IDLE -> INIT */
+    /* RUN  -> INIT */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.status = DRPAI_STATUS_INIT;
+    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
 /* ISP */
 static int drpai_drp_config_init(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int result;
     struct drpai_priv *priv = drpai_priv;
@@ -2261,7 +2676,7 @@ static int drpai_drp_config_init(void)
         result = -1;
         goto end;
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) dmabuf:0x%08X, dmaphys:0x%08X\n", __func__, current->pid, p_dmabuf_vaddr, p_dmabuf_phyaddr);
+    DRPAI_DEBUG_PRINT("dmabuf:0x%08X, dmaphys:0x%08X\n", p_dmabuf_vaddr, p_dmabuf_phyaddr);
 
     /* 64bytes alignment adjustment */
     if (0 != (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN))
@@ -2270,8 +2685,13 @@ static int drpai_drp_config_init(void)
         p_dmabuf_phyaddr = p_dmabuf_phyaddr + (0x40 - (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN));
     }
 
+/* DRP single operation */
     /* Deploy drp_single_desc */
-    memcpy(p_dmabuf_vaddr, &drp_single_desc_bin[0], sizeof(drp_single_desc_bin));
+    for (i = 0; i < DRPAI_SEQ_NUM; i++)
+    {
+        memcpy(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i), &drp_single_desc_bin[0], sizeof(drp_single_desc_bin));
+    }
+/* DRP single operation */
 
     __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
 
@@ -2279,82 +2699,54 @@ static int drpai_drp_config_init(void)
 
     goto end;
 end:
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 static void drpai_drp_config_uninit(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     struct drpai_priv *priv = drpai_priv;
     struct device *dev = &priv->pdev->dev;
 
     dma_free_coherent(dev, DRPAI_CMA_SIZE, p_dmabuf_vaddr, p_dmabuf_phyaddr);
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 }
 
 int drpai_open_k(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
     
     int result = 0;
     struct drpai_priv *priv = drpai_priv;
     unsigned long flags;
+    uint64_t bank;
     
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
     if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
     {
         result = -ETIMEDOUT;
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ETIMEDOUT.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("ETIMEDOUT.\n");
         goto end;
     }  
 
-    if(drpai_drp_config_init())
-    {
-        result = -ENOMEM;
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ENOMEM.\n", __func__, current->pid);
-        goto end;
-    }
-
     if(likely(1 == refcount_read(&priv->count)))
     {
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) Initialize DRP-AI\n", __func__, current->pid);
-
-        /* CPG Reset */
-        if(drpai_drp_cpg_init())
+        result = drpai_open_process();
+        if(R_DRPAI_SUCCESS != result)
         {
-            result = -EIO;
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) DRP CPG HW error EIO.\n", __func__, current->pid);
             goto end;
         }
-
-        /* Initialize DRP-AI */
-        drpai_init_device(0);
-
-        /* Reset DRP-AI */
-        if(R_DRPAI_SUCCESS != drpai_reset_device(0))
-        {
-            result = -EIO;
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) DRP HW error EIO.\n", __func__, current->pid);
-            goto end;
-        }
-
-        /* Initialize DRP-AI */
-        drpai_init_device(0);
-
-        /* INIT -> IDLE */
-        spin_lock_irqsave(&priv->lock, flags);
-        priv->drpai_status.status = DRPAI_STATUS_IDLE;
-        spin_unlock_irqrestore(&priv->lock, flags);
     }
 
     /* Increment reference count */
     refcount_inc(&priv->count);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:%d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+
     goto end;
 end:
     if(-ETIMEDOUT != result)
@@ -2362,30 +2754,26 @@ int drpai_open_k(void)
         /* Return semaphore when no ETIMEOUT */
         up(&priv->sem);
     }
-    if(-EIO == result)
-    {
-        /* Release Linux CMA when hardware error */
-        drpai_drp_config_uninit();
-    }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 int drpai_close_k(void)
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int result = 0;
     struct drpai_priv *priv = drpai_priv;
     unsigned long flags;
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
     if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
     {
         result = -ETIMEDOUT;
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ETIMEOUT.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
         goto end;
     } 
 
@@ -2395,45 +2783,24 @@ int drpai_close_k(void)
     {
         spin_unlock_irqrestore(&priv->lock, flags);
         result = -EACCES;        
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EACCES.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("EACCES.\n");
         goto end;
     }
     spin_unlock_irqrestore(&priv->lock, flags);
 
     if(2 == refcount_read(&priv->count))
     {
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start DRP-AI reset\n", __func__, current->pid);
-        if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+        result = drpai_close_process();
+        if(R_DRPAI_SUCCESS != result)
         {
-            result = -EIO;              
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EIO.\n", __func__, current->pid);
             goto end;
         }
-
-        // CPG clock disable
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) CPG clock disable\n", __func__, current->pid);
-        clk_disable_unprepare(priv->clk_int);
-        clk_disable_unprepare(priv->clk_aclk_drp);
-        clk_disable_unprepare(priv->clk_mclk);
-        clk_disable_unprepare(priv->clk_dclkin);
-        clk_disable_unprepare(priv->clk_aclk);  
-
-        /* IDLE -> INIT */
-        /* RUN  -> INIT */
-        spin_lock_irqsave(&priv->lock, flags);
-        priv->drpai_status.status = DRPAI_STATUS_INIT;
-        priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
-        spin_unlock_irqrestore(&priv->lock, flags);
-
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) done DRP-AI reset\n", __func__, current->pid);
     }
-    /* Release Linux CMA */
-    drpai_drp_config_uninit();
 
     /* Decrement referenece count*/
     refcount_dec(&priv->count);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
 
     goto end;
 end:
@@ -2442,14 +2809,14 @@ int drpai_close_k(void)
         /* Return semaphore when no ETIMEOUT */
         up(&priv->sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
 
     return result;
 }
 
 int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
 {
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) start.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("start.\n");
 
     int result = 0;
     int wait_ret = 0;
@@ -2465,11 +2832,11 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
     if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
     {
         result = -ETIMEDOUT;
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) ETIMEOUT.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
         goto end;
     }
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status1:   %d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
 
     /* Check H/W Error */
     spin_lock_irqsave(&priv->lock, flags);
@@ -2477,7 +2844,7 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
     {
         spin_unlock_irqrestore(&priv->lock, flags);
         result = -EIO;   
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EIO.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("EIO.\n");
         goto end;
     }
     spin_unlock_irqrestore(&priv->lock, flags);
@@ -2488,7 +2855,7 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
     {
         spin_unlock_irqrestore(&priv->lock, flags);
         result = -EBUSY;   
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EBUSY.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("EBUSY.\n");
         goto end;
     }
     spin_unlock_irqrestore(&priv->lock, flags);
@@ -2499,7 +2866,7 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
     {
         spin_unlock_irqrestore(&priv->lock, flags);
         result = -EACCES;   
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EACCES.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("EACCES.\n");
         goto end;
     }
     spin_unlock_irqrestore(&priv->lock, flags);
@@ -2508,7 +2875,7 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
     if (NULL == isp_finish)
     {
         result = -EINVAL; 
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EINVAL NULL function pointer.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("EINVAL NULL function pointer.\n");
         goto end;
     }
     /* Referring the call back function info from ISP Lib */
@@ -2518,7 +2885,7 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
     if (NULL == arg)
     {
         result = -EINVAL; 
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EINVAL NULL argument pointer.\n", __func__, current->pid);
+        DRPAI_DEBUG_PRINT("EINVAL NULL argument pointer.\n");
         goto end;
     }
     /* Referring the obj file info from ISP Lib */
@@ -2531,10 +2898,10 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
     odif_intcnto.ch3 = 0;
     spin_unlock_irqrestore(&priv->lock, flags);
 
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
-    DRPAI_DEBUG_PRINT(KERN_INFO "ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
 
     /* Check Argument 64-byte*/
     for (i = 0; i < 2; i++)
@@ -2542,7 +2909,7 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
         if (0 != (proc_k[i].address & DRPAI_64BYTE_ALIGN))
         {
             result = -EINVAL; 
-            DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) EINVAL argument. Not 64-byte aligned.\n", __func__, current->pid);
+            DRPAI_DEBUG_PRINT("EINVAL argument. Not 64-byte aligned.\n");
             goto end;
         }
     }
@@ -2553,13 +2920,13 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
         *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 4) = proc_k[i * 2].address;
         *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 8) = proc_k[i * 2].size;
 
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) cfg_address:0x%08X, cfg_size:0x%08X\n", __func__, current->pid, proc_k[i * 2].address, proc_k[i * 2].size);
+        DRPAI_DEBUG_PRINT("cfg_address:0x%08X, cfg_size:0x%08X\n", proc_k[i * 2].address, proc_k[i * 2].size);
 
         /* DRP param address and size settings */
         *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 36) = proc_k[i * 2 + 1].address;
         *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 40) = proc_k[i * 2 + 1].size;
 
-        DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) parm_address:0x%08X, parm_size:0x%08X\n", __func__, current->pid, proc_k[i * 2 + 1].address, proc_k[i * 2 + 1].size);
+        DRPAI_DEBUG_PRINT("parm_address:0x%08X, parm_size:0x%08X\n", proc_k[i * 2 + 1].address, proc_k[i * 2 + 1].size);
 
     }
     __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
@@ -2570,12 +2937,12 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
 
     /* IDLE -> RUN */
     priv->drpai_status.status = DRPAI_STATUS_RUN;
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) status2:   %d\n", __func__, current->pid, priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
     spin_unlock_irqrestore(&priv->lock, flags);
 
     /* Kick */
-    (void)R_DRPAI_DRP_Start(0, p_dmabuf_phyaddr);
-    (void)R_DRPAI_AIMAC_Start(0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE));
+    (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, p_dmabuf_phyaddr);
+    (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM), &priv->lock);
 
     goto end;
 end:
@@ -2584,7 +2951,7 @@ int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
         /* Return semaphore when no ETIMEOUT */
         up(&priv->sem);
     }
-    DRPAI_DEBUG_PRINT(KERN_INFO "[%s](pid %d) end.\n", __func__, current->pid);
+    DRPAI_DEBUG_PRINT("end.\n");
     
     return result;
 }
@@ -2594,10 +2961,21 @@ EXPORT_SYMBOL(drpai_open_k);
 EXPORT_SYMBOL(drpai_close_k);
 EXPORT_SYMBOL(drpai_start_k);
 /* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
 
 module_platform_driver(drpai_platform_driver);
 MODULE_DEVICE_TABLE(of, drpai_match);
-MODULE_DESCRIPTION("RZ/V2L DRP-AI driver");
+
+#if defined(CONFIG_ARCH_R9A09G011GBG) 
+/* V2M conditional compilation */
+MODULE_DESCRIPTION("RZ/V2M DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2MA conditional compilation */
+MODULE_DESCRIPTION("RZ/V2MA DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+MODULE_DESCRIPTION("RZ/V2L DRPAI driver");
+#endif
 MODULE_AUTHOR("Renesas Electronics Corporation");
 MODULE_LICENSE("GPL v2");
 
diff --git a/drivers/drpai/drpai-reg.h b/drivers/drpai/drpai-reg.h
index 82a6c2b373f0..2f88206cd8e6 100644
--- a/drivers/drpai/drpai-reg.h
+++ b/drivers/drpai/drpai-reg.h
@@ -1,5 +1,5 @@
 /*
- * Driver for the Renesas RZ/V2L DRP-AI unit
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
  *
  * Copyright (C) 2021 Renesas Electronics Corporation
  *
@@ -39,10 +39,8 @@
 #define ODIF_DMACTLO2                   (0x81A300)
 #define ODIF_DMACTLO3                   (0x81A400)
 #define ODIF_DMACTLCR                   (0x81A900)
-/* ISP */
 /* Normal Interrupt mask */
 #define ODIF_INTMSK                     (0x81A004)
-/* ISP */
 /* Err Interrupt mask */
 #define IDIF_EINTMSK                    (0x81900C)
 #define IDIF_EINTMSK_DSC                (0x819014)
@@ -55,7 +53,6 @@
 --------------------------------------------------------------------------------------------------*/
 #define DSCC_DPA                        (0x818108)
 #define DSCC_DCTL                       (0x818100)
-/* ISP */
 /*--------------------------------------------------------------------------------------------------
   DPP NMLINT register
 --------------------------------------------------------------------------------------------------*/
@@ -64,7 +61,6 @@
 #define ODIF_INTCNTO1                   (0x81A218)
 #define ODIF_INTCNTO2                   (0x81A318)
 #define ODIF_INTCNTO3                   (0x81A418)
-/* ISP */
 /*--------------------------------------------------------------------------------------------------
   DRP ERRINT register
 --------------------------------------------------------------------------------------------------*/
@@ -231,6 +227,25 @@
 #define SYNCTBL_TBL13                   (0x140834)
 #define SYNCTBL_TBL14                   (0x140838)
 #define SYNCTBL_TBL15                   (0x14083C)
+/*--------------------------------------------------------------------------------------------------
+  DRP Reset register
+--------------------------------------------------------------------------------------------------*/
+#define DRP_SYNCTBL_TBL0                (0x81E000)
+#define DRP_SYNCTBL_TBL1                (0x81E004)
+#define DRP_SYNCTBL_TBL2                (0x81E008)
+#define DRP_SYNCTBL_TBL3                (0x81E00C)
+#define DRP_SYNCTBL_TBL4                (0x81E010)
+#define DRP_SYNCTBL_TBL5                (0x81E014)
+#define DRP_SYNCTBL_TBL6                (0x81E018)
+#define DRP_SYNCTBL_TBL7                (0x81E01C)
+#define DRP_SYNCTBL_TBL8                (0x81E020)
+#define DRP_SYNCTBL_TBL9                (0x81E024)
+#define DRP_SYNCTBL_TBL10               (0x81E028)
+#define DRP_SYNCTBL_TBL11               (0x81E02C)
+#define DRP_SYNCTBL_TBL12               (0x81E030)
+#define DRP_SYNCTBL_TBL13               (0x81E034)
+#define DRP_SYNCTBL_TBL14               (0x81E038)
+#define DRP_SYNCTBL_TBL15               (0x81E03C)
 /*--------------------------------------------------------------------------------------------------
   DRP-AI Internal state register
 --------------------------------------------------------------------------------------------------*/
diff --git a/include/uapi/linux/drpai.h b/include/uapi/linux/drpai.h
index ea13e0ba9501..b8fa8733f71d 100644
--- a/include/uapi/linux/drpai.h
+++ b/include/uapi/linux/drpai.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 /*
- * Driver for the Renesas RZ/V2L DRP-AI unit
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
  *
  * Copyright (C) 2021 Renesas Electronics Corporation
  *
@@ -34,6 +34,7 @@
 #define DRPAI_ASSIGN_PARAM          _IOW (DRPAI_IO_TYPE, 6, drpai_assign_param_t)
 #define DRPAI_PREPOST_CROP          _IOW (DRPAI_IO_TYPE, 7, drpai_crop_t)
 #define DRPAI_PREPOST_INADDR        _IOW (DRPAI_IO_TYPE, 8, drpai_inout_t)
+#define DRPAI_SET_SEQ               _IOW (DRPAI_IO_TYPE, 6, drpai_seq_t)
 
 #define DRPAI_INDEX_NUM             (7)
 #define DRPAI_INDEX_INPUT           (0)
@@ -51,6 +52,10 @@
 #define DRPAI_ERRINFO_AIMAC_ERR     (-2)
 #define DRPAI_ERRINFO_RESET         (-3)
 #define DRPAI_RESERVED_NUM          (10)
+#define DRPAI_SEQ_NUM               (20)
+#define DRPAI_EXE_AI                (1)
+#define DRPAI_EXE_DRP               (2)
+#define DRPAI_DRP_NOLOAD            (0)
 #define DRPAI_MAX_NODE_NAME         (256)
 
 #ifdef __cplusplus
@@ -92,6 +97,12 @@ typedef struct drpai_inout
     drpai_data_t obj;
 } drpai_inout_t;
 
+typedef struct drpai_seq
+{
+    uint32_t        num;
+    uint32_t        order[DRPAI_SEQ_NUM];
+} drpai_seq_t;
+
 #ifdef __cplusplus
 }
 #endif
-- 
2.17.1

